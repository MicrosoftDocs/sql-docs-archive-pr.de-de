---
title: Richtlinien für Transaktions Isolations Stufen mit Speicher optimierten Tabellen | Microsoft-Dokumentation
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: e365e9ca-c34b-44ae-840c-10e599fa614f
author: stevestein
ms.author: sstein
ms.openlocfilehash: 834c5950a8f8b0ddf8854d06c6fb1073a264fc22
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/04/2020
ms.locfileid: "87701565"
---
# <a name="guidelines-for-transaction-isolation-levels-with-memory-optimized-tables"></a><span data-ttu-id="b6ead-102">Richtlinien für Transaktionsisolationsstufen mit speicheroptimierten Tabellen</span><span class="sxs-lookup"><span data-stu-id="b6ead-102">Guidelines for Transaction Isolation Levels with Memory-Optimized Tables</span></span>
  <span data-ttu-id="b6ead-103">In vielen Szenarien müssen Sie die Transaktionsisolationsstufe angeben.</span><span class="sxs-lookup"><span data-stu-id="b6ead-103">In many scenarios, you must specify the transaction isolation level.</span></span> <span data-ttu-id="b6ead-104">Transaktionsisolation für speicheroptimierte Tabellen unterscheidet sich von Transaktionsisolation für datenträgerbasierte Tabellen.</span><span class="sxs-lookup"><span data-stu-id="b6ead-104">Transaction isolation for memory-optimized tables differs from disk-based tables.</span></span>  
  
 <span data-ttu-id="b6ead-105">Anforderungen zum Angeben der Transaktionsisolationsstufe:</span><span class="sxs-lookup"><span data-stu-id="b6ead-105">Requirements for specifying transaction isolation level:</span></span>  
  
-   <span data-ttu-id="b6ead-106">TRANSAKTIONSISOLATIONSSTUFE ist eine erforderliche Option für den ATOMIC-Block, der den Inhalt einer systemintern kompilierten gespeicherten Prozedur enthält.</span><span class="sxs-lookup"><span data-stu-id="b6ead-106">TRANSACTION ISOLATION LEVEL is a required option for the ATOMIC block comprising the content of a natively compiled stored procedure.</span></span>  
  
-   <span data-ttu-id="b6ead-107">Aufgrund von Einschränkungen bei der Isolationsstufenverwendung in containerübergreifenden Transaktionen, muss die Verwendung speicheroptimierter Tabellen in interpretiertem [!INCLUDE[tsql](../includes/tsql-md.md)] häufig von einem Tabellenhinweis begleitet werden, der die Isolationsstufe für den Tabellenzugriff angibt.</span><span class="sxs-lookup"><span data-stu-id="b6ead-107">Because of restrictions on isolation level use in cross-container transactions, uses of memory-optimized tables in interpreted [!INCLUDE[tsql](../includes/tsql-md.md)] must often be accompanied by a table hint specifying the isolation level used to access the table.</span></span> <span data-ttu-id="b6ead-108">Weitere Informationen zu Isolations Stufen hinweisen und Container übergreifenden Transaktionen finden Sie unter [Transaktions Isolations Stufen](../../2014/database-engine/transaction-isolation-levels.md).</span><span class="sxs-lookup"><span data-stu-id="b6ead-108">For more information about isolation level hints and cross-container transactions, see [Transaction Isolation Levels](../../2014/database-engine/transaction-isolation-levels.md).</span></span>  
  
-   <span data-ttu-id="b6ead-109">Die gewünschte Transaktionsisolationsstufe muss explizit deklariert werden.</span><span class="sxs-lookup"><span data-stu-id="b6ead-109">The desired transaction isolation level must be explicitly declared.</span></span> <span data-ttu-id="b6ead-110">Es ist nicht möglich, Sperrhinweise zu verwenden (etwa XLOCK), um die Isolation bestimmter Zeilen oder Tabellen in der Transaktion sicherzustellen.</span><span class="sxs-lookup"><span data-stu-id="b6ead-110">It is not possible to use locking hints (such as XLOCK) to guarantee the isolation of certain rows or tables in the transaction.</span></span>  
  
-   <span data-ttu-id="b6ead-111">Die Anwendung, die auf die Datenbank zugreift, sollte Wiederholungslogik implementieren, um Fehler zu behandeln, die aus Konflikten aufgrund fehlgeschlagener Transaktionen, Überprüfungsfehlern und Commitabhängigkeitsfehlern resultieren.</span><span class="sxs-lookup"><span data-stu-id="b6ead-111">The application accessing the database should implement retry logic to deal with errors resulting from transaction-dooming conflicts, validation failures, and commit-dependency failures.</span></span> <span data-ttu-id="b6ead-112">Beachten Sie, dass Commitabhängigkeitsfehler auch bei schreibgeschützten Transaktionen auftreten können.</span><span class="sxs-lookup"><span data-stu-id="b6ead-112">Note that commit dependency failures can occur even with read-only transactions.</span></span>  
  
-   <span data-ttu-id="b6ead-113">Transaktionen mit langer Laufzeit sollten bei speicheroptimierten Tabellen vermieden werden.</span><span class="sxs-lookup"><span data-stu-id="b6ead-113">Long-running transactions should be avoided with memory-optimized tables.</span></span> <span data-ttu-id="b6ead-114">Derartige Transaktionen erhöhen die Wahrscheinlichkeit, dass Konflikte auftreten und Transaktionen infolgedessen beendet werden.</span><span class="sxs-lookup"><span data-stu-id="b6ead-114">Such transactions increase the likelihood of conflicts and subsequent transaction terminations.</span></span> <span data-ttu-id="b6ead-115">Eine Transaktion mit langer Ausführungszeit verzögert außerdem die Garbage Collection.</span><span class="sxs-lookup"><span data-stu-id="b6ead-115">A long-running transaction also defers garbage collection.</span></span> <span data-ttu-id="b6ead-116">Je länger eine Transaktion ausgeführt wird, desto länger werden zuletzt gelöschte Zeilenversionen von In-Memory OLTP beibehalten, wodurch die Suchleistung bei neuen Transaktionen beeinträchtigt werden kann.</span><span class="sxs-lookup"><span data-stu-id="b6ead-116">The longer a transaction runs, the longer In-Memory OLTP keeps recently deleted row versions, which can decrease lookup performance for new transactions.</span></span>  
  
 <span data-ttu-id="b6ead-117">Bei datenträgerbasierten Tabellen werden für die Transaktionsisolation normalerweise Sperren und Blockierungen eingesetzt.</span><span class="sxs-lookup"><span data-stu-id="b6ead-117">Disk-based tables typically rely on locking and blocking for transaction isolation.</span></span> <span data-ttu-id="b6ead-118">Speicheroptimierte Tabellen basieren auf Multiversionsverwaltung und Konflikterkennung, um Isolation sicherzustellen.</span><span class="sxs-lookup"><span data-stu-id="b6ead-118">Memory-optimized tables rely on multi-versioning and conflict detection to guarantee isolation.</span></span> <span data-ttu-id="b6ead-119">Ausführliche Informationen finden Sie im Abschnitt zur Konflikterkennung, zur Überprüfung und zu Commitabhängigkeitsüberprüfungen unter [Transactions in Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="b6ead-119">For details, see the section on Conflict Detection, Validation, and Commit Dependency Checks in [Transactions in Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="b6ead-120">Datenträgerbasierte Tabellen ermöglichen Multiversionsverwaltung mit den Isolationsstufen SNAPSHOT und READ_COMMITTED_SNAPSHOT.</span><span class="sxs-lookup"><span data-stu-id="b6ead-120">Disk-based tables do allow multi-versioning with the isolation levels SNAPSHOT and READ_COMMITTED_SNAPSHOT.</span></span> <span data-ttu-id="b6ead-121">Bei speicheroptimierten Tabellen sind alle Isolationsstufen multiversionsbasiert, einschließlich REPEATABLE READ und SERIALIZABLE.</span><span class="sxs-lookup"><span data-stu-id="b6ead-121">For memory-optimized tables all isolation levels are multi-version based, including REPEATABLE READ and SERIALIZABLE.</span></span>  
  
## <a name="types-of-transactions"></a><span data-ttu-id="b6ead-122">Transaktionstypen</span><span class="sxs-lookup"><span data-stu-id="b6ead-122">Types of Transactions</span></span>  
 <span data-ttu-id="b6ead-123">Jede Abfrage in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] wird im Kontext einer Transaktion ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="b6ead-123">Every query in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] runs in the context of a transaction.</span></span>  
  
 <span data-ttu-id="b6ead-124">Es gibt drei Typen von Transaktionen in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]:</span><span class="sxs-lookup"><span data-stu-id="b6ead-124">There are three types of transactions in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]:</span></span>  
  
-   <span data-ttu-id="b6ead-125">Autocommittransaktionen.</span><span class="sxs-lookup"><span data-stu-id="b6ead-125">Autocommit transactions.</span></span> <span data-ttu-id="b6ead-126">Wenn es keinen aktiven Transaktionskontext gibt und implizite Transaktionen in der Sitzung auf ON festgelegt werden, verfügt jede Abfrage über einen eigenen Transaktionskontext.</span><span class="sxs-lookup"><span data-stu-id="b6ead-126">If there is no active transaction context and implicit transactions are not set to ON in the session, each query has its own transaction context.</span></span> <span data-ttu-id="b6ead-127">Die Transaktion startet, wenn die Ausführung der Anweisung beginnt, und endet, wenn die Anweisung abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="b6ead-127">The transaction starts when the statement starts execution, and completes when the statement finishes.</span></span>  
  
-   <span data-ttu-id="b6ead-128">Explizite Transaktionen.</span><span class="sxs-lookup"><span data-stu-id="b6ead-128">Explicit transactions.</span></span> <span data-ttu-id="b6ead-129">Der Benutzer startet die Transaktion durch eine explizite BEGIN TRAN- oder BEGIN ATOMIC-Anweisung.</span><span class="sxs-lookup"><span data-stu-id="b6ead-129">The user starts the transaction through an explicit BEGIN TRAN or BEGIN ATOMIC.</span></span> <span data-ttu-id="b6ead-130">Die Transaktion wird nach der entsprechenden COMMIT- und ROLLBACK- oder END-Anweisung abgeschlossen (im Fall eines ATOMIC-Blocks).</span><span class="sxs-lookup"><span data-stu-id="b6ead-130">The transaction is completed following the corresponding COMMIT and ROLLBACK or END (in the case of an atomic block).</span></span>  
  
-   <span data-ttu-id="b6ead-131">Implizite Transaktionen.</span><span class="sxs-lookup"><span data-stu-id="b6ead-131">Implicit transactions.</span></span> <span data-ttu-id="b6ead-132">Wenn die Option IMPLICIT_TRANSACTIONS auf ON festgelegt ist, wird eine Transaktion implizit gestartet, wenn der Benutzer eine Anweisung ausführt und es keinen aktiven Transaktionskontext gibt.</span><span class="sxs-lookup"><span data-stu-id="b6ead-132">When the option IMPLICIT_TRANSACTIONS is set to ON, a transaction is started implicitly whenever the user executes a statement and there is no active transaction context.</span></span> <span data-ttu-id="b6ead-133">Die Transaktion wird durch eine explizite COMMIT- und ROLLBACK-Anweisung abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="b6ead-133">The transaction is completed through an explicit COMMIT and ROLLBACK.</span></span>  
  
## <a name="baseline-read-committed-isolation"></a><span data-ttu-id="b6ead-134">READ COMMITTED-Basislinienisolation</span><span class="sxs-lookup"><span data-stu-id="b6ead-134">Baseline READ COMMITTED Isolation</span></span>  
 <span data-ttu-id="b6ead-135">Die Standardisolationsstufe in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]ist READ COMMITTED.</span><span class="sxs-lookup"><span data-stu-id="b6ead-135">READ COMMITTED is the default isolation level in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span>  
  
 <span data-ttu-id="b6ead-136">Die READ COMMITTED-Isolationsstufe gewährleistet, dass Transaktionen nicht auf Daten zugreifen, für die nach einer Änderung außerhalb der aktuellen Transaktion noch kein Commit ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="b6ead-136">The isolation level READ COMMITTED guarantees that transactions do not see any uncommitted data from changes outside the current transaction.</span></span> <span data-ttu-id="b6ead-137">Die Transaktion liest also nur Daten, für die ein Commit in der Datenbank ausgeführt wurde oder die von der aktuellen Transaktion geändert wurden.</span><span class="sxs-lookup"><span data-stu-id="b6ead-137">In other words, the transaction only reads data which has either been committed to the database, or has been changed by the current transaction.</span></span>  
  
 <span data-ttu-id="b6ead-138">Bei allen Isolationsstufen, die für speicheroptimierte Tabellen unterstützt werden, ist Read Committed sichergestellt.</span><span class="sxs-lookup"><span data-stu-id="b6ead-138">All isolation levels supported for memory-optimized tables provide the read committed guarantee.</span></span> <span data-ttu-id="b6ead-139">Wenn die Transaktion keine stärkeren Garantien erfordert, können Sie daher eine beliebige Isolationsstufe verwenden, die für speicheroptimierte Tabellen unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="b6ead-139">Therefore, if the transaction does not require stronger guarantees, you can use any of the isolation levels supported for memory-optimized tables.</span></span> <span data-ttu-id="b6ead-140">SNAPSHOT beansprucht im Vergleich zu anderen Isolationsstufen die wenigsten Systemressourcen.</span><span class="sxs-lookup"><span data-stu-id="b6ead-140">SNAPSHOT uses the fewest system resources, compared to other isolation levels.</span></span>  
  
 <span data-ttu-id="b6ead-141">Die Garantie, welche die SNAPSHOT-Isolationsstufe (die unterste Ebene der Isolation, die für speicheroptimierte Tabellen unterstützt wird) bietet, umfasst die READ COMMITTED-Garantien.</span><span class="sxs-lookup"><span data-stu-id="b6ead-141">The guarantee provided by the SNAPSHOT isolation level (the lowest level of isolation supported for memory-optimized tables) includes the guarantees of READ COMMITTED.</span></span> <span data-ttu-id="b6ead-142">Jede Anweisung in der Transaktion liest die gleiche, konsistente Version der Datenbank.</span><span class="sxs-lookup"><span data-stu-id="b6ead-142">Every statement in the transaction reads the same, consistent version of the database.</span></span> <span data-ttu-id="b6ead-143">Er werden nicht nur alle von der Transaktion gelesenen Zeilen an die Datenbank übergeben, sondern bei allen Lesevorgängen wird auch der Satz von Änderungen angezeigt, die durch den gleichen Transaktionssatz ausgeführt wurden.</span><span class="sxs-lookup"><span data-stu-id="b6ead-143">Not only are all the rows read by the transaction committed to the database, also all the read operations see the set of changes made by the same set of transactions.</span></span>  
  
 <span data-ttu-id="b6ead-144">**Richtlinie**: Wenn nur die READ COMMITTED-Isolationsgarantie erforderlich ist, verwenden Sie die SNAPSHOT-Isolation mit systemintern kompilierten gespeicherten Prozeduren und für den Zugriff auf speicheroptimierte Tabellen über interpretiertes [!INCLUDE[tsql](../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="b6ead-144">**Guideline**: If only the READ COMMITTED isolation guarantee is required, use SNAPSHOT isolation with natively compiled stored procedures and for accessing memory-optimized tables through interpreted [!INCLUDE[tsql](../includes/tsql-md.md)].</span></span>  
  
 <span data-ttu-id="b6ead-145">Bei speicheroptimierten Tabellen wird für Autocommittransaktionen die Isolationsstufe READ COMMITTED implizit SNAPSHOT zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="b6ead-145">For autocommit transactions, the isolation level READ COMMITTED is implicitly mapped to SNAPSHOT for memory-optimized tables.</span></span> <span data-ttu-id="b6ead-146">Wenn die Sitzungseinstellung TRANSACTION ISOLATION LEVEL auf READ COMMITTED festgelegt wird, ist es daher nicht notwendig, die Isolationsstufe durch einen Tabellenhinweis anzugeben, wenn Sie auf speicheroptimierte Tabellen zugreifen.</span><span class="sxs-lookup"><span data-stu-id="b6ead-146">Therefore, if the TRANSACTION ISOLATION LEVEL session setting is set to READ COMMITTED, it is not necessary to specify the isolation level through a table hint when accessing memory-optimized tables.</span></span>  
  
 <span data-ttu-id="b6ead-147">Das folgende Beispiel für eine Autocommittransaktion zeigt einen Join zwischen einer speicheroptimierten Tabelle [Customers] und einer normalen Tabelle [Order History] als Teil eines Ad-hoc-Batches:</span><span class="sxs-lookup"><span data-stu-id="b6ead-147">The following autocommit transaction example shows a join between a memory-optimized table Customers and a regular table [Order History], as part of an ad hoc batch:</span></span>  
  
```sql  
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;  
GO  
SELECT *   
FROM dbo.Customers AS c   
LEFT JOIN dbo.[Order History] AS oh   
    ON c.customer_id = oh.customer_id;  
```  
  
 <span data-ttu-id="b6ead-148">Das folgende Beispiel für explizite oder implizite Transaktionen zeigt den gleichen Join, dieses Mal aber in einer expliziten Benutzertransaktion.</span><span class="sxs-lookup"><span data-stu-id="b6ead-148">The following explicit or implicit transactions example shows the same join, but this time in an explicit user transaction.</span></span> <span data-ttu-id="b6ead-149">Auf die speicheroptimierte Tabelle [Customers] wird unter der SNAPSHOT-Isolation zugegriffen, wie durch den Tabellenhinweis WITH (SNAPSHOT) angegeben, und auf die normale Tabelle [Order History] wird unter der READ COMMITTED-Isolation zugegriffen:</span><span class="sxs-lookup"><span data-stu-id="b6ead-149">The memory-optimized table Customers is accessed under snapshot isolation, as indicated through the table hint WITH (SNAPSHOT), and the regular table [Order History] is accessed under read committed isolation:</span></span>  
  
```sql  
SET TRANSACTION ISOLATION LEVEL READ COMMITTED  
GO  
BEGIN TRAN  
SELECT * FROM dbo.Customers c with (SNAPSHOT)   
LEFT JOIN dbo.[Order History] oh   
    ON c.customer_id=oh.customer_id  
...  
COMMIT  
```  
  
### <a name="operational-differences"></a><span data-ttu-id="b6ead-150">Betriebliche Unterschiede</span><span class="sxs-lookup"><span data-stu-id="b6ead-150">Operational Differences</span></span>  
 <span data-ttu-id="b6ead-151">Neben der READ COMMITTED-Garantie gibt es auch zwei wichtige Implementierungsdetails, auf denen Anwendungen mit datenträgerbasierten Tabellen basieren können.</span><span class="sxs-lookup"><span data-stu-id="b6ead-151">Besides the read committed guarantee, there are also two key implementation details that applications using disk-based tables may rely on.</span></span> <span data-ttu-id="b6ead-152">Beachten Sie Folgendes, wenn Sie eine datenträgerbasierte Tabelle, auf die mithilfe von READ COMMITTED-Isolation zugegriffen wird, in eine speicheroptimierte Tabelle konvertieren, auf die mithilfe von SNAPSHOT-Isolation zugegriffen wird:</span><span class="sxs-lookup"><span data-stu-id="b6ead-152">Be aware of the following when converting a disk-based table that is accessed using READ COMMITTED isolation to a memory-optimized table that is accessed using SNAPSHOT isolation:</span></span>  
  
-   <span data-ttu-id="b6ead-153">Die Implementierung der READ COMMITTED-Isolationsstufe für datenträgerbasierte Tabellen (vorausgesetzt, READ_COMMITTED_SNAPSHOT ist OFF) verwendet Sperren, um Konflikte zwischen Readern und Writern zu verhindern.</span><span class="sxs-lookup"><span data-stu-id="b6ead-153">The implementation of the READ COMMITTED isolation level for disk-based tables (assuming READ_COMMITTED_SNAPSHOT is OFF) uses locks to prevent conflicts between readers and writers.</span></span> <span data-ttu-id="b6ead-154">Wenn ein Writer mit der Aktualisierung einer Zeile beginnt, wird eine Sperre gesetzt, die erst aufgehoben wird, wenn für die Transaktion ein Commit ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="b6ead-154">When a writer starts updating a row, it takes a lock and does not release the lock until the transaction is committed.</span></span> <span data-ttu-id="b6ead-155">Alle Lesevorgänge werden blockiert und warten darauf, dass für die Schreibtransaktion ein Commit ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="b6ead-155">Any read operations are blocked and will wait for the write transaction to commit.</span></span>  
  
     <span data-ttu-id="b6ead-156">Einige Anwendungen setzen möglicherweise voraus, dass Reader immer warten, bis Writer einen Commit durchgeführt haben, insbesondere wenn auf der Anwendungsebene eine Synchronisierung zwischen den beiden Transaktionen vorliegt.</span><span class="sxs-lookup"><span data-stu-id="b6ead-156">Some applications may assume readers always wait for writers to commit, particularly if there is any synchronization between the two transactions in the application tier.</span></span>  
  
     <span data-ttu-id="b6ead-157">**Richtlinie:** Anwendungen können nicht auf Blockierverhalten basieren.</span><span class="sxs-lookup"><span data-stu-id="b6ead-157">**Guideline:** Applications cannot rely on blocking behavior.</span></span> <span data-ttu-id="b6ead-158">Wenn eine Anwendung eine Synchronisierung zwischen gleichzeitigen Transaktionen benötigt, kann diese Logik in der Anwendungsebene oder auf der Datenbankebene durch [sp_getapplock &#40;Transact-SQL-&#41;](/sql/relational-databases/system-stored-procedures/sp-getapplock-transact-sql)implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="b6ead-158">If an application needs synchronization between concurrent transactions, such logic can be implemented in the application tier or in the database tier, through [sp_getapplock &#40;Transact-SQL&#41;](/sql/relational-databases/system-stored-procedures/sp-getapplock-transact-sql).</span></span>  
  
-   <span data-ttu-id="b6ead-159">In Transaktionen, die READ COMMITTED-Isolation verwenden, wird jeder Anweisung die neueste Version der Zeilen in der Datenbank angezeigt.</span><span class="sxs-lookup"><span data-stu-id="b6ead-159">In transactions that use READ COMMITTED isolation, each statement sees the most recent version of the rows in the database.</span></span> <span data-ttu-id="b6ead-160">Daher sind Änderungen des Datenbankstatus in nachfolgenden Anweisungen sichtbar.</span><span class="sxs-lookup"><span data-stu-id="b6ead-160">Therefore, subsequent statements see changes in the state of the database.</span></span>  
  
     <span data-ttu-id="b6ead-161">Ein Tabellenabruf mithilfe einer WHILE-Schleife, bis eine neue Zeile gefunden wurde, ist ein Beispiel für ein Anwendungsmuster, das diese Annahme verwendet.</span><span class="sxs-lookup"><span data-stu-id="b6ead-161">Polling a table using a WHILE loop until a new row has been found is an example of an application pattern that uses this assumption.</span></span> <span data-ttu-id="b6ead-162">Bei jeder Iteration der Schleife werden der Abfrage die neuesten Updates in der Datenbank angezeigt.</span><span class="sxs-lookup"><span data-stu-id="b6ead-162">With each iteration of the loop, the query will see the latest updates in the database.</span></span>  
  
     <span data-ttu-id="b6ead-163">**Richtlinie:** Wenn eine Anwendung eine speicheroptimierte Tabelle abrufen muss, um die neuesten Zeilen zu erhalten, die in die Tabelle geschrieben wurden, verschieben Sie die Abrufschleife aus der Transaktion heraus.</span><span class="sxs-lookup"><span data-stu-id="b6ead-163">**Guideline:** If an application needs to poll a memory-optimized table to obtain the most recent rows written to the table, move the polling loop outside the scope of the transaction.</span></span>  
  
     <span data-ttu-id="b6ead-164">Es folgt ein Beispiel für ein Anwendungsmuster, das die folgende Annahme verwendet:</span><span class="sxs-lookup"><span data-stu-id="b6ead-164">The following is an example application pattern that uses this assumption.</span></span> <span data-ttu-id="b6ead-165">Abrufen einer Tabelle mithilfe einer WHILE-Schleife, bis eine neue Zeile gefunden wird.</span><span class="sxs-lookup"><span data-stu-id="b6ead-165">Polling a table using a WHILE loop until a new row is found.</span></span> <span data-ttu-id="b6ead-166">In jeder Schleifeniteration greift die Abfrage auf die neuesten Updates in der Datenbank zu.</span><span class="sxs-lookup"><span data-stu-id="b6ead-166">In each loop iteration, the query will access the latest updates in the database.</span></span>  
  
 <span data-ttu-id="b6ead-167">Im folgenden Beispielskript wird eine Tabelle t1 abgerufen, bis sie über eine Zeile verfügt.</span><span class="sxs-lookup"><span data-stu-id="b6ead-167">The following example script polls a table t1 until it has a row.</span></span> <span data-ttu-id="b6ead-168">Dann wird aus der Tabelle eine einzelne Zeile für die weitere Verarbeitung entfernt.</span><span class="sxs-lookup"><span data-stu-id="b6ead-168">It then removes a single row from the table for further processing.</span></span>  
  
 <span data-ttu-id="b6ead-169">Beachten Sie, dass die Abruflogik außerhalb des Bereichs der Transaktion liegen muss, da sie die Momentaufnahmeisolation verwendet, um auf Tabelle t1 zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="b6ead-169">Notice that the polling logic needs to be outside the scope of the transaction, as it is using snapshot isolation to access table t1.</span></span> <span data-ttu-id="b6ead-170">Wenn die Abruflogik innerhalb des Bereichs einer Transaktion verwendet wird, würde das zu einer Transaktion mit langer Laufzeit führen, was nicht empfohlen wird.</span><span class="sxs-lookup"><span data-stu-id="b6ead-170">Using polling logic inside the scope of a transaction would create a long-running transaction, which is a bad practice.</span></span>  
  
```sql  
-- poll table  
WHILE NOT EXISTS (SELECT 1 FROM dbo.t1)  
BEGIN   
  -- if empty, wait and poll again  
  WAITFOR DELAY '00:00:01'  
END  
  
BEGIN TRANSACTION  
  DECLARE @id int  
  SELECT TOP 1 @id=id FROM dbo.t1 WITH (SNAPSHOT)  
  DELETE FROM dbo.t1 WITH (SNAPSHOT) WHERE id=@id  
  
  -- insert processing based on @id  
COMMIT  
```  
  
## <a name="locking-table-hints"></a><span data-ttu-id="b6ead-171">Sperrhinweise für Tabellen</span><span class="sxs-lookup"><span data-stu-id="b6ead-171">Locking Table Hints</span></span>  
 <span data-ttu-id="b6ead-172">Sperr Hinweise ([Tabellen Hinweise &#40;Transact-SQL-&#41;](/sql/t-sql/queries/hints-transact-sql-table)) wie HOLDLOCK und xlock können mit Datenträger basierten Tabellen verwendet werden, um [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] mehr Sperren zu verwenden, als für die angegebene Isolationsstufe erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="b6ead-172">Locking hints ([Table Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-table)) such as HOLDLOCK and XLOCK can be used with disk-based tables to have [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] take more locks than are required for the specified isolation level.</span></span>  
  
 <span data-ttu-id="b6ead-173">Speicheroptimierte Tabellen verwenden keine Sperren.</span><span class="sxs-lookup"><span data-stu-id="b6ead-173">Memory-optimized tables do not use locks.</span></span> <span data-ttu-id="b6ead-174">Höhere Isolationsstufen wie REPEATABLE READ und SERIALIZABLE können verwendet werden, um die gewünschten Garantien zu deklarieren.</span><span class="sxs-lookup"><span data-stu-id="b6ead-174">Higher isolation levels such as REPEATABLE READ and SERIALIZABLE can be used to declare the desired guarantees.</span></span>  
  
 <span data-ttu-id="b6ead-175">Sperrhinweise werden nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="b6ead-175">Locking hints are not supported.</span></span> <span data-ttu-id="b6ead-176">Deklarieren Sie stattdessen die erforderlichen Garantien über die Transaktionsisolationsstufen.</span><span class="sxs-lookup"><span data-stu-id="b6ead-176">Instead, declare the required guarantees through the transaction isolation levels.</span></span> <span data-ttu-id="b6ead-177">(NOLOCK wird unterstützt, da [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] keine Sperren für speicheroptimierten Tabellen verwendet.</span><span class="sxs-lookup"><span data-stu-id="b6ead-177">(NOLOCK is supported because [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] does not take locks on memory-optimized tables.</span></span> <span data-ttu-id="b6ead-178">Beachten Sie, dass NOLOCK anders als bei datenträgerbasierten Tabellen kein READ UNCOMMITTED-Verhalten für speicheroptimierte Tabellen impliziert.)</span><span class="sxs-lookup"><span data-stu-id="b6ead-178">Note that, in contrast to disk-based tables, NOLOCK does not imply READ UNCOMMITTED behavior for memory-optimized tables.)</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="b6ead-179">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="b6ead-179">See Also</span></span>  
 <span data-ttu-id="b6ead-180">[Grundlegendes zu Transaktionen in Speicher optimierten Tabellen](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md) </span><span class="sxs-lookup"><span data-stu-id="b6ead-180">[Understanding Transactions on Memory-Optimized Tables](../../2014/database-engine/understanding-transactions-on-memory-optimized-tables.md) </span></span>  
 <span data-ttu-id="b6ead-181">[Richtlinien für Wiederholungs Logik für Transaktionen in Speicher optimierten Tabellen](../../2014/database-engine/guidelines-for-retry-logic-for-transactions-on-memory-optimized-tables.md) </span><span class="sxs-lookup"><span data-stu-id="b6ead-181">[Guidelines for Retry Logic for Transactions on Memory-Optimized Tables](../../2014/database-engine/guidelines-for-retry-logic-for-transactions-on-memory-optimized-tables.md) </span></span>  
 [<span data-ttu-id="b6ead-182">Transaktionsisolationsstufen</span><span class="sxs-lookup"><span data-stu-id="b6ead-182">Transaction Isolation Levels</span></span>](../../2014/database-engine/transaction-isolation-levels.md)  
  
  
