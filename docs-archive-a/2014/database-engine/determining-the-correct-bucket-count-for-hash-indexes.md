---
title: Bestimmen der korrekten Bucketanzahl für Hash Indizes | Microsoft-Dokumentation
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 6d1ac280-87db-4bd8-ad43-54353647d8b5
author: stevestein
ms.author: sstein
ms.openlocfilehash: e0579a98e3302b6944f68ca449d3e7cda0ecc01d
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/04/2020
ms.locfileid: "87615553"
---
# <a name="determining-the-correct-bucket-count-for-hash-indexes"></a><span data-ttu-id="51587-102">Bestimmen der korrekten Bucketanzahl für Hashindizes</span><span class="sxs-lookup"><span data-stu-id="51587-102">Determining the Correct Bucket Count for Hash Indexes</span></span>
  <span data-ttu-id="51587-103">Beim Erstellen der speicheroptimierten Tabelle müssen Sie einen Wert für den `BUCKET_COUNT`-Parameter angeben.</span><span class="sxs-lookup"><span data-stu-id="51587-103">You must specify a value for the `BUCKET_COUNT` parameter when you create the memory-optimized table.</span></span> <span data-ttu-id="51587-104">Dieses Thema enthält Empfehlungen zum Bestimmen des geeigneten Werts für den `BUCKET_COUNT`-Parameter.</span><span class="sxs-lookup"><span data-stu-id="51587-104">This topic makes recommendations for determining the appropriate value for the `BUCKET_COUNT` parameter.</span></span> <span data-ttu-id="51587-105">Wenn Sie die richtige Bucketanzahl nicht ermitteln können, verwenden Sie einen nicht gruppierten Index.</span><span class="sxs-lookup"><span data-stu-id="51587-105">If you cannot determine the correct bucket count, use a nonclustered index instead.</span></span>  <span data-ttu-id="51587-106">Ein ungültiger `BUCKET_COUNT`-Wert kann, insbesondere wenn er zu niedrig ist, die Arbeitsauslastungsleistung sowie die Wiederherstellungszeit der Datenbank erheblich beeinträchtigen.</span><span class="sxs-lookup"><span data-stu-id="51587-106">An incorrect `BUCKET_COUNT` value, especially one that is too low, can significantly impact workload performance, as well as recovery time of the database.</span></span> <span data-ttu-id="51587-107">Es ist besser, die Bucketanzahl zu überschätzen.</span><span class="sxs-lookup"><span data-stu-id="51587-107">It is better to overestimate the bucket count.</span></span>  
  
 <span data-ttu-id="51587-108">Doppelte Indexschlüssel können bei Verwendung eines Hashindexes die Leistung beeinträchtigen, da die Schlüssel demselben Hashbucket hinzugefügt werden, wodurch die Kette dieses Buckets anwächst.</span><span class="sxs-lookup"><span data-stu-id="51587-108">Duplicate index keys can decrease performance with a hash index because the keys are hashed to the same bucket, causing that bucket's chain to increase.</span></span>  
  
 <span data-ttu-id="51587-109">Weitere Informationen zu nicht gruppierten Hashindizes finden Sie unter [Hash Indexes](hash-indexes.md) und [Guidelines for Using Indexes on Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="51587-109">For more information about nonclustered hash indexes, see [Hash Indexes](hash-indexes.md) and [Guidelines for Using Indexes on Memory-Optimized Tables](../relational-databases/in-memory-oltp/memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="51587-110">Für jeden Hashindex in einer speicheroptimierten Tabelle wird eine Hashtabelle zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="51587-110">One hash table is allocated for each hash index on a memory-optimized table.</span></span> <span data-ttu-id="51587-111">Die Größe der Hash Tabelle, die für einen Index zugeordnet ist, wird durch den- `BUCKET_COUNT` Parameter in [CREATE TABLE &#40;Transact-SQL-&#41;](/sql/t-sql/statements/create-table-transact-sql) oder [Create Type &#40;Transact-SQL-&#41;](/sql/t-sql/statements/create-type-transact-sql)angegeben.</span><span class="sxs-lookup"><span data-stu-id="51587-111">The size of the hash table allocated for an index is specified by the `BUCKET_COUNT` parameter in [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql) or [CREATE TYPE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-type-transact-sql).</span></span> <span data-ttu-id="51587-112">Die Bucketanzahl wird intern bis zur nächsten Zweierpotenz aufgerundet.</span><span class="sxs-lookup"><span data-stu-id="51587-112">The bucket count will internally be rounded up to the next power of two.</span></span> <span data-ttu-id="51587-113">Wenn als Bucketanzahl beispielsweise 300.000 angegeben wird, führt dies zu einer tatsächlichen Bucketanzahl von 524.288.</span><span class="sxs-lookup"><span data-stu-id="51587-113">For example, specifying a bucket count of 300,000 will result in an actual bucket count of 524,288.</span></span>  
  
 <span data-ttu-id="51587-114">Links zu einem Artikel und Videos zur Bucketanzahl finden Sie unter [Bestimmen der richtigen Bucketanzahl für Hashindizes (In-Memory OLTP)](https://www.mssqltips.com/sqlservertip/3104/determine-bucketcount-for-hash-indexes-for-sql-server-memory-optimized-tables/).</span><span class="sxs-lookup"><span data-stu-id="51587-114">For links to an article and video on bucket count, see [How to determine the right bucket count for hash indexes (In-Memory OLTP)](https://www.mssqltips.com/sqlservertip/3104/determine-bucketcount-for-hash-indexes-for-sql-server-memory-optimized-tables/).</span></span>  
  
## <a name="recommendations"></a><span data-ttu-id="51587-115">Empfehlungen</span><span class="sxs-lookup"><span data-stu-id="51587-115">Recommendations</span></span>  
 <span data-ttu-id="51587-116">In den meisten Fällen sollte die Bucketanzahl das Ein- bis Zweifache der Anzahl von unterschiedlichen Werten im Indexschlüssel betragen.</span><span class="sxs-lookup"><span data-stu-id="51587-116">In most cases the bucket count should be between 1 and 2 times the number of distinct values in the index key.</span></span> <span data-ttu-id="51587-117">Wenn der Indexschlüssel zahlreiche doppelte Werte enthält und durchschnittlich über 10 Zeilen für jeden Indexschlüsselwert vorhanden sind, verwenden Sie einen nicht gruppierten Index.</span><span class="sxs-lookup"><span data-stu-id="51587-117">If the index key contains a lot of duplicate values, on average there are more than 10 rows for each index key value, use a nonclustered index instead</span></span>  
  
 <span data-ttu-id="51587-118">Möglicherweise können Sie nicht immer prognostizieren, wie viele Werte ein bestimmter Indexschlüssel enthalten kann oder wird.</span><span class="sxs-lookup"><span data-stu-id="51587-118">You may not always be able to predict how many values a particular index key may have or will have.</span></span> <span data-ttu-id="51587-119">Die Leistung sollte akzeptabel sein, wenn der `BUCKET_COUNT`-Wert bis zum Fünffachen der tatsächlichen Anzahl von Schlüsselwerten beträgt.</span><span class="sxs-lookup"><span data-stu-id="51587-119">Performance should be acceptable if the `BUCKET_COUNT` value is within 5 times of the actual number of key values.</span></span>  
  
 <span data-ttu-id="51587-120">Verwenden Sie zum Ermitteln der Anzahl von eindeutigen Indexschlüsseln in vorhandenen Daten Abfragen wie in den folgenden Beispielen:</span><span class="sxs-lookup"><span data-stu-id="51587-120">To determine the number of unique index keys in existing data, use queries similar to the following examples:</span></span>  
  
### <a name="primary-key-and-unique-indexes"></a><span data-ttu-id="51587-121">Primärschlüssel und eindeutige Indizes</span><span class="sxs-lookup"><span data-stu-id="51587-121">Primary Key and Unique Indexes</span></span>  
 <span data-ttu-id="51587-122">Da der Primärschlüsselindex eindeutig ist, entspricht die Anzahl unterschiedlicher Werte im Schlüssel der Anzahl der Zeilen in der Tabelle.</span><span class="sxs-lookup"><span data-stu-id="51587-122">Because the primary key index is unique, the number of distinct values in the key corresponds to the number of rows in the table.</span></span> <span data-ttu-id="51587-123">Geben Sie für einen Beispielprimärschlüssel für (SalesOrderID, SalesOrderDetailID) in der Tabelle "Sales.SalesOrderDetail" in der AdventureWorks-Datenbank die folgende Abfrage aus, um die Anzahl der unterschiedlichen Primärschlüsselwerte zu berechnen. Diese entspricht der Anzahl der Zeilen in der Tabelle.</span><span class="sxs-lookup"><span data-stu-id="51587-123">For an example primary key on (SalesOrderID, SalesOrderDetailID) in the table Sales.SalesOrderDetail in the AdventureWorks database, issue the following query to calculate the number of distinct primary key values, which corresponds to the number of rows in the table:</span></span>  
  
```sql  
SELECT COUNT(*) AS [row count]   
FROM Sales.SalesOrderDetail  
```  
  
 <span data-ttu-id="51587-124">Diese Abfrage enthält eine Zeilenanzahl von 121.317.</span><span class="sxs-lookup"><span data-stu-id="51587-124">This query shows a row count of 121,317.</span></span> <span data-ttu-id="51587-125">Verwenden Sie eine Bucketanzahl von 240.000, wenn sich die Zeilenanzahl nicht signifikant ändert.</span><span class="sxs-lookup"><span data-stu-id="51587-125">Use a bucket count of 240,000 if the row count will not change significantly.</span></span> <span data-ttu-id="51587-126">Verwenden Sie eine Bucketanzahl von 480.000, wenn Sie erwarten, dass sich die Anzahl der Bestellungen vervierfachen wird.</span><span class="sxs-lookup"><span data-stu-id="51587-126">Use a bucket count of 480,000 if the number of sales orders in the table is expected to quadruple.</span></span>  
  
### <a name="non-unique-indexes"></a><span data-ttu-id="51587-127">Nicht eindeutige Indizes</span><span class="sxs-lookup"><span data-stu-id="51587-127">Non-Unique Indexes</span></span>  
 <span data-ttu-id="51587-128">Für andere Indizes, z. B. einen mehrspaltigen Index für (SpecialOfferID, ProductID), geben Sie die folgende Abfrage aus, um die Anzahl von eindeutigen Indexschlüsselwerten zu bestimmen:</span><span class="sxs-lookup"><span data-stu-id="51587-128">For other indexes, for example a multi-column index on (SpecialOfferID, ProductID), issue the following query to determine the number of unique index key values:</span></span>  
  
```sql  
SELECT COUNT(*) AS [SpecialOfferID_ProductID index key count]  
FROM   
   (SELECT DISTINCT SpecialOfferID, ProductID   
    FROM Sales.SalesOrderDetail) t  
```  
  
 <span data-ttu-id="51587-129">Diese Abfrage gibt für (SpecialOfferID, ProductID) die Indexschlüsselanzahl 484 zurück, was darauf hindeutet, dass ein nicht gruppierter Index anstelle eines nicht gruppierten Hashindexes verwendet werden sollte.</span><span class="sxs-lookup"><span data-stu-id="51587-129">This query returns an index key count for (SpecialOfferID, ProductID) of 484, indicating a that a nonclustered index should be used instead of a nonclustered hash index.</span></span>  
  
### <a name="determining-the-number-of-duplicates"></a><span data-ttu-id="51587-130">Bestimmen der Anzahl von Duplikaten</span><span class="sxs-lookup"><span data-stu-id="51587-130">Determining the Number of Duplicates</span></span>  
 <span data-ttu-id="51587-131">Teilen Sie zum Bestimmen der durchschnittlichen Anzahl doppelter Werte für einen Indexschlüsselwert die Gesamtzeilenanzahl durch die Anzahl der eindeutigen Indexschlüssel.</span><span class="sxs-lookup"><span data-stu-id="51587-131">To determine the average number of duplicate values for an index key value, divide the total number of rows by the number of unique index keys.</span></span>  
  
 <span data-ttu-id="51587-132">Beim Beispielindex für (SpecialOfferID, ProductID) ist dies 121317/484 = 251.</span><span class="sxs-lookup"><span data-stu-id="51587-132">For the example index on (SpecialOfferID, ProductID), this leads to 121317 / 484 = 251.</span></span> <span data-ttu-id="51587-133">Dies bedeutet, dass der Durchschnitt von Indexschlüsselwerten 251 beträgt und es sich daher hier um einen nicht gruppierten Index handeln sollte.</span><span class="sxs-lookup"><span data-stu-id="51587-133">This means index key values have an average of 251, and thus this should be a nonclustered index.</span></span>  
  
## <a name="troubleshooting-the-bucket-count"></a><span data-ttu-id="51587-134">Problembehandlung für die Bucketanzahl</span><span class="sxs-lookup"><span data-stu-id="51587-134">Troubleshooting the Bucket Count</span></span>  
 <span data-ttu-id="51587-135">Um Probleme mit der Bucketanzahl in Speicher optimierten Tabellen zu beheben, verwenden Sie [sys. dm_db_xtp_hash_index_stats &#40;Transact-SQL-&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-hash-index-stats-transact-sql) , um Statistiken über die leeren Bucket und die Länge der Zeilen Ketten abzurufen.</span><span class="sxs-lookup"><span data-stu-id="51587-135">To troubleshoot bucket count issues in memory-optimized tables, use [sys.dm_db_xtp_hash_index_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-xtp-hash-index-stats-transact-sql) to obtain statistics about the empty buckets and the length of row chains.</span></span> <span data-ttu-id="51587-136">Mit der folgenden Abfrage können Statistiken zu allen Hashindizes in der aktuellen Datenbank abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="51587-136">The following query can be used to obtain statistics about all the hash indexes in the current database.</span></span> <span data-ttu-id="51587-137">Die Abfrage kann einige Zeit in Anspruch nehmen, wenn die Datenbank große Tabellen enthält.</span><span class="sxs-lookup"><span data-stu-id="51587-137">The query can take several minutes to run if there are large tables in the database.</span></span>  
  
```sql  
SELECT   
   object_name(hs.object_id) AS 'object name',   
   i.name as 'index name',   
   hs.total_bucket_count,  
   hs.empty_bucket_count,  
   floor((cast(empty_bucket_count as float)/total_bucket_count) * 100) AS 'empty_bucket_percent',  
   hs.avg_chain_length,   
   hs.max_chain_length  
FROM sys.dm_db_xtp_hash_index_stats AS hs   
   JOIN sys.indexes AS i   
   ON hs.object_id=i.object_id AND hs.index_id=i.index_id  
```  
  
 <span data-ttu-id="51587-138">Zwei wichtige Indikatoren für den Zustand von Hashindizes lauten wie folgt:</span><span class="sxs-lookup"><span data-stu-id="51587-138">The two key indicators of hash index health are:</span></span>  
  
 <span data-ttu-id="51587-139">*empty_bucket_percent*</span><span class="sxs-lookup"><span data-stu-id="51587-139">*empty_bucket_percent*</span></span>  
 <span data-ttu-id="51587-140">*empty_bucket_percent* gibt die Anzahl der leeren Buckets im Hashindex an.</span><span class="sxs-lookup"><span data-stu-id="51587-140">*empty_bucket_percent* indicates the number of empty buckets in the hash index.</span></span>  
  
 <span data-ttu-id="51587-141">Wenn *empty_bucket_percent* kleiner als 10 Prozent ist, ist die Bucketanzahl wahrscheinlich zu niedrig.</span><span class="sxs-lookup"><span data-stu-id="51587-141">If *empty_bucket_percent* is less than 10 percent, the bucket count is likely to be too low.</span></span> <span data-ttu-id="51587-142">Im Idealfall sollte *empty_bucket_percent* mindestens 33 Prozent betragen.</span><span class="sxs-lookup"><span data-stu-id="51587-142">Ideally, the *empty_bucket_percent* should be 33 percent or greater.</span></span> <span data-ttu-id="51587-143">Wenn die Bucketanzahl der Anzahl der Indexschlüsselwerte entspricht, ist ca. 1/3 der Buckets aufgrund der Hashverteilung leer.</span><span class="sxs-lookup"><span data-stu-id="51587-143">If the bucket count matches the number of index key values, about 1/3 of the buckets is empty, due to hash distribution.</span></span>  
  
 <span data-ttu-id="51587-144">*avg_chain_length*</span><span class="sxs-lookup"><span data-stu-id="51587-144">*avg_chain_length*</span></span>  
 <span data-ttu-id="51587-145">*avg_chain_length* gibt die durchschnittliche Länge der Zeilenketten in den Hashbuckets an.</span><span class="sxs-lookup"><span data-stu-id="51587-145">*avg_chain_length* indicates the average length of the row chains in the hash buckets.</span></span>  
  
 <span data-ttu-id="51587-146">Wenn *avg_chain_length* größer als 10 und *empty_bucket_percent* größer als 10 Prozent ist, sind wahrscheinlich zahlreiche doppelte Indexschlüsselwerte vorhanden, und ein nicht gruppierter Index wäre besser geeignet.</span><span class="sxs-lookup"><span data-stu-id="51587-146">If *avg_chain_length* is greater than 10 and *empty_bucket_percent* is greater than 10 percent, there likely are many duplicate index key values and a nonclustered index would be more appropriate.</span></span> <span data-ttu-id="51587-147">Eine durchschnittliche Kettenlänge von 1 ist ideal.</span><span class="sxs-lookup"><span data-stu-id="51587-147">An average chain length of 1 is ideal.</span></span>  
  
 <span data-ttu-id="51587-148">Zwei Faktoren haben Auswirkungen auf die Kettenlänge:</span><span class="sxs-lookup"><span data-stu-id="51587-148">There are two factors that impact the chain length:</span></span>  
  
1.  <span data-ttu-id="51587-149">Duplikate: Alle doppelten Zeilen sind Teil derselben Kette im Hashindex.</span><span class="sxs-lookup"><span data-stu-id="51587-149">Duplicates; all duplicate rows are part of the same chain in the hash index.</span></span>  
  
2.  <span data-ttu-id="51587-150">Mehrere Schlüsselwerte wurden dem gleichen Bucket zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="51587-150">Multiple key values map to the same bucket.</span></span> <span data-ttu-id="51587-151">Je niedriger die Bucketanzahl, desto mehr Buckets sind mehrere Werte zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="51587-151">The lower the bucket count, the more buckets that will have multiple values mapped to them.</span></span>  
  
 <span data-ttu-id="51587-152">Betrachten Sie als Beispiel die folgende Tabelle und das Skript zum Einfügen von Beispielzeilen in der Tabelle:</span><span class="sxs-lookup"><span data-stu-id="51587-152">As an example, consider the following table and script to insert sample rows in the table:</span></span>  
  
```sql  
CREATE TABLE [Sales].[SalesOrderHeader_test]  
(  
   [SalesOrderID] [uniqueidentifier] NOT NULL DEFAULT (newid()),  
   [OrderSequence] int NOT NULL,  
   [OrderDate] [datetime2](7) NOT NULL,  
   [Status] [tinyint] NOT NULL,  
  
PRIMARY KEY NONCLUSTERED HASH ([SalesOrderID]) WITH ( BUCKET_COUNT = 262144 ),  
INDEX IX_OrderSequence HASH (OrderSequence) WITH ( BUCKET_COUNT = 20000),  
INDEX IX_Status HASH ([Status]) WITH ( BUCKET_COUNT = 8),  
INDEX IX_OrderDate NONCLUSTERED ([OrderDate] ASC),  
)WITH ( MEMORY_OPTIMIZED = ON , DURABILITY = SCHEMA_AND_DATA )  
GO  
  
DECLARE @i int = 0  
BEGIN TRAN  
WHILE @i < 262144  
BEGIN  
   INSERT Sales.SalesOrderHeader_test (OrderSequence, OrderDate, [Status]) VALUES (@i, sysdatetime(), @i % 8)  
   SET @i += 1  
END  
COMMIT  
GO  
```  
  
 <span data-ttu-id="51587-153">Mit dem Skript werden 262.144 Zeilen in der Tabelle eingefügt.</span><span class="sxs-lookup"><span data-stu-id="51587-153">The script inserts 262,144 rows in the table.</span></span> <span data-ttu-id="51587-154">Das Skript fügt eindeutige Werte im Primärschlüsselindex und in "IX_OrderSequence" ein.</span><span class="sxs-lookup"><span data-stu-id="51587-154">It inserts unique values in the primary key index and in IX_OrderSequence.</span></span> <span data-ttu-id="51587-155">Es werden zahlreiche doppelte Werte im Index "IX_Status" eingefügt. Das Skript generiert nur 8 unterschiedliche Werte.</span><span class="sxs-lookup"><span data-stu-id="51587-155">It inserts a lot of duplicate values in the index IX_Status: the script only generates 8 distinct values.</span></span>  
  
 <span data-ttu-id="51587-156">Die Ausgabe der BUCKET_COUNT-Abfrage zur Problembehandlung lautet wie folgt:</span><span class="sxs-lookup"><span data-stu-id="51587-156">The output of the BUCKET_COUNT troubleshooting query is as follows:</span></span>  
  
|<span data-ttu-id="51587-157">Indexname</span><span class="sxs-lookup"><span data-stu-id="51587-157">index name</span></span>|<span data-ttu-id="51587-158">total_bucket_count</span><span class="sxs-lookup"><span data-stu-id="51587-158">total_bucket_count</span></span>|<span data-ttu-id="51587-159">empty_bucket_count</span><span class="sxs-lookup"><span data-stu-id="51587-159">empty_bucket_count</span></span>|<span data-ttu-id="51587-160">empty_bucket_percent</span><span class="sxs-lookup"><span data-stu-id="51587-160">empty_bucket_percent</span></span>|<span data-ttu-id="51587-161">avg_chain_length</span><span class="sxs-lookup"><span data-stu-id="51587-161">avg_chain_length</span></span>|<span data-ttu-id="51587-162">max_chain_length</span><span class="sxs-lookup"><span data-stu-id="51587-162">max_chain_length</span></span>|  
|----------------|--------------------------|--------------------------|----------------------------|------------------------|------------------------|  
|<span data-ttu-id="51587-163">IX_Status</span><span class="sxs-lookup"><span data-stu-id="51587-163">IX_Status</span></span>|<span data-ttu-id="51587-164">8</span><span class="sxs-lookup"><span data-stu-id="51587-164">8</span></span>|<span data-ttu-id="51587-165">4</span><span class="sxs-lookup"><span data-stu-id="51587-165">4</span></span>|<span data-ttu-id="51587-166">50</span><span class="sxs-lookup"><span data-stu-id="51587-166">50</span></span>|<span data-ttu-id="51587-167">65536</span><span class="sxs-lookup"><span data-stu-id="51587-167">65536</span></span>|<span data-ttu-id="51587-168">65536</span><span class="sxs-lookup"><span data-stu-id="51587-168">65536</span></span>|  
|<span data-ttu-id="51587-169">IX_OrderSequence</span><span class="sxs-lookup"><span data-stu-id="51587-169">IX_OrderSequence</span></span>|<span data-ttu-id="51587-170">32768</span><span class="sxs-lookup"><span data-stu-id="51587-170">32768</span></span>|<span data-ttu-id="51587-171">13</span><span class="sxs-lookup"><span data-stu-id="51587-171">13</span></span>|<span data-ttu-id="51587-172">0</span><span class="sxs-lookup"><span data-stu-id="51587-172">0</span></span>|<span data-ttu-id="51587-173">8</span><span class="sxs-lookup"><span data-stu-id="51587-173">8</span></span>|<span data-ttu-id="51587-174">26</span><span class="sxs-lookup"><span data-stu-id="51587-174">26</span></span>|  
|<span data-ttu-id="51587-175">PK_SalesOrd_B14003C3F8FB3364</span><span class="sxs-lookup"><span data-stu-id="51587-175">PK_SalesOrd_B14003C3F8FB3364</span></span>|<span data-ttu-id="51587-176">262144</span><span class="sxs-lookup"><span data-stu-id="51587-176">262144</span></span>|<span data-ttu-id="51587-177">96319</span><span class="sxs-lookup"><span data-stu-id="51587-177">96319</span></span>|<span data-ttu-id="51587-178">36</span><span class="sxs-lookup"><span data-stu-id="51587-178">36</span></span>|<span data-ttu-id="51587-179">1</span><span class="sxs-lookup"><span data-stu-id="51587-179">1</span></span>|<span data-ttu-id="51587-180">8</span><span class="sxs-lookup"><span data-stu-id="51587-180">8</span></span>|  
  
 <span data-ttu-id="51587-181">Betrachten Sie die drei Hashindizes für diese Tabelle:</span><span class="sxs-lookup"><span data-stu-id="51587-181">Consider the three hash indexes on this table:</span></span>  
  
-   <span data-ttu-id="51587-182">IX_Status: 50 Prozent der Buckets sind leer, das ist positiv.</span><span class="sxs-lookup"><span data-stu-id="51587-182">IX_Status: 50 percent of the buckets are empty, which is good.</span></span> <span data-ttu-id="51587-183">Die durchschnittliche Kettenlänge ist jedoch sehr hoch (65.536).</span><span class="sxs-lookup"><span data-stu-id="51587-183">However, the average chain length is very high (65,536).</span></span> <span data-ttu-id="51587-184">Dies weist auf eine große Anzahl doppelter Werte hin.</span><span class="sxs-lookup"><span data-stu-id="51587-184">This indicates a large number of duplicate values.</span></span> <span data-ttu-id="51587-185">Die Verwendung eines nicht gruppierten Hashindexes ist in diesem Fall daher nicht sinnvoll.</span><span class="sxs-lookup"><span data-stu-id="51587-185">Therefore, using a nonclustered hash index is not appropriate in this case.</span></span> <span data-ttu-id="51587-186">Stattdessen sollte ein nicht gruppierter Index verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="51587-186">A nonclustered index should be used instead.</span></span>  
  
-   <span data-ttu-id="51587-187">IX_OrderSequence: 0 Prozent der Buckets sind leer. Dieser Wert ist zu niedrig.</span><span class="sxs-lookup"><span data-stu-id="51587-187">IX_OrderSequence: 0 percent of the buckets are empty, which is too low.</span></span> <span data-ttu-id="51587-188">Darüber hinaus beträgt die durchschnittliche Kettenlänge 8.</span><span class="sxs-lookup"><span data-stu-id="51587-188">In addition, the average chain length is 8.</span></span> <span data-ttu-id="51587-189">Da die Werte in diesem Index eindeutig sind, bedeutet dies, dass durchschnittlich jedem Bucket 8 Werte zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="51587-189">As the values in this index are unique, this means on average 8 values are mapped to each bucket.</span></span> <span data-ttu-id="51587-190">Die Bucketanzahl sollte erhöht werden.</span><span class="sxs-lookup"><span data-stu-id="51587-190">The bucket count should be increased.</span></span> <span data-ttu-id="51587-191">Da der Indexschlüssel 262.144 eindeutige Werte enthält, sollte die Bucketanzahl mindestens 262.144 betragen.</span><span class="sxs-lookup"><span data-stu-id="51587-191">As the index key has 262,144 unique values, the bucket count should be at least 262,144.</span></span> <span data-ttu-id="51587-192">Wenn zukünftiges Wachstum erwartet wird, sollte die Zahl größer sein.</span><span class="sxs-lookup"><span data-stu-id="51587-192">If future growth is expected, the number should be higher.</span></span>  
  
-   <span data-ttu-id="51587-193">Primärschlüssel Index (PK__SalesOrder...): 36 Prozent der Eimer sind leer, was gut ist.</span><span class="sxs-lookup"><span data-stu-id="51587-193">Primary key index (PK__SalesOrder...): 36 percent of the buckets are empty, which is good.</span></span> <span data-ttu-id="51587-194">Außerdem beträgt die durchschnittliche Kettenlänge 1, was ebenfalls positiv ist.</span><span class="sxs-lookup"><span data-stu-id="51587-194">In addition the average chain length is 1, which is also good.</span></span> <span data-ttu-id="51587-195">Es ist keine Änderung erforderlich.</span><span class="sxs-lookup"><span data-stu-id="51587-195">No change needed.</span></span>  
  
 <span data-ttu-id="51587-196">Weitere Informationen zur Fehlerbehebung bei speicheroptimierten Hashindizes finden Sie unter [Troubleshooting Common Performance Problems with Memory-Optimized Hash Indexes](../../2014/database-engine/troubleshooting-common-performance-problems-with-memory-optimized-hash-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="51587-196">For more information on troubleshooting issues with your memory-optimized hash indexes, see [Troubleshooting Common Performance Problems with Memory-Optimized Hash Indexes](../../2014/database-engine/troubleshooting-common-performance-problems-with-memory-optimized-hash-indexes.md).</span></span>  
  
## <a name="detailed-considerations-for-further-optimization"></a><span data-ttu-id="51587-197">Ausführliche Überlegungen für die weitere Optimierung</span><span class="sxs-lookup"><span data-stu-id="51587-197">Detailed Considerations for Further Optimization</span></span>  
 <span data-ttu-id="51587-198">Dieser Abschnitt enthält zusätzliche Überlegungen zum Optimieren der Bucketanzahl.</span><span class="sxs-lookup"><span data-stu-id="51587-198">This section outlines further considerations for optimizing the bucket count.</span></span>  
  
 <span data-ttu-id="51587-199">Um die optimale Leistung von Hashindizes zu gewährleisten, müssen Sie ein Gleichgewicht zwischen dem Speicherplatz, der der Hashtabelle im Arbeitsspeicher zugeordnet ist, und der Anzahl der unterschiedlichen Werte im Indexschlüssel finden.</span><span class="sxs-lookup"><span data-stu-id="51587-199">To achieve the best performance for hash indexes, balance the amount of memory allocated to the hash table and the number of distinct values in the index key.</span></span> <span data-ttu-id="51587-200">Zudem besteht ein Zusammenhang zwischen der Leistung von Punktsuchen und Tabellenscans:</span><span class="sxs-lookup"><span data-stu-id="51587-200">There is also a balance between the performance of point lookups and table scans:</span></span>  
  
-   <span data-ttu-id="51587-201">Je höher der Wert für die Bucketanzahl ist, desto mehr leere Buckets sind im Index enthalten.</span><span class="sxs-lookup"><span data-stu-id="51587-201">The higher the bucket count value, the more empty buckets there will be in the index.</span></span> <span data-ttu-id="51587-202">Dies hat Auswirkungen auf die Speicherauslastung (8 Bytes pro Bucket) und die Leistung von Tabellenscans, da jeder Bucket als Teil eines Tabellenscans überprüft wird.</span><span class="sxs-lookup"><span data-stu-id="51587-202">This has an impact on memory usage (8 bytes per bucket) and the performance of table scans, as each bucket is scanned as part of a table scan.</span></span>  
  
-   <span data-ttu-id="51587-203">Je niedriger die Bucketanzahl, desto mehr Werte sind einem einzelnen Bucket zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="51587-203">The lower the bucket count, the more values are assigned to a single bucket.</span></span> <span data-ttu-id="51587-204">Dadurch wird die Leistung für Punktsuchen und Einfügungen verringert, da [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] möglicherweise mehrere Werte in einem einzelnen Bucket durchlaufen muss, um den durch das Suchprädikat angegebenen Wert zu finden.</span><span class="sxs-lookup"><span data-stu-id="51587-204">This decreases performance for point lookups and inserts, because [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] may need to traverse several values in a single bucket to find the value specified by the search predicate.</span></span>  
  
 <span data-ttu-id="51587-205">Wenn die Bucketanzahl deutlich niedriger als die Anzahl der eindeutigen Indexschlüssel ist, werden jedem Bucket zahlreiche Werte zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="51587-205">If the bucket count is significantly lower than the number of unique index keys, many values will map to each bucket.</span></span> <span data-ttu-id="51587-206">Dadurch wird die Leistung der meisten DML-Vorgänge beeinträchtigt, insbesondere von Punktsuchen (Suchen nach einzelnen Indexschlüsseln) und Einfügevorgängen.</span><span class="sxs-lookup"><span data-stu-id="51587-206">This degrades performance of most DML operations, particularly point lookups (lookups of individual index keys) and insert operations.</span></span> <span data-ttu-id="51587-207">Beispielsweise lässt sich eine Leistungsminderung bei SELECT-Abfragen sowie UPDATE- und DELETE-Vorgängen mit Gleichheitsprädikaten feststellen, durch die die Indexschlüsselspalten in der WHERE-Klausel verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="51587-207">For example, you may see poor performance of SELECT queries and, UPDATE and DELETE operations with equality predicates matching the index key columns in the WHERE clause.</span></span> <span data-ttu-id="51587-208">Eine niedrige Bucketanzahl hat außerdem Auswirkungen auf die Dauer der Datenbankwiederherstellung, da die Indizes beim Datenbankstart neu erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="51587-208">A low bucket count will also affect the recovery time of the database, as the indexes are recreated on database startup.</span></span>  
  
### <a name="duplicate-index-key-values"></a><span data-ttu-id="51587-209">Doppelte Indexschlüsselwerte</span><span class="sxs-lookup"><span data-stu-id="51587-209">Duplicate Index Key Values</span></span>  
 <span data-ttu-id="51587-210">Doppelte Werte können die Auswirkungen auf die Leistung durch Hashkonflikte verstärken.</span><span class="sxs-lookup"><span data-stu-id="51587-210">Duplicate values can increase the performance impact of hash collisions.</span></span> <span data-ttu-id="51587-211">Dies stellt normalerweise kein Problem dar, wenn jeder Indexschlüssel eine geringe Anzahl von Duplikaten aufweist.</span><span class="sxs-lookup"><span data-stu-id="51587-211">This is usually not a problem if each index key has a low number of duplicates.</span></span> <span data-ttu-id="51587-212">Es kann jedoch problematisch werden, wenn die Diskrepanz zwischen der Anzahl eindeutiger Indexschlüssel und der Anzahl der Tabellenzeilen erheblich zunimmt.</span><span class="sxs-lookup"><span data-stu-id="51587-212">But this can be a problem if the discrepancy between the number of unique index keys and the number of rows in the tables becomes very large.</span></span>  
  
 <span data-ttu-id="51587-213">Alle Zeilen mit dem gleichen Indexschlüssel werden der gleichen Duplikatkette zugewiesen.</span><span class="sxs-lookup"><span data-stu-id="51587-213">All rows with the same index key will go into the same duplicate chain.</span></span> <span data-ttu-id="51587-214">Wenn ein Bucket aufgrund eines Hashkonflikts mehrere Indexschlüssel enthält, müssen Indexscanner immer die vollständige Duplikatkette nach dem ersten Wert durchsuchen, bevor die erste Zeile gesucht werden kann, die dem zweiten Wert entspricht.</span><span class="sxs-lookup"><span data-stu-id="51587-214">If multiple index keys are in the same bucket due to a hash collision, index scanners always need to scan the full duplicate chain for the first value before they can locate the first row corresponding to the second value.</span></span> <span data-ttu-id="51587-215">Doppelte Schlüssel erschweren der Garbage Collection zusätzlich die Suche nach der entsprechenden Zeile.</span><span class="sxs-lookup"><span data-stu-id="51587-215">Duplicate keys also make it more difficult for garbage collection to locate the row.</span></span> <span data-ttu-id="51587-216">Beispiel: Wenn für einen Schlüssel 1.000 Duplikate vorhanden sind und eine der Zeilen gelöscht wird, muss der Garbage Collector die gesamte Kette von 1.000 Duplikaten überprüfen, um die Verknüpfung der Zeile mit dem Index aufzuheben.</span><span class="sxs-lookup"><span data-stu-id="51587-216">For example, if there are 1,000 duplicates for any key and one of the rows is deleted, the garbage collector needs to scan the chain of 1,000 duplicates to unlink the row from the index.</span></span> <span data-ttu-id="51587-217">Dies gilt selbst dann, wenn die Abfrage, durch die die gelöschte Zeile gefunden wurde, einen effizienteren Index (Primärschlüsselindex) zum Suchen der Zeile verwendet hat, weil der Garbage Collector die Verknüpfung mit jedem Index aufheben muss.</span><span class="sxs-lookup"><span data-stu-id="51587-217">This is true even if the query that found the delete used a more efficient index (a primary key index) to locate the row, because the garbage collector needs to unlink from every index</span></span>  
  
 <span data-ttu-id="51587-218">Bei Hashindizes gibt es zwei Möglichkeiten, den durch doppelte Indexschlüsselwerte verursachten Aufwand zu reduzieren:</span><span class="sxs-lookup"><span data-stu-id="51587-218">For hash indexes, there are two ways to reduce the work caused by duplicate index key values:</span></span>  
  
-   <span data-ttu-id="51587-219">Verwenden Sie stattdessen einen nicht gruppierten Index.</span><span class="sxs-lookup"><span data-stu-id="51587-219">Use a nonclustered index instead.</span></span> <span data-ttu-id="51587-220">Sie können die Duplikate verringern, indem Sie dem Indexschlüssel Spalten hinzufügen, ohne dass Änderungen an der Anwendung erforderlich sind.</span><span class="sxs-lookup"><span data-stu-id="51587-220">You can decrease the duplicates by adding columns to the index key without requiring any changes to the application.</span></span>  
  
-   <span data-ttu-id="51587-221">Geben Sie eine sehr hohe Bucketanzahl für den Index an.</span><span class="sxs-lookup"><span data-stu-id="51587-221">Specify a very high bucket count for the index.</span></span> <span data-ttu-id="51587-222">Beispielsweise das 20- bis 100-fache der Anzahl der eindeutigen Indexschlüssel.</span><span class="sxs-lookup"><span data-stu-id="51587-222">For example, 20-to-100 times the number of unique index keys.</span></span> <span data-ttu-id="51587-223">Dadurch werden Hashkonflikte verringert.</span><span class="sxs-lookup"><span data-stu-id="51587-223">This will reduce hash collisions.</span></span>  
  
### <a name="small-tables"></a><span data-ttu-id="51587-224">Kleine Tabellen</span><span class="sxs-lookup"><span data-stu-id="51587-224">Small Tables</span></span>  
 <span data-ttu-id="51587-225">Bei kleineren Tabellen ist die Arbeitsspeicherauslastung normalerweise kein Problem, da die Indexgröße im Vergleich zur Gesamtgröße der Datenbank gering ist.</span><span class="sxs-lookup"><span data-stu-id="51587-225">For smaller tables, memory utilization is usually not a concern, as the size of the index will be small compared to the overall size of the database.</span></span>  
  
 <span data-ttu-id="51587-226">Sie müssen nun auf Grundlage der gewünschten Leistung eine Auswahl treffen:</span><span class="sxs-lookup"><span data-stu-id="51587-226">You must now make a choice based on the kind of performance you want:</span></span>  
  
-   <span data-ttu-id="51587-227">Wenn es sich bei den leistungskritischen Vorgängen für den Index vorwiegend um Punktsuchen und/oder Einfügevorgänge handelt, ist eine höhere Bucketanzahl sinnvoll, um die Wahrscheinlichkeit von Hashkonflikten zu reduzieren.</span><span class="sxs-lookup"><span data-stu-id="51587-227">If the performance-critical operations on the index are predominantly point lookups and/or insert operations, a higher bucket count would be appropriate to reduce the likelihood of hash collisions.</span></span> <span data-ttu-id="51587-228">Das Dreifache der Zeilenanzahl oder sogar ein höherer Wert ist hier die beste Option.</span><span class="sxs-lookup"><span data-stu-id="51587-228">Three times the number of rows or even more would be the best option.</span></span>  
  
-   <span data-ttu-id="51587-229">Wenn es sich bei den wichtigsten leistungskritischen Vorgängen um vollständige Indexscans handelt, verwenden Sie eine Bucketanzahl, die nah an der tatsächlichen Anzahl von Indexschlüsselwerten liegt.</span><span class="sxs-lookup"><span data-stu-id="51587-229">If full index scans are the predominant performance-critical operations, use a bucket count that is close to the actual number of index key values.</span></span>  
  
### <a name="big-tables"></a><span data-ttu-id="51587-230">Große Tabellen</span><span class="sxs-lookup"><span data-stu-id="51587-230">Big Tables</span></span>  
 <span data-ttu-id="51587-231">Bei großen Tabellen kann die Arbeitsspeicherauslastung zu einem Problem werden.</span><span class="sxs-lookup"><span data-stu-id="51587-231">For large tables, memory utilization could become a concern.</span></span> <span data-ttu-id="51587-232">Bei einer 250 Millionen-Zeilen Tabelle mit vier Hash Indizes, die jeweils über eine Bucketanzahl von 1 Milliarde verfügen, beträgt der Aufwand für die Hash Tabellen beispielsweise 4 Indizes \* 1 Milliarde Bucket \* 8 Bytes = 32 Gigabyte Arbeitsspeicher Auslastung.</span><span class="sxs-lookup"><span data-stu-id="51587-232">For example, with a 250 million row table that has 4 hash indexes, each with a bucket count of one billion, the overhead for the hash tables is 4 indexes \* 1 billion buckets \* 8 bytes = 32 gigabytes of memory utilization.</span></span> <span data-ttu-id="51587-233">Wenn eine Bucketanzahl von 250 Millionen für jeden der Indizes ausgewählt wird, beträgt die benötigte Leistung für die Hashtabellen 8 GB.</span><span class="sxs-lookup"><span data-stu-id="51587-233">When choosing a bucket count of 250 million for each of the indexes, the total overhead for the hash tables will be 8 gigabytes.</span></span> <span data-ttu-id="51587-234">Beachten Sie, dass dies zusätzlich zu den 8 Bytes der Speicherauslastung liegt, die jeder Index jeder einzelnen Zeile hinzufügt, d. h. 8 Gigabyte in diesem Szenario (4 Indizes \* 8 Bytes \* 250 Millionen Zeilen).</span><span class="sxs-lookup"><span data-stu-id="51587-234">Note that this is in addition to the 8 bytes of memory usage each index adds to each individual row, which is 8 gigabytes in this scenario (4 indexes \* 8 bytes \* 250 million rows).</span></span>  
  
 <span data-ttu-id="51587-235">Vollständige Tabellenscans befinden sich normalerweise nicht im leistungskritischen Pfad für OLTP-Arbeitsauslastungen.</span><span class="sxs-lookup"><span data-stu-id="51587-235">Full table scans are not usually in the performance-critical path for OLTP workloads.</span></span> <span data-ttu-id="51587-236">Daher muss eine Wahl zwischen Arbeitsspeicherauslastung und Leistung von Punktsuchen und Einfügevorgängen getroffen werden:</span><span class="sxs-lookup"><span data-stu-id="51587-236">Therefore, the choice is between memory utilization versus performance of point lookup and insert operations:</span></span>  
  
-   <span data-ttu-id="51587-237">Wenn die Arbeitsspeicherauslastung wichtig ist, wählen Sie eine Bucketanzahl aus, die nahe an der Anzahl der Indexschlüsselwerte liegt.</span><span class="sxs-lookup"><span data-stu-id="51587-237">If memory utilization is a concern, choose a bucket count close to the number of index key values.</span></span> <span data-ttu-id="51587-238">Die Bucketanzahl sollte nicht deutlich niedriger sein als die Anzahl der Indexschlüsselwerte, da dies Auswirkungen auf die meisten DML-Vorgänge sowie die Zeit hat, die zum Wiederherstellen der Datenbank nach einem Neustart des Servers benötigt wird.</span><span class="sxs-lookup"><span data-stu-id="51587-238">The bucket count should not be significantly lower than the number of index key values, as this impacts most DML operations as well the time it takes to recover the database after server restart.</span></span>  
  
-   <span data-ttu-id="51587-239">Beim Optimieren der Leistung für Punktsuchen ist eine höhere Bucketanzahl (das Zwei- oder Dreifache der Anzahl von eindeutigen Indexwerten) angemessen.</span><span class="sxs-lookup"><span data-stu-id="51587-239">When optimizing the performance for point lookups, a higher bucket count of two or even three times the number of unique index values would be appropriate.</span></span> <span data-ttu-id="51587-240">Eine höhere Bucketanzahl würde eine erhöhte Speicherauslastung bedeuten und die benötigte Zeit für einen vollständigen Indexscan verlängern.</span><span class="sxs-lookup"><span data-stu-id="51587-240">A higher bucket count would mean an increased memory utilization and an increase in the time required for a full index scan.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="51587-241">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="51587-241">See Also</span></span>  
 [<span data-ttu-id="51587-242">Indizes für speicheroptimierte Tabellen</span><span class="sxs-lookup"><span data-stu-id="51587-242">Indexes on Memory-Optimized Tables</span></span>](../../2014/database-engine/indexes-on-memory-optimized-tables.md)  
  
  
