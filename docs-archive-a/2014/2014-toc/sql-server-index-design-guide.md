---
title: Handbuch zum SQL Server Indexentwurf | Microsoft-Dokumentation
ms.custom: ''
ms.date: 06/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
ms.assetid: b856ee9a-49e7-4fab-a88d-48a633fce269
author: rothja
ms.author: jroth
ms.openlocfilehash: 1f5ad72413fe71004fb1c5f125969b984db815d3
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/04/2020
ms.locfileid: "87608952"
---
# <a name="sql-server-index-design-guide"></a><span data-ttu-id="bcdf2-102">Handbuch zum SQL Server Indexentwurf</span><span class="sxs-lookup"><span data-stu-id="bcdf2-102">SQL Server Index Design Guide</span></span>

  <span data-ttu-id="bcdf2-103">Schlecht entworfene oder fehlende Indizes sind die Hauptquellen für Engpässe der Datenbankanwendung.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-103">Poorly designed indexes and a lack of indexes are primary sources of database application bottlenecks.</span></span> <span data-ttu-id="bcdf2-104">Ein effizienter Indexentwurf ist zum Erzielen einer guten Datenbank- und Anwendungsleistung unabdinglich.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-104">Designing efficient indexes is paramount to achieving good database and application performance.</span></span> <span data-ttu-id="bcdf2-105">Die in diesem Handbuch zum SQL Server Indexentwurf enthaltenen Informationen und Best Practices unterstützen Sie beim Entwerfen effizienter Indizes, die den Anforderungen Ihrer Anwendung entsprechen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-105">This SQL Server index design guide contains information and best practices to help you design effective indexes to meet the needs of your application.</span></span>  
  
<span data-ttu-id="bcdf2-106">**Gilt für**: [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] bis, [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] sofern nichts anderes angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-106">**Applies to**: [!INCLUDE[ssVersion2005](../includes/ssversion2005-md.md)] through [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] unless noted otherwise.</span></span>  
  
 <span data-ttu-id="bcdf2-107">In diesem Handbuch wird davon ausgegangen, dass der Leser grundsätzlich mit den in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]verfügbaren Indextypen vertraut ist.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-107">This guide assumes the reader has a general understanding of the index types available in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="bcdf2-108">Eine allgemeine Beschreibung zu Indextypen finden Sie unter [Indextypen](../relational-databases/indexes/indexes.md).</span><span class="sxs-lookup"><span data-stu-id="bcdf2-108">For a general description of index types, see [Index Types](../relational-databases/indexes/indexes.md).</span></span>  
  
##  <a name="in-this-guide"></a><a name="Top"></a><span data-ttu-id="bcdf2-109">In dieser Anleitung</span><span class="sxs-lookup"><span data-stu-id="bcdf2-109">In This Guide</span></span>  

 [<span data-ttu-id="bcdf2-110">Grundlagen des Index Entwurfs</span><span class="sxs-lookup"><span data-stu-id="bcdf2-110">Index Design Basics</span></span>](#Basics)  
  
 [<span data-ttu-id="bcdf2-111">Allgemeine Richtlinien zum Index Entwurf</span><span class="sxs-lookup"><span data-stu-id="bcdf2-111">General Index Design Guidelines</span></span>](#General_Design)  
  
 [<span data-ttu-id="bcdf2-112">Entwurfs Richtlinien für gruppierte Indizes</span><span class="sxs-lookup"><span data-stu-id="bcdf2-112">Clustered Index Design Guidelines</span></span>](#Clustered)  
  
 [<span data-ttu-id="bcdf2-113">Entwurfs Richtlinien für nicht gruppierte Indizes</span><span class="sxs-lookup"><span data-stu-id="bcdf2-113">Nonclustered Index Design Guidelines</span></span>](#Nonclustered)  
  
 [<span data-ttu-id="bcdf2-114">Richtlinien zum Entwerfen eindeutiger Indizes</span><span class="sxs-lookup"><span data-stu-id="bcdf2-114">Unique Index Design Guidelines</span></span>](#Unique)  
  
 [<span data-ttu-id="bcdf2-115">Entwurfs Richtlinien für gefilterte Indizes</span><span class="sxs-lookup"><span data-stu-id="bcdf2-115">Filtered Index Design Guidelines</span></span>](#Filtered)  
  
 [<span data-ttu-id="bcdf2-116">Zusätzliches lesen</span><span class="sxs-lookup"><span data-stu-id="bcdf2-116">Additional Reading</span></span>](#Additional_Reading)  
  
##  <a name="index-design-basics"></a><a name="Basics"></a> <span data-ttu-id="bcdf2-117">Grundlagen des Indexentwurfs</span><span class="sxs-lookup"><span data-stu-id="bcdf2-117">Index Design Basics</span></span>  

 <span data-ttu-id="bcdf2-118">Ein Index ist eine Struktur auf dem Datenträger, die einer Tabelle oder einer Sicht zugeordnet ist und durch die das Abrufen von Zeilen aus der Tabelle oder Sicht beschleunigt wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-118">An index is an on-disk structure associated with a table or view that speeds retrieval of rows from the table or view.</span></span> <span data-ttu-id="bcdf2-119">Ein Index enthält Schlüssel, die aus einer oder mehreren Spalten in der Tabelle oder Sicht erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-119">An index contains keys built from one or more columns in the table or view.</span></span> <span data-ttu-id="bcdf2-120">Diese Schlüssel werden in einer Struktur (B-Struktur) gespeichert, die es SQL Server ermöglicht, die den Schlüsselwerten zugeordneten Zeilen schnell und effizient zu finden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-120">These keys are stored in a structure (B-tree) that enables SQL Server to find the row or rows associated with the key values quickly and efficiently.</span></span>  
  
 <span data-ttu-id="bcdf2-121">Das Auswählen der richtigen Indizes für eine Datenbank und ihre Arbeitsauslastung ist ein komplexer Vorgang, bei dem ein ausgewogenes Verhältnis zwischen gewünschter Abfragegeschwindigkeit und vertretbaren Updatekosten erzielt werden muss.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-121">The selection of the right indexes for a database and its workload is a complex balancing act between query speed and update cost.</span></span> <span data-ttu-id="bcdf2-122">Schmale Indizes (Indizes mit wenigen Spalten im Indexschlüssel) erfordern weniger Speicherplatz und Wartungsaufwand.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-122">Narrow indexes, or indexes with few columns in the index key, require less disk space and maintenance overhead.</span></span> <span data-ttu-id="bcdf2-123">Breite Indizes decken jedoch eine größere Anzahl an Abfragen ab.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-123">Wide indexes, on the other hand, cover more queries.</span></span> <span data-ttu-id="bcdf2-124">Möglicherweise müssen Sie mit verschiedenen Entwürfen experimentieren, bevor Sie den effizientesten Index ermitteln.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-124">You may have to experiment with several different designs before finding the most efficient index.</span></span> <span data-ttu-id="bcdf2-125">Indizes können ohne Auswirkungen auf das Datenbankschema oder den Anwendungsentwurf hinzugefügt, geändert und gelöscht werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-125">Indexes can be added, modified, and dropped without affecting the database schema or application design.</span></span> <span data-ttu-id="bcdf2-126">Daher sollten Sie in jedem Fall mit verschiedenen Indizes experimentieren.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-126">Therefore, you should not hesitate to experiment with different indexes.</span></span>  
  
 <span data-ttu-id="bcdf2-127">Der Abfrageoptimierer von [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] wählt in der Mehrzahl der Fälle zuverlässig den effektivsten Index aus.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-127">The query optimizer in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] reliably chooses the most effective index in the vast majority of cases.</span></span> <span data-ttu-id="bcdf2-128">Indexentwurfsstrategie sollte sein, dem Abfrageoptimierer eine Vielzahl von Indizes zur Auswahl bereitzustellen und sich darauf zu verlassen, dass dieser die richtige Entscheidung trifft.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-128">Your overall index design strategy should provide a variety of indexes for the query optimizer to choose from and trust it to make the right decision.</span></span> <span data-ttu-id="bcdf2-129">Auf diese Weise wird die Analysezeit verkürzt und ein gutes Leistungsverhalten in vielen unterschiedlichen Situationen erzielt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-129">This reduces analysis time and produces good performance over a variety of situations.</span></span> <span data-ttu-id="bcdf2-130">Wenn Sie anzeigen möchten, welche Indizes der Abfrageoptimierer für eine bestimmte Abfrage verwendet, wählen Sie in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]die Option **Tatsächlichen Ausführungsplan einschließen** aus dem Menü **Abfrage**aus.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-130">To see which indexes the query optimizer uses for a specific query, in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], on the **Query** menu, select **Include Actual Execution Plan**.</span></span>  
  
 <span data-ttu-id="bcdf2-131">Setzen Sie Indexverwendung aber nicht stets mit gutem Leistungsverhalten bzw. gute Leistung mit effizienter Indexverwendung gleich.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-131">Do not always equate index usage with good performance, and good performance with efficient index use.</span></span> <span data-ttu-id="bcdf2-132">Würde durch die Verwendung eines Indexes in jedem Fall die beste Leistung erzielt, so wäre die Arbeit des Abfrageoptimierers sehr einfach.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-132">If using an index always helped produce the best performance, the job of the query optimizer would be simple.</span></span> <span data-ttu-id="bcdf2-133">Tatsächlich kann die Auswahl eines falschen Indexes eine Leistung bewirken, die nicht optimal ist.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-133">In reality, an incorrect index choice can cause less than optimal performance.</span></span> <span data-ttu-id="bcdf2-134">Daher besteht die Aufgabe des Abfrageoptimierers darin, einen Index oder eine Kombination aus Indizes nur dann auszuwählen, wenn die Leistung verbessert wird, und den indizierten Abruf zu vermeiden, wenn die Leistung negativ beeinflusst wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-134">Therefore, the task of the query optimizer is to select an index, or combination of indexes, only when it will improve performance, and to avoid indexed retrieval when it will hinder performance.</span></span>  
  
### <a name="index-design-tasks"></a><span data-ttu-id="bcdf2-135">Aufgaben beim Indexentwurf</span><span class="sxs-lookup"><span data-stu-id="bcdf2-135">Index Design Tasks</span></span>  

 <span data-ttu-id="bcdf2-136">Die folgenden Aufgaben fassen die empfohlene Strategie beim Entwerfen von Indizes zusammen:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-136">The follow tasks make up our recommended strategy for designing indexes:</span></span>  
  
1.  <span data-ttu-id="bcdf2-137">Verstehen der Merkmale der Datenbank selbst.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-137">Understand the characteristics of the database itself.</span></span> <span data-ttu-id="bcdf2-138">Wird die Datenbank z. B. für die Onlinetransaktionsverarbeitung (OLTP) mit häufigen Datenänderungen oder als Entscheidungsunterstützungssystem (EUS) bzw. als Data Warehousing-Datenbank (OLAP-Datenbank) verwendet, die hauptsächlich schreibgeschützte Daten enthält und sehr große Datasets schnell verarbeiten muss?</span><span class="sxs-lookup"><span data-stu-id="bcdf2-138">For example, is it an online transaction processing (OLTP) database with frequent data modifications, or a Decision Support System (DSS) or data warehousing (OLAP) database that contains primarily read-only data and must process very large data sets quickly.</span></span> <span data-ttu-id="bcdf2-139">In [!INCLUDE[ssSQL11](../includes/sssql11-md.md)]ist der *speicheroptimierte xVelocity-columnstore* -Index besonders gut für typische Data Warehousing-Datasets geeignet.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-139">In [!INCLUDE[ssSQL11](../includes/sssql11-md.md)], *xVelocity memory optimized columnstore* index is especially appropriate for typical data warehousing data sets.</span></span> <span data-ttu-id="bcdf2-140">Columnstore-Indizes verbessern die Benutzererfahrung im Bereich Data Warehousing, da sie die schnellere Ausführung allgemeiner Data Warehousing-Abfragen, wie Filter-, Aggregierungs-, Gruppierungs- und Sternjoinabfragen ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-140">Columnstore indexes can transform the data warehousing experience for users by enabling faster performance for common data warehousing queries such as filtering, aggregating, grouping, and star-join queries.</span></span> <span data-ttu-id="bcdf2-141">Weitere Informationen finden Sie unter [Beschreibung von columnstore-Indizes](../relational-databases/indexes/columnstore-indexes-described.md).</span><span class="sxs-lookup"><span data-stu-id="bcdf2-141">For more information, see [Columnstore Indexes Described](../relational-databases/indexes/columnstore-indexes-described.md).</span></span>  
  
2.  <span data-ttu-id="bcdf2-142">Verstehen der Merkmale der am häufigsten verwendeten Abfragen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-142">Understand the characteristics of the most frequently used queries.</span></span> <span data-ttu-id="bcdf2-143">Wenn Sie z. B. wissen, dass eine häufig verwendete Abfrage zwei oder mehr Tabellen verknüpft, unterstützt Sie dieses Wissen beim Ermitteln der zu verwendenden effizientesten Indextypen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-143">For example, knowing that a frequently used query joins two or more tables will help you determine the best type of indexes to use.</span></span>  
  
3.  <span data-ttu-id="bcdf2-144">Verstehen der Merkmale der in den Abfragen verwendeten Spalten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-144">Understand the characteristics of the columns used in the queries.</span></span> <span data-ttu-id="bcdf2-145">Ein Index eignet sich z. B. ideal für Spalten, die einen ganzzahligen Datentyp besitzen und außerdem eindeutige oder Nicht-NULL-Spalten sind.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-145">For example, an index is ideal for columns that have an integer data type and are also unique or nonnull columns.</span></span> <span data-ttu-id="bcdf2-146">Für Spalten, die klar definierte Teilmengen von Daten enthalten, können Sie in [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] und höheren Versionen einen gefilterten Index verwenden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-146">For columns that have well-defined subsets of data, you can use a filtered index in [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] and higher versions.</span></span> <span data-ttu-id="bcdf2-147">Weitere Informationen finden Sie unter [Richtlinien für den Entwurf gefilterter Indizes](#Filtered) in diesem Handbuch.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-147">For more information, see [Filtered Index Design Guidelines](#Filtered) in this guide.</span></span>  
  
4.  <span data-ttu-id="bcdf2-148">Ermitteln, welche Indexoptionen die Leistung steigern können, wenn der Index erstellt oder gewartet wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-148">Determine which index options might enhance performance when the index is created or maintained.</span></span> <span data-ttu-id="bcdf2-149">Für das Erstellen eines gruppierten Indexes für eine vorhandene Tabelle ist z. B. die ONLINE-Indexoption vorteilhaft.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-149">For example, creating a clustered index on an existing large table would benefit from the ONLINE index option.</span></span> <span data-ttu-id="bcdf2-150">Die ONLINE-Option ermöglicht, dass gleichzeitige Aktivitäten für die zugrunde liegenden Daten fortgesetzt werden können, während der Index erstellt oder neu erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-150">The ONLINE option allows for concurrent activity on the underlying data to continue while the index is being created or rebuilt.</span></span> <span data-ttu-id="bcdf2-151">Weitere Informationen finden Sie unter [Festlegen von Indexoptionen](../relational-databases/indexes/set-index-options.md).</span><span class="sxs-lookup"><span data-stu-id="bcdf2-151">For more information, see [Set Index Options](../relational-databases/indexes/set-index-options.md).</span></span>  
  
5.  <span data-ttu-id="bcdf2-152">Angeben des optimalen Speicherorts für den Index.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-152">Determine the optimal storage location for the index.</span></span> <span data-ttu-id="bcdf2-153">Ein nicht gruppierter Index kann in derselben Dateigruppe wie die zugrunde liegende Tabelle oder in einer anderen Dateigruppe gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-153">A nonclustered index can be stored in the same filegroup as the underlying table, or on a different filegroup.</span></span> <span data-ttu-id="bcdf2-154">Der Speicherort von Indizes kann die Abfrageleistung durch Optimieren der Datenträger-E/A-Leistung verbessern.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-154">The storage location of indexes can improve query performance by increasing disk I/O performance.</span></span> <span data-ttu-id="bcdf2-155">Wenn Sie z. B. einen nicht gruppierten Index in einer Dateigruppe speichern, die sich auf einem anderen Datenträger als die Tabellendateigruppe befindet, kann dies die Leistung verbessern, weil mehrere Datenträger gleichzeitig gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-155">For example, storing a nonclustered index on a filegroup that is on a different disk than the table filegroup can improve performance because multiple disks can be read at the same time.</span></span>  
  
     <span data-ttu-id="bcdf2-156">Alternativ können gruppierte und nicht gruppierte Indizes ein dateigruppenübergreifendes Partitionsschema verwenden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-156">Alternatively, clustered and nonclustered indexes can use a partition scheme across multiple filegroups.</span></span> <span data-ttu-id="bcdf2-157">Durch die Partitionierung sind große Tabellen oder Indizes leichter zu verwalten, denn Sie können dadurch schnell und effizient auf Datenteilmengen zugreifen und sie verwalten, während die Integrität der gesamten Sammlung erhalten bleibt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-157">Partitioning makes large tables or indexes more manageable by letting you access or manage subsets of data quickly and efficiently, while maintaining the integrity of the overall collection.</span></span> <span data-ttu-id="bcdf2-158">Weitere Informationen finden Sie unter [partitionierte Tabellen und Indizes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="bcdf2-158">For more information, see [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span></span> <span data-ttu-id="bcdf2-159">Wenn Sie Partitionierung in Erwägung ziehen, müssen Sie festlegen, ob der Index ausgerichtet sein soll, d. h., ob er weitgehend wie die Tabelle oder unabhängig davon partitioniert werden soll.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-159">When you consider partitioning, determine whether the index should be aligned, that is, partitioned in essentially the same manner as the table, or partitioned independently.</span></span>  
  
##  <a name="general-index-design-guidelines"></a><a name="General_Design"></a> <span data-ttu-id="bcdf2-160">Allgemeine Richtlinien zum Indexentwurf</span><span class="sxs-lookup"><span data-stu-id="bcdf2-160">General Index Design Guidelines</span></span>  

 <span data-ttu-id="bcdf2-161">Erfahrene Datenbankadministratoren sind in der Lage, einen geeigneten Satz an Indizes zu entwerfen. Es handelt sich jedoch selbst bei gemäßigt komplexen Datenbanken und Arbeitsauslastungen um eine sehr komplexe, zeitintensive und fehleranfällige Aufgabe.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-161">Experienced database administrators can design a good set of indexes, but this task is very complex, time-consuming, and error-prone even for moderately complex databases and workloads.</span></span> <span data-ttu-id="bcdf2-162">Das Verständnis der Merkmale der Datenbank, Abfragen und Datenspalten kann Sie beim Entwerfen optimaler Indizes unterstützen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-162">Understanding the characteristics of your database, queries, and data columns can help you design optimal indexes.</span></span>  
  
### <a name="database-considerations"></a><span data-ttu-id="bcdf2-163">Überlegungen zu Datenbanken</span><span class="sxs-lookup"><span data-stu-id="bcdf2-163">Database Considerations</span></span>  

 <span data-ttu-id="bcdf2-164">Beachten Sie beim Entwerfen eines Indexes die folgenden Datenbankrichtlinien:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-164">When you design an index, consider the following database guidelines:</span></span>  
  
-   <span data-ttu-id="bcdf2-165">Eine große Anzahl an Indizes für eine Tabelle beeinträchtigt die Leistung von INSERT-, UPDATE-, DELETE- und MERGE-Anweisungen, da alle Indizes entsprechend angepasst werden müssen, sobald Daten in der Tabelle geändert werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-165">Large numbers of indexes on a table affect the performance of INSERT, UPDATE, DELETE, and MERGE statements because all indexes must be adjusted appropriately as data in the table changes.</span></span> <span data-ttu-id="bcdf2-166">Beispiel: Wenn eine Spalte in mehreren Indizes verwendet wird und Sie eine UPDATE-Anweisung ausführen, durch die Daten in dieser Spalte geändert werden, müssen alle Indizes, die diese Spalte enthalten, sowie die Spalte in der zugrunde liegenden Basistabelle (Heap oder gruppierter Index) ebenfalls aktualisiert werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-166">For example, if a column is used in several indexes and you execute an UPDATE statement that modifies that column's data, each index that contains that column must be updated as well as the column in the underlying base table (heap or clustered index).</span></span>  
  
    -   <span data-ttu-id="bcdf2-167">Vermeiden Sie die zu starke Indizierung häufig aktualisierter Tabellen, und halten Sie die Indizes schmal, d. h., verwenden Sie so wenig Spalten wie möglich.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-167">Avoid over-indexing heavily updated tables and keep indexes narrow, that is, with as few columns as possible.</span></span>  
  
    -   <span data-ttu-id="bcdf2-168">Verwenden Sie viele Indizes, um die Abfrageleistung für Tabellen zu verbessern, die geringe Updateanforderungen und große Datenmengen aufweisen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-168">Use many indexes to improve query performance on tables with low update requirements, but large volumes of data.</span></span> <span data-ttu-id="bcdf2-169">Eine große Anzahl an Indizes kann die Leistung von Abfragen steigern, durch die keine Daten geändert werden (z. B. SELECT-Anweisungen), da der Abfrageoptimierer aus einer größeren Anzahl an Indizes auswählen kann, um die beste Methode für den schnellstmöglichen Zugriff zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-169">Large numbers of indexes can help the performance of queries that do not modify data, such as SELECT statements, because the query optimizer has more indexes to choose from to determine the fastest access method.</span></span>  
  
-   <span data-ttu-id="bcdf2-170">Das Indizieren kleiner Tabellen ist häufig nicht die optimale Methode, da der Abfrageoptimierer in diesem Fall mitunter mehr Zeit benötigt, um die Daten über einen Index zu suchen, als für die Durchführung eines einfachen Tabellenscans erforderlich wäre.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-170">Indexing small tables may not be optimal because it can take the query optimizer longer to traverse the index searching for data than to perform a simple table scan.</span></span> <span data-ttu-id="bcdf2-171">Aus diesem Grund werden Indizes für kleine Tabellen möglicherweise niemals verwendet, müssen jedoch trotzdem verwaltet werden, wenn sich Daten in der Tabelle ändern.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-171">Therefore, indexes on small tables might never be used, but must still be maintained as data in the table changes.</span></span>  
  
-   <span data-ttu-id="bcdf2-172">Indizes für Sichten können zu erheblichen Leistungsverbesserungen führen, wenn die Sicht Aggregationen, Tabellenjoins oder eine Kombination aus Aggregationen und Joins enthält.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-172">Indexes on views can provide significant performance gains when the view contains aggregations, table joins, or a combination of aggregations and joins.</span></span> <span data-ttu-id="bcdf2-173">Es ist nicht erforderlich, dass in der Abfrage explizit auf die jeweilige Sicht verwiesen wird, damit der Abfrageoptimierer die Sicht verwendet.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-173">The view does not have to be explicitly referenced in the query for the query optimizer to use it.</span></span>  
  
-   <span data-ttu-id="bcdf2-174">Verwenden Sie den Datenbankoptimierungsratgeber, um die Datenbank zu analysieren und Indexempfehlungen zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-174">Use the Database Engine Tuning Advisor to analyze your database and make index recommendations.</span></span> <span data-ttu-id="bcdf2-175">Weitere Informationen finden Sie unter [Database Engine Tuning Advisor](../relational-databases/performance/database-engine-tuning-advisor.md).</span><span class="sxs-lookup"><span data-stu-id="bcdf2-175">For more information, see [Database Engine Tuning Advisor](../relational-databases/performance/database-engine-tuning-advisor.md).</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="bcdf2-176">Überlegungen zu Abfragen</span><span class="sxs-lookup"><span data-stu-id="bcdf2-176">Query Considerations</span></span>  

 <span data-ttu-id="bcdf2-177">Beachten Sie beim Entwerfen eines Indexes die folgenden Abfragerichtlinien:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-177">When you design an index, consider the following query guidelines:</span></span>  
  
-   <span data-ttu-id="bcdf2-178">Erstellen Sie nicht gruppierte Indizes für die Spalten, die häufig in Prädikaten und Joinbedingungen in Abfragen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-178">Create nonclustered indexes on the columns that are frequently used in predicates and join conditions in queries.</span></span> <span data-ttu-id="bcdf2-179">Sie sollten jedoch keine unnötigen Spalten hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-179">However, you should avoid adding unnecessary columns.</span></span> <span data-ttu-id="bcdf2-180">Wenn Sie zu viele Indexspalten hinzufügen, kann sich dies negativ auf den Speicherplatz und die Indexverwaltungsleistung auswirken.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-180">Adding too many index columns can adversely affect disk space and index maintenance performance.</span></span>  
  
-   <span data-ttu-id="bcdf2-181">Abdeckende Indizes können die Abfrageleistung steigern, weil alle Daten im Index selbst enthalten sind, die die Anforderungen der Abfrage erfüllen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-181">Covering indexes can improve query performance because all the data needed to meet the requirements of the query exists within the index itself.</span></span> <span data-ttu-id="bcdf2-182">Auf diese Weise muss nur auf die Indexseiten und nicht auf die Datenseiten der Tabelle oder des gruppierten Indexes verwiesen werden, um die abgefragten Daten abzurufen, wodurch der Umfang der E/A-Operationen des Datenträgers verringert wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-182">That is, only the index pages, and not the data pages of the table or clustered index, are required to retrieve the requested data; therefore, reducing overall disk I/O.</span></span> <span data-ttu-id="bcdf2-183">Eine Abfrage der Spalten **a** und **b** für eine Tabelle, die einen zusammengesetzten Index besitzt, der für die Spalten **a**, **b**und **c** erstellt wurde, kann die angegebenen Daten ausschließlich aus dem Index abrufen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-183">For example, a query of columns **a** and **b** on a table that has a composite index created on columns **a**, **b**, and **c** can retrieve the specified data from the index alone.</span></span>  
  
-   <span data-ttu-id="bcdf2-184">Schreiben Sie Abfragen, die möglichst viele Zeilen in einer einzigen Anweisung einfügen oder ändern, anstatt mehrere Abfragen zum Aktualisieren der gleichen Zeilen zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-184">Write queries that insert or modify as many rows as possible in a single statement, instead of using multiple queries to update the same rows.</span></span> <span data-ttu-id="bcdf2-185">Wenn nur eine Anweisung verwendet wird, kann der Index optimal verwaltet werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-185">By using only one statement, optimized index maintenance could be exploited.</span></span>  
  
-   <span data-ttu-id="bcdf2-186">Werten Sie den Abfragetyp sowie die Art der Verwendung von Spalten in der Abfrage aus.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-186">Evaluate the query type and how columns are used in the query.</span></span> <span data-ttu-id="bcdf2-187">Eine Spalte, die in einem Abfragetyp für genaue Übereinstimmung verwendet wird, ist z. B. ein guter Kandidat für einen nicht gruppierten oder gruppierten Index.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-187">For example, a column used in an exact-match query type would be a good candidate for a nonclustered or clustered index.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="bcdf2-188">Überlegungen zu Spalten</span><span class="sxs-lookup"><span data-stu-id="bcdf2-188">Column Considerations</span></span>  

 <span data-ttu-id="bcdf2-189">Beachten Sie beim Entwerfen eines Indexes die folgenden Spaltenrichtlinien:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-189">When you design an index consider the following column guidelines:</span></span>  
  
-   <span data-ttu-id="bcdf2-190">Wählen Sie für gruppierte Indizes einen kurzen Indexschlüssel aus.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-190">Keep the length of the index key short for clustered indexes.</span></span> <span data-ttu-id="bcdf2-191">Gruppierte Indizes bieten darüber hinaus den Vorteil, dass sie für eindeutige oder Nicht-NULL-Spalten erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-191">Additionally, clustered indexes benefit from being created on unique or nonnull columns.</span></span>  
  
-   <span data-ttu-id="bcdf2-192">Spalten, die die `ntext`-, `text`-, `image`-, `varchar(max)`-, `nvarchar(max)`- und `varbinary(max)`-Datentypen verwenden, können nicht als Indexschlüsselspalten angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-192">Columns that are of the `ntext`, `text`, `image`, `varchar(max)`, `nvarchar(max)`, and `varbinary(max)` data types cannot be specified as index key columns.</span></span> <span data-ttu-id="bcdf2-193">`varchar(max)`-, `nvarchar(max)`-, `varbinary(max)`- und `xml`-Datentypen können jedoch als Nichtschlüssel-Indexspalten in einen nicht gruppierten Index aufgenommen werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-193">However, `varchar(max)`, `nvarchar(max)`, `varbinary(max)`, and `xml` data types can participate in a nonclustered index as nonkey index columns.</span></span> <span data-ttu-id="bcdf2-194">Weitere Informationen finden Sie im Abschnitt [Index mit eingeschlossenen Spalten](#Included_Columns)in diesem Handbuch.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-194">For more information, see the section ['Index with Included Columns](#Included_Columns)' in this guide.</span></span>  
  
-   <span data-ttu-id="bcdf2-195">Ein `xml`-Datentyp kann nur in einem XML-Index eine Schlüsselspalte sein.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-195">An `xml` data type can only be a key column only in an XML index.</span></span> <span data-ttu-id="bcdf2-196">Weitere Informationen finden Sie unter [XML-Indizes &#40;SQL Server&#41;](../relational-databases/xml/xml-indexes-sql-server.md).</span><span class="sxs-lookup"><span data-stu-id="bcdf2-196">For more information, see [XML Indexes &#40;SQL Server&#41;](../relational-databases/xml/xml-indexes-sql-server.md).</span></span> <span data-ttu-id="bcdf2-197">Mit SQL Server 2012 SP1 wird ein neuer XML-Indextyp eingeführt, der als selektiver XML-Index bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-197">SQL Server 2012 SP1 introduces a new type of XML index known as a Selective XML Index.</span></span> <span data-ttu-id="bcdf2-198">Durch diesen neuen Index kann die Abfrageleistung bei Daten verbessert werden, die als XML in SQL Server gespeichert sind. Das sorgt für eine schnellere Indizierung großer XML-Datenmengen und für höhere Skalierbarkeit, indem die Speicherkosten des Indexes gesenkt werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-198">This new index can improve querying performance over data stored as XML in SQL Server, allow for much faster indexing of large XML data workloads, and improve scalability by reducing storage costs of the index itself.</span></span> <span data-ttu-id="bcdf2-199">Weitere Informationen finden Sie unter [Selektive XML-Indizes &#40;SXI&#41;](../relational-databases/xml/selective-xml-indexes-sxi.md).</span><span class="sxs-lookup"><span data-stu-id="bcdf2-199">For more information, see [Selective XML Indexes &#40;SXI&#41;](../relational-databases/xml/selective-xml-indexes-sxi.md).</span></span>  
  
-   <span data-ttu-id="bcdf2-200">Überprüfen Sie die Eindeutigkeit der Spalten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-200">Examine column uniqueness.</span></span> <span data-ttu-id="bcdf2-201">Ein eindeutiger Index anstelle eines nicht eindeutigen Indexes für dieselbe Kombination von Spalten stellt zusätzliche Informationen für den Abfrageoptimierer bereit, die den Index wertvoller machen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-201">A unique index instead of a nonunique index on the same combination of columns provides additional information for the query optimizer that makes the index more useful.</span></span> <span data-ttu-id="bcdf2-202">Weitere Informationen finden Sie unter [Richtlinien zum Entwerfen eindeutiger Indizes](#Unique) in diesem Handbuch.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-202">For more information, see [Unique Index Design Guidelines](#Unique) in this guide.</span></span>  
  
-   <span data-ttu-id="bcdf2-203">Überprüfen Sie die Datenverteilung in der Spalte.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-203">Examine data distribution in the column.</span></span> <span data-ttu-id="bcdf2-204">Häufig dauert eine Abfrage deshalb sehr lange, weil eine indizierte Spalte mit wenigen eindeutigen Werten verwendet wird oder weil sie einen Join mit einer solchen Spalte durchführt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-204">Frequently, a long-running query is caused by indexing a column with few unique values, or by performing a join on such a column.</span></span> <span data-ttu-id="bcdf2-205">Hierbei handelt es sich um ein grundlegendes Problem von Daten und Abfragen, das in der Regel nicht gelöst werden kann, ohne die betreffende Situation zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-205">This is a fundamental problem with the data and query, and generally cannot be resolved without identifying this situation.</span></span> <span data-ttu-id="bcdf2-206">Beispielsweise wird ein physisches Telefonbuch, das alphabetisch nach dem Nachnamen sortiert ist, das Suchen eines Teilnehmers nicht vereinfachen, wenn alle Teilnehmer des Ortsnetzes Smith oder Jones heißen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-206">For example, a physical telephone directory sorted alphabetically on last name will not expedite locating a person if all people in the city are named Smith or Jones.</span></span> <span data-ttu-id="bcdf2-207">Weitere Informationen zur Datenverteilung finden Sie unter [Statistics](../relational-databases/statistics/statistics.md).</span><span class="sxs-lookup"><span data-stu-id="bcdf2-207">For more information about data distribution, see [Statistics](../relational-databases/statistics/statistics.md).</span></span>  
  
-   <span data-ttu-id="bcdf2-208">Verwenden Sie für Spalten mit fest definierten Teilmengen, z. B. Sparsespalten, Spalten, die größtenteils NULL-Werte enthalten, Spalten mit Wertekategorien und Spalten mit verschiedenen Wertebereichen, gefilterte Indizes.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-208">Consider using filtered indexes on columns that have well-defined subsets, for example sparse columns, columns with mostly NULL values, columns with categories of values, and columns with distinct ranges of values.</span></span> <span data-ttu-id="bcdf2-209">Ein gut entworfener gefilterter Index kann die Abfrageleistung verbessern, die Indexwartungskosten reduzieren und den Speicheraufwand verringern.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-209">A well-designed filtered index can improve query performance, reduce index maintenance costs, and reduce storage costs.</span></span>  
  
-   <span data-ttu-id="bcdf2-210">Berücksichtigen Sie die Reihenfolge der Spalten, wenn der Index mehrere Spalten enthalten soll.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-210">Consider the order of the columns if the index will contain multiple columns.</span></span> <span data-ttu-id="bcdf2-211">Die Spalte, die in der WHERE-Klausel in einer Gleich- (=), Größer als- (>), Kleiner als- (<) oder BETWEEN-Suchbedingung verwendet oder in einen Join eingeschlossen wird, sollte an erster Stelle stehen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-211">The column that is used in the WHERE clause in an equal to (=), greater than (>), less than (<), or BETWEEN search condition, or participates in a join, should be placed first.</span></span> <span data-ttu-id="bcdf2-212">Die Reihenfolge zusätzlicher Spalten sollte basierend auf dem Grad ihrer Eindeutigkeit, d. h. von der eindeutigsten Spalte absteigend zu der am wenigsten eindeutigen Spalte, ausgewählt werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-212">Additional columns should be ordered based on their level of distinctness, that is, from the most distinct to the least distinct.</span></span>  
  
     <span data-ttu-id="bcdf2-213">Wenn der Index z. B. als `LastName`, `FirstName` definiert ist, ist der Index hilfreich, wenn das Suchkriterium `WHERE LastName = 'Smith'` oder `WHERE LastName = Smith AND FirstName LIKE 'J%'`lautet.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-213">For example, if the index is defined as `LastName`, `FirstName` the index will be useful when the search criterion is `WHERE LastName = 'Smith'` or `WHERE LastName = Smith AND FirstName LIKE 'J%'`.</span></span> <span data-ttu-id="bcdf2-214">Der Abfrageoptimierer verwendet den Index jedoch nicht für eine Abfrage, die nur nach `FirstName (WHERE FirstName = 'Jane')`sucht.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-214">However, the query optimizer would not use the index for a query that searched only on `FirstName (WHERE FirstName = 'Jane')`.</span></span>  
  
-   <span data-ttu-id="bcdf2-215">Ziehen Sie das Indizieren berechneter Spalten in Betracht.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-215">Consider indexing computed columns.</span></span> <span data-ttu-id="bcdf2-216">Weitere Informationen finden Sie unter [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span><span class="sxs-lookup"><span data-stu-id="bcdf2-216">For more information, see [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span></span>  
  
### <a name="index-characteristics"></a><span data-ttu-id="bcdf2-217">Indexmerkmale</span><span class="sxs-lookup"><span data-stu-id="bcdf2-217">Index Characteristics</span></span>  

 <span data-ttu-id="bcdf2-218">Wenn sich herausgestellt hat, dass ein Index für eine Abfrage geeignet ist, können Sie den Indextyp auswählen, der für die jeweilige Situation am besten geeignet ist.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-218">After you have determined that an index is appropriate for a query, you can select the type of index that best fits your situation.</span></span> <span data-ttu-id="bcdf2-219">Die Indexmerkmale beziehen sich z. B. auf Folgendes:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-219">Index characteristics include the following:</span></span>  
  
-   <span data-ttu-id="bcdf2-220">Gruppiert im Vergleich zu nicht gruppiert</span><span class="sxs-lookup"><span data-stu-id="bcdf2-220">Clustered versus nonclustered</span></span>  
  
-   <span data-ttu-id="bcdf2-221">Eindeutig im Vergleich zu nicht eindeutig</span><span class="sxs-lookup"><span data-stu-id="bcdf2-221">Unique versus nonunique</span></span>  
  
-   <span data-ttu-id="bcdf2-222">Einspaltig im Vergleich zu mehrspaltig</span><span class="sxs-lookup"><span data-stu-id="bcdf2-222">Single column versus multicolumn</span></span>  
  
-   <span data-ttu-id="bcdf2-223">Aufsteigende oder absteigende Reihenfolge in den Spalten des Indexes</span><span class="sxs-lookup"><span data-stu-id="bcdf2-223">Ascending or descending order on the columns in the index</span></span>  
  
-   <span data-ttu-id="bcdf2-224">Tabellenindizes im Vergleich zu gefilterten für nicht gruppierte Indizes</span><span class="sxs-lookup"><span data-stu-id="bcdf2-224">Full-table versus filtered for nonclustered indexes</span></span>  
  
 <span data-ttu-id="bcdf2-225">Um die Indexleistung- oder -wartung zu optimieren, können Sie durch das Festlegen einer Option wie z. B. FILLFACTOR auch die Ausgangsspeichermerkmale des Indexes anpassen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-225">You can also customize the initial storage characteristics of the index to optimize its performance or maintenance by setting an option such as FILLFACTOR.</span></span> <span data-ttu-id="bcdf2-226">Zudem können Sie den Speicherort des Indexes mithilfe von Dateigruppen oder Partitionsschemas festlegen, um die Leistung zu optimieren.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-226">Also, you can determine the index storage location by using filegroups or partition schemes to optimize performance.</span></span>  
  
###  <a name="index-placement-on-filegroups-or-partitions-schemes"></a><a name="Index_placement"></a> <span data-ttu-id="bcdf2-227">Indexplatzierung in Dateigruppen oder Partitionsschemas</span><span class="sxs-lookup"><span data-stu-id="bcdf2-227">Index Placement on Filegroups or Partitions Schemes</span></span>  

 <span data-ttu-id="bcdf2-228">Bei der Entwicklung einer Indexentwurfsstrategie sollten Sie die Platzierung der Indizes in den Dateigruppen berücksichtigen, die der Datenbank zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-228">As you develop your index design strategy, you should consider the placement of the indexes on the filegroups associated with the database.</span></span> <span data-ttu-id="bcdf2-229">Das sorgfältige Auswählen der Dateigruppe oder des Partitionsschemas kann die Abfrageleistung verbessern.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-229">Careful selection of the filegroup or partition scheme can improve query performance.</span></span>  
  
 <span data-ttu-id="bcdf2-230">Standardmäßig werden Indizes in derselben Dateigruppe wie die Basistabelle gespeichert, für die der Index erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-230">By default, indexes are stored in the same filegroup as the base table on which the index is created.</span></span> <span data-ttu-id="bcdf2-231">Ein nicht partitionierter, gruppierter Index und die Basistabelle befinden sich immer in der gleichen Dateigruppe.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-231">A nonpartitioned clustered index and the base table always reside in the same filegroup.</span></span> <span data-ttu-id="bcdf2-232">Sie können jedoch folgende Aktionen ausführen:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-232">However, you can do the following:</span></span>  
  
-   <span data-ttu-id="bcdf2-233">Erstellen nicht gruppierter Indizes in einer anderen Dateigruppe als der Dateigruppe der Basistabelle oder des gruppierten Indexes.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-233">Create nonclustered indexes on a filegroup other than the filegroup of the base table or clustered index.</span></span>  
  
-   <span data-ttu-id="bcdf2-234">Partitionieren von gruppierten und nicht gruppierten Indizes, damit diese mehrere Dateigruppen umfassen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-234">Partition clustered and nonclustered indexes to span multiple filegroups.</span></span>  
  
-   <span data-ttu-id="bcdf2-235">Verschieben einer Tabelle aus einer Dateigruppe in eine andere durch Löschen des gruppierten Index und Angeben einer neuen Dateigruppe oder eines Partitionsschemas in der MOVE TO-Klausel der DROP INDEX-Anweisung oder durch Verwenden der CREATE INDEX-Anweisung mit der DROP_EXISTIN-Klausel.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-235">Move a table from one filegroup to another by dropping the clustered index and specifying a new filegroup or partition scheme in the MOVE TO clause of the DROP INDEX statement or by using the CREATE INDEX statement with the DROP_EXISTING clause.</span></span>  
  
 <span data-ttu-id="bcdf2-236">Wird der nicht gruppierte Index in einer anderen Dateigruppe erstellt, können Leistungsvorteile erzielt werden, wenn die Dateigruppen verschiedene physische Laufwerke mit eigenen Controllern verwenden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-236">By creating the nonclustered index on a different filegroup, you can achieve performance gains if the filegroups are using different physical drives with their own controllers.</span></span> <span data-ttu-id="bcdf2-237">Daten und Indexinformationen können dann parallel von mehreren Leseköpfen gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-237">Data and index information can then be read in parallel by the multiple disk heads.</span></span> <span data-ttu-id="bcdf2-238">Werden beispielsweise `Table_A` in Dateigruppe `f1` und `Index_A` in Dateigruppe `f2` von derselben Abfrage verwendet, können Leistungsvorteile erzielt werden, da beide Dateigruppen konfliktfrei vollständig verwendet werden können.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-238">For example, if `Table_A` on filegroup `f1` and `Index_A` on filegroup `f2` are both being used by the same query, performance gains can be achieved because both filegroups are being fully used without contention.</span></span> <span data-ttu-id="bcdf2-239">Wenn `Table_A` von der Abfrage durchsucht wird, ohne dass auf `Index_A` verwiesen wird, wird jedoch nur Dateigruppe `f1` verwendet.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-239">However, if `Table_A` is scanned by the query but `Index_A` is not referenced, only filegroup `f1` is used.</span></span> <span data-ttu-id="bcdf2-240">In diesem Fall ist kein Leistungsgewinn zu verzeichnen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-240">This creates no performance gain.</span></span>  
  
 <span data-ttu-id="bcdf2-241">Da jedoch nicht vorhersehbar ist, welche Zugriffsart wann erfolgt, ist die Entscheidung für das Verteilen der Tabellen und Indizes auf alle Dateigruppen häufig die bessere Lösung.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-241">Because you cannot predict what type of access will occur and when it will occur, it could be a better decision to spread your tables and indexes across all filegroups.</span></span> <span data-ttu-id="bcdf2-242">So ist sichergestellt, dass unabhängig von der Art des Datenzugriffs auf alle Datenträger zugegriffen wird, da alle Daten und Indizes gleichmäßig auf alle Datenträger verteilt sind.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-242">This would guarantee that all disks are being accessed because all data and indexes are spread evenly across all disks, regardless of which way the data is accessed.</span></span> <span data-ttu-id="bcdf2-243">Diese Lösung ist auch aus Systemadministratorensicht einfacher.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-243">This is also a simpler approach for system administrators.</span></span>  
  
#### <a name="partitions-across-multiple-filegroups"></a><span data-ttu-id="bcdf2-244">Partitionen über mehrere Dateigruppen</span><span class="sxs-lookup"><span data-stu-id="bcdf2-244">Partitions Across Multiple Filegroups</span></span>  

 <span data-ttu-id="bcdf2-245">Sie können auch das Partitionieren von gruppierten und nicht gruppierten Indizes über mehrere Dateigruppen hinweg in Betracht ziehen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-245">You can also consider partitioning clustered and nonclustered indexes across multiple filegroups.</span></span> <span data-ttu-id="bcdf2-246">Partitionierte Indizes werden horizontal oder nach Zeile basierend auf einer Partitionsfunktion partitioniert.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-246">Partitioned indexes are partitioned horizontally, or by row, based on a partition function.</span></span> <span data-ttu-id="bcdf2-247">Die Partitionsfunktion definiert, wie jede einzelne Zeile einer Gruppe von Partitionen auf der Grundlage der Werte bestimmter Spalten zugeordnet wird, die als Partitionierungsspalten bezeichnet werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-247">The partition function defines how each row is mapped to a set of partitions based on the values of certain columns, called partitioning columns.</span></span> <span data-ttu-id="bcdf2-248">Ein Partitionsschema gibt die Zuordnung dieser Partitionen zu einer Sammlung von Dateigruppen an.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-248">A partition scheme specifies the mapping of the partitions to a set of filegroups.</span></span>  
  
 <span data-ttu-id="bcdf2-249">Das Partitionieren eines Indexes kann die folgenden Vorteile bieten:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-249">Partitioning an index can provide the following benefits:</span></span>  
  
-   <span data-ttu-id="bcdf2-250">Bereitstellen skalierbarer Systeme, die die Verwaltbarkeit großer Indizes vereinfachen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-250">Provide scalable systems that make large indexes more manageable.</span></span> <span data-ttu-id="bcdf2-251">OLTP-Systeme können z. B. partitionsabhängige Anwendungen implementieren, die große Indizes verwalten können.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-251">OLTP systems, for example, can implement partition-aware applications that deal with large indexes.</span></span>  
  
-   <span data-ttu-id="bcdf2-252">Schnellere und effizientere Ausführung von Abfragen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-252">Make queries run faster and more efficiently.</span></span> <span data-ttu-id="bcdf2-253">Wenn Abfragen auf mehrere Partitionen eines Indexes zugreifen, kann der Abfrageoptimierer einzelne Partitionen gleichzeitig verarbeiten und Partitionen ausschließen, die nicht von der Abfrage betroffen sind.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-253">When queries access several partitions of an index, the query optimizer can process individual partitions at the same time and exclude partitions that are not affected by the query.</span></span>  
  
 <span data-ttu-id="bcdf2-254">Weitere Informationen finden Sie unter [partitionierte Tabellen und Indizes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="bcdf2-254">For more information, see [Partitioned Tables and Indexes](../relational-databases/partitions/partitioned-tables-and-indexes.md).</span></span>  
  
###  <a name="index-sort-order-design-guidelines"></a><a name="Sort_Order"></a> <span data-ttu-id="bcdf2-255">Entwurfsrichtlinien zur Sortierreihenfolge von Indizes</span><span class="sxs-lookup"><span data-stu-id="bcdf2-255">Index Sort Order Design Guidelines</span></span>  

 <span data-ttu-id="bcdf2-256">Beim Definieren von Indizes sollten Sie berücksichtigen, ob die Daten für die Indexschlüsselspalte in aufsteigender oder absteigender Reihenfolge gespeichert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-256">When defining indexes, you should consider whether the data for the index key column should be stored in ascending or descending order.</span></span> <span data-ttu-id="bcdf2-257">Die Standardreihenfolge ist aufsteigend. Hierbei wird auch die Kompatibilität mit früheren Versionen von [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]beibehalten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-257">Ascending is the default and maintains compatibility with earlier versions of [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="bcdf2-258">Die Syntax der CREATE INDEX-, CREATE TABLE- und ALTER TABLE-Anweisungen unterstützt die Schüsselwörter ASC (aufsteigend) und DESC (absteigend) für einzelne Spalten in Indizes und Einschränkungen:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-258">The syntax of the CREATE INDEX, CREATE TABLE, and ALTER TABLE statements supports the keywords ASC (ascending) and DESC (descending) on individual columns in indexes and constraints.</span></span>  
  
 <span data-ttu-id="bcdf2-259">Das Angeben der Reihenfolge, in der die Schlüsselwerte in einem Index gespeichert werden, ist sinnvoll, wenn Abfragen, die auf die Tabelle verweisen, über ORDER BY-Klauseln verfügen, die verschiedene Richtungen für die Schlüsselspalten in dem entsprechenden Index angeben.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-259">Specifying the order in which key values are stored in an index is useful when queries referencing the table have ORDER BY clauses that specify different directions for the key column or columns in that index.</span></span> <span data-ttu-id="bcdf2-260">In diesen Fällen kann der Index dafür sorgen, dass kein SORT-Operator mehr im Abfrageplan benötigt wird, wodurch die Abfrage effizienter wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-260">In these cases, the index can remove the need for a SORT operator in the query plan; therefore, this makes the query more efficient.</span></span> <span data-ttu-id="bcdf2-261">Die Mitarbeiter der Einkaufsabteilung von [!INCLUDE[ssSampleDBCoFull](../includes/sssampledbcofull-md.md)] müssen beispielsweise die Qualität der Produkte, die sie von den Anbietern kaufen, bewerten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-261">For example, the buyers in the [!INCLUDE[ssSampleDBCoFull](../includes/sssampledbcofull-md.md)] purchasing department have to evaluate the quality of products they purchase from vendors.</span></span> <span data-ttu-id="bcdf2-262">Die Einkäufer sind vor allem interessiert daran, Produkte zu finden, die von diesen Anbietern gesendet wurden und die eine hohe Ablehnungsrate aufweisen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-262">The buyers are most interested in finding products sent by these vendors with a high rejection rate.</span></span> <span data-ttu-id="bcdf2-263">Wie in der folgenden Abfrage gezeigt, muss zum Abrufen der Daten, die diese Anforderung erfüllen, die `RejectedQty` -Spalte in der `Purchasing.PurchaseOrderDetail` -Tabelle in absteigender Reihenfolge (von groß nach klein) sortiert werden, und die `ProductID` -Spalte muss in aufsteigender Reihenfolge (von klein nach groß) sortiert werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-263">As shown in the following query, retrieving the data to meet this criteria requires the `RejectedQty` column in the `Purchasing.PurchaseOrderDetail` table to be sorted in descending order (large to small) and the `ProductID` column to be sorted in ascending order (small to large).</span></span>  
  
```sql
SELECT RejectedQty, ((RejectedQty/OrderQty)*100) AS RejectionRate,  
    ProductID, DueDate  
FROM Purchasing.PurchaseOrderDetail  
ORDER BY RejectedQty DESC, ProductID ASC;  
```  
  
 <span data-ttu-id="bcdf2-264">Der folgende Ausführungsplan für diese Abfrage zeigt, dass der Abfrageoptimierer einen SORT-Operator verwendet hat, um das Resultset in der durch die ORDER BY-Klausel angegebenen Reihenfolge zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-264">The following execution plan for this query shows that the query optimizer used a SORT operator to return the result set in the order specified by the ORDER BY clause.</span></span>  
  
 <span data-ttu-id="bcdf2-265">![Ausführungsplan zeigt, dass ein SORT-Operator verwendet wird](media/indexsort1.gif "Ausführungsplan zeigt, dass ein SORT-Operator verwendet wird")</span><span class="sxs-lookup"><span data-stu-id="bcdf2-265">![Execution plan shows a SORT operator is used.](media/indexsort1.gif "Execution plan shows a SORT operator is used.")</span></span>  
  
 <span data-ttu-id="bcdf2-266">Falls ein Index mit Schlüsselspalten erstellt wird, die mit jenen in der ORDER BY-Klausel in der Abfrage übereinstimmen, kann der SORT-Operator im Abfrageplan gelöscht werden, wodurch der Abfrageplan effizienter wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-266">If an index is created with key columns that match those in the ORDER BY clause in the query, the SORT operator can be eliminated in the query plan and the query plan is more efficient.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX IX_PurchaseOrderDetail_RejectedQty  
ON Purchasing.PurchaseOrderDetail  
    (RejectedQty DESC, ProductID ASC, DueDate, OrderQty);  
```  
  
 <span data-ttu-id="bcdf2-267">Nachdem die Abfrage erneut ausgeführt wurde, zeigt folgender Ausführungsplan, dass der SORT-Operator gelöscht wurde und der neu erstellte nicht gruppierte Index verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-267">After the query is executed again, the following execution plan shows that the SORT operator has been eliminated and the newly created nonclustered index is used.</span></span>  
  
 <span data-ttu-id="bcdf2-268">![Ausführungsplan zeigt, dass kein SORT-Operator verwendet wird](media/insertsort2.gif "Ausführungsplan zeigt, dass kein SORT-Operator verwendet wird")</span><span class="sxs-lookup"><span data-stu-id="bcdf2-268">![Execution plan shows a SORT operator is not used](media/insertsort2.gif "Execution plan shows a SORT operator is not used")</span></span>  
  
 <span data-ttu-id="bcdf2-269">[!INCLUDE[ssDE](../includes/ssde-md.md)] bewegt sich in beide Richtungen gleichermaßen effizient.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-269">The [!INCLUDE[ssDE](../includes/ssde-md.md)] can move equally efficiently in either direction.</span></span> <span data-ttu-id="bcdf2-270">Ein als `(RejectedQty DESC, ProductID ASC)` definierter Index kann nach wie vor für eine Abfrage verwendet werden, in der die Sortierreihenfolge der Spalten in der ORDER BY-Klausel reserviert sind.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-270">An index defined as `(RejectedQty DESC, ProductID ASC)` can still be used for a query in which the sort direction of the columns in the ORDER BY clause are reversed.</span></span> <span data-ttu-id="bcdf2-271">Eine Abfrage mit der ORDER BY-Klausel `ORDER BY RejectedQty ASC, ProductID DESC` kann den Index beispielsweise verwenden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-271">For example, a query with the ORDER BY clause `ORDER BY RejectedQty ASC, ProductID DESC` can use the index.</span></span>  
  
 <span data-ttu-id="bcdf2-272">Die Sortierreihenfolge kann nur für Schlüsselspalten angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-272">Sort order can be specified only for key columns.</span></span> <span data-ttu-id="bcdf2-273">Die Katalogsicht [sys.index_columns](/sql/relational-databases/system-catalog-views/sys-indexes-transact-sql) und die INDEXKEY_PROPERTY-Funktion melden, ob eine Indexspalte in aufsteigender oder absteigender Reihenfolge gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-273">The [sys.index_columns](/sql/relational-databases/system-catalog-views/sys-indexes-transact-sql) catalog view and the INDEXKEY_PROPERTY function report whether an index column is stored in ascending or descending order.</span></span>  
  
 <span data-ttu-id="bcdf2-274">![Pfeilsymbol mit dem Link "zurück zum Anfang](media/uparrow16x16.gif "Pfeilsymbol, das mit dem Link „Zurück zum Anfang“ verwendet wird") " [in diesem Handbuch](#Top)</span><span class="sxs-lookup"><span data-stu-id="bcdf2-274">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="clustered-index-design-guidelines"></a><a name="Clustered"></a> <span data-ttu-id="bcdf2-275">Richtlinien für den Entwurf gruppierter Indizes</span><span class="sxs-lookup"><span data-stu-id="bcdf2-275">Clustered Index Design Guidelines</span></span>  

 <span data-ttu-id="bcdf2-276">Gruppierte Indizes sortieren und speichern die Datenzeilen in den Tabellen basierend auf ihren Schlüsselwerten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-276">Clustered indexes sort and store the data rows in the table based on their key values.</span></span> <span data-ttu-id="bcdf2-277">Pro Tabelle kann nur ein gruppierter Index vorhanden sein, da die Datenzeilen nur in einer Reihenfolge sortiert werden können.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-277">There can only be one clustered index per table, because the data rows themselves can only be sorted in one order.</span></span> <span data-ttu-id="bcdf2-278">Mit wenigen Ausnahmen sollte für jede Tabelle ein gruppierter Index für die Spalte(n) definiert werden, auf die Folgendes zutrifft:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-278">With few exceptions, every table should have a clustered index defined on the column, or columns, that offer the following:</span></span>  
  
-   <span data-ttu-id="bcdf2-279">Sie kann für häufig verwendete Abfragen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-279">Can be used for frequently used queries.</span></span>  
  
-   <span data-ttu-id="bcdf2-280">Sie stellt einen hohen Grad an Eindeutigkeit bereit.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-280">Provide a high degree of uniqueness.</span></span>  
  
    > [!NOTE]  
    >  <span data-ttu-id="bcdf2-281">Wenn Sie eine PRIMARY KEY-Einschränkung erstellen, wird automatisch ein eindeutiger Index für die Spalte(n) erstellt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-281">When you create a PRIMARY KEY constraint, a unique index on the column, or columns, is automatically created.</span></span> <span data-ttu-id="bcdf2-282">Standardmäßig ist dieser Index gruppiert; Sie können jedoch auch einen nicht gruppierten Index angeben, wenn Sie die Einschränkung erstellen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-282">By default, this index is clustered; however, you can specify a nonclustered index when you create the constraint.</span></span>  
  
-   <span data-ttu-id="bcdf2-283">Sie kann in Bereichsabfragen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-283">Can be used in range queries.</span></span>  
  
 <span data-ttu-id="bcdf2-284">Wenn der gruppierte Index nicht mit der Unique-Eigenschaft erstellt wird, [!INCLUDE[ssDE](../includes/ssde-md.md)] Fügt der Tabelle automatisch eine 4-Byte-Spalte vom Typ uniquifier hinzu.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-284">If the clustered index is not created with the UNIQUE property, the [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically adds a 4-byte uniquifier column to the table.</span></span> <span data-ttu-id="bcdf2-285">Wenn dies erforderlich ist, [!INCLUDE[ssDE](../includes/ssde-md.md)] Fügt der eine Zeile automatisch einen uniquifier-Wert hinzu, um jeden Schlüssel eindeutig zu machen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-285">When it is required, the [!INCLUDE[ssDE](../includes/ssde-md.md)] automatically adds a uniquifier value to a row to make each key unique.</span></span> <span data-ttu-id="bcdf2-286">Diese Spalte und ihre Werte werden intern verwendet und können durch Benutzer nicht angezeigt werden. Der Zugriff durch Benutzer auf diese ist ebenfalls nicht möglich.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-286">This column and its values are used internally and cannot be seen or accessed by users.</span></span>  
  
### <a name="clustered-index-architecture"></a><span data-ttu-id="bcdf2-287">Architektur gruppierter Indizes</span><span class="sxs-lookup"><span data-stu-id="bcdf2-287">Clustered Index Architecture</span></span>  

 <span data-ttu-id="bcdf2-288">In [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]sind Indizes in Form von B-Strukturen aufgebaut.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-288">In [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)], indexes are organized as B-trees.</span></span> <span data-ttu-id="bcdf2-289">Jede Seite in der B-Struktur eines Indexes wird als Indexknoten bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-289">Each page in an index B-tree is called an index node.</span></span> <span data-ttu-id="bcdf2-290">Der oberste Knoten der B-Struktur wird als Stammknoten bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-290">The top node of the B-tree is called the root node.</span></span> <span data-ttu-id="bcdf2-291">Die unteren Knoten im Index werden als Blattknoten bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-291">The bottom nodes in the index are called the leaf nodes.</span></span> <span data-ttu-id="bcdf2-292">Alle anderen Indexebenen zwischen dem Stamm- und den Blattknoten werden zusammenfassend als Zwischenebenen bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-292">Any index levels between the root and the leaf nodes are collectively known as intermediate levels.</span></span> <span data-ttu-id="bcdf2-293">In einem gruppierten Index enthalten die Blattknoten die Datenseiten der zugrunde liegenden Tabelle.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-293">In a clustered index, the leaf nodes contain the data pages of the underlying table.</span></span> <span data-ttu-id="bcdf2-294">Die Stamm- und Zwischenebenenknoten enthalten Indexseiten, in denen Indexzeilen enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-294">The root and intermediate level nodes contain index pages holding index rows.</span></span> <span data-ttu-id="bcdf2-295">Jede Indexzeile enthält einen Schlüsselwert und einen Zeiger auf eine Seite einer Zwischenebene in der B-Struktur oder auf eine Datenzeile in der Blattebene des Indexes.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-295">Each index row contains a key value and a pointer to either an intermediate level page in the B-tree, or a data row in the leaf level of the index.</span></span> <span data-ttu-id="bcdf2-296">Die Seiten auf jeder Ebene des Indexes sind durch eine doppelt verknüpfte Liste miteinander verknüpft.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-296">The pages in each level of the index are linked in a doubly-linked list.</span></span>  
  
 <span data-ttu-id="bcdf2-297">Gruppierte Indizes besitzen eine Zeile in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql), wobei **index_id** = 1 für jede Partition, die vom Index verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-297">Clustered indexes have one row in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql), with **index_id** = 1 for each partition used by the index.</span></span> <span data-ttu-id="bcdf2-298">Standardmäßig besitzt ein gruppierter Index eine Partition.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-298">By default, a clustered index has a single partition.</span></span> <span data-ttu-id="bcdf2-299">Wenn ein gruppierter Index über mehrere Partitionen verfügt, besitzt jede Partition eine B-Struktur, die die Daten für diese bestimmte Partition enthält.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-299">When a clustered index has multiple partitions, each partition has a B-tree structure that contains the data for that specific partition.</span></span> <span data-ttu-id="bcdf2-300">Wenn ein gruppierter Index z. B. vier Partitionen besitzt, sind vier B-Strukturen vorhanden, eine in jeder Partition.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-300">For example, if a clustered index has four partitions, there are four B-tree structures; one in each partition.</span></span>  
  
 <span data-ttu-id="bcdf2-301">Abhängig von den Datentypen im gruppierten Index weist jede gruppierte Indexstruktur eine oder mehrere Zuordnungseinheiten auf, in denen die Daten für eine bestimmte Partition gespeichert und verwaltet werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-301">Depending on the data types in the clustered index, each clustered index structure will have one or more allocation units in which to store and manage the data for a specific partition.</span></span> <span data-ttu-id="bcdf2-302">Jeder gruppierte Index weist mindestens eine IN_ROW_DATA-Zuordnungseinheit pro Partition auf.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-302">At a minimum, each clustered index will have one IN_ROW_DATA allocation unit per partition.</span></span> <span data-ttu-id="bcdf2-303">Der gruppierte Index besitzt außerdem eine LOB_DATA-Zuordnungseinheit pro Partition, wenn LOB-Spalten (Large Object) vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-303">The clustered index will also have one LOB_DATA allocation unit per partition if it contains large object (LOB) columns.</span></span> <span data-ttu-id="bcdf2-304">Außerdem ist eine ROW_OVERFLOW_DATA-Zuordnungseinheit pro Partition vorhanden, wenn der Index Spalten variabler Länge aufweist, die die Zeilengrößenbegrenzung von 8.060 Byte übersteigen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-304">It will also have one ROW_OVERFLOW_DATA allocation unit per partition if it contains variable length columns that exceed the 8,060 byte row size limit.</span></span>  
  
 <span data-ttu-id="bcdf2-305">Die Seiten in der Datenkette und die darin enthaltenen Zeilen werden anhand des Werts des Schlüssels des gruppierten Indexes angeordnet.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-305">The pages in the data chain and the rows in them are ordered on the value of the clustered index key.</span></span> <span data-ttu-id="bcdf2-306">Jede Einfügung wird an der Position vorgenommen, die der Schlüsselwert der eingefügten Zeile in der Reihenfolge vorhandener Zeilen einnimmt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-306">All inserts are made at the point where the key value in the inserted row fits in the ordering sequence among existing rows.</span></span>  
  
 <span data-ttu-id="bcdf2-307">Die folgende Abbildung veranschaulicht die Struktur eines gruppierten Indexes in einer einzelnen Partition.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-307">This illustration shows the structure of a clustered index in a single partition.</span></span>  
  
 <span data-ttu-id="bcdf2-308">![Ebenen eines gruppierten Index](media/bokind2.gif "Ebenen eines gruppierten Index")</span><span class="sxs-lookup"><span data-stu-id="bcdf2-308">![Levels of a clustered index](media/bokind2.gif "Levels of a clustered index")</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="bcdf2-309">Überlegungen zu Abfragen</span><span class="sxs-lookup"><span data-stu-id="bcdf2-309">Query Considerations</span></span>  

 <span data-ttu-id="bcdf2-310">Bevor Sie gruppierte Indizes erstellen, sollten Sie sich überlegen, wie der Zugriff auf die Daten erfolgt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-310">Before you create clustered indexes, understand how your data will be accessed.</span></span> <span data-ttu-id="bcdf2-311">Einen gruppierten Index können Sie für Abfragen verwenden, die die folgenden Aktionen durchführen:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-311">Consider using a clustered index for queries that do the following:</span></span>  
  
-   <span data-ttu-id="bcdf2-312">Zurückgeben eines Wertebereichs, indem z. B. folgende Operatoren verwendet werden: BETWEEN, >, >=, < und <=.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-312">Return a range of values by using operators such as BETWEEN, >, >=, <, and <=.</span></span>  
  
     <span data-ttu-id="bcdf2-313">Sobald mithilfe des gruppierten Indexes die Zeile mit dem ersten Wert gefunden wird, ist sichergestellt, dass Zeilen mit nachfolgenden Indexwerten physisch benachbart sind.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-313">After the row with the first value is found by using the clustered index, rows with subsequent indexed values are guaranteed to be physically adjacent.</span></span> <span data-ttu-id="bcdf2-314">Wenn mit einer Abfrage z. B. Datensätze aus einem Bereich von Verkaufsauftragsnummern abgerufen werden, bietet ein gruppierter Index für die `SalesOrderNumber` -Spalte die Möglichkeit, schnell die Zeile zu finden, die die Start-Verkaufsauftragsnummer enthält, und dann alle nachfolgenden Zeilen in der Tabelle abzurufen, bis die letzte Verkaufsauftragsnummer erreicht ist.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-314">For example, if a query retrieves records between a range of sales order numbers, a clustered index on the column `SalesOrderNumber` can quickly locate the row that contains the starting sales order number, and then retrieve all successive rows in the table until the last sales order number is reached.</span></span>  
  
-   <span data-ttu-id="bcdf2-315">Zurückgeben umfangreicher Resultsets.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-315">Return large result sets.</span></span>  
  
-   <span data-ttu-id="bcdf2-316">Verwenden von JOIN-Klauseln; in der Regel handelt es sich dabei um Fremdschlüsselspalten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-316">Use JOIN clauses; typically these are foreign key columns.</span></span>  
  
-   <span data-ttu-id="bcdf2-317">Verwenden von ORDER BY- oder GROUP BY-Klauseln.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-317">Use ORDER BY, or GROUP BY clauses.</span></span>  
  
     <span data-ttu-id="bcdf2-318">Durch einen Index für Spalten, die in der ORDER BY- oder GROUP BY-Klausel angegeben werden, entfällt ggf. die Notwendigkeit für [!INCLUDE[ssDE](../includes/ssde-md.md)] , die Daten zu sortieren, da die Zeilen bereits sortiert sind.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-318">An index on the columns specified in the ORDER BY or GROUP BY clause may remove the need for the [!INCLUDE[ssDE](../includes/ssde-md.md)] to sort the data, because the rows are already sorted.</span></span> <span data-ttu-id="bcdf2-319">Die Abfrageleistung wird somit verbessert.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-319">This improves query performance.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="bcdf2-320">Überlegungen zu Spalten</span><span class="sxs-lookup"><span data-stu-id="bcdf2-320">Column Considerations</span></span>  

 <span data-ttu-id="bcdf2-321">Die Definition des gruppierten Indexschlüssels sollte im Allgemeinen so wenig Spalten wie möglich umfassen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-321">Generally, you should define the clustered index key with as few columns as possible.</span></span> <span data-ttu-id="bcdf2-322">Ziehen Sie Spalten in Betracht, auf die ein oder mehrere der folgenden Merkmale zutreffen:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-322">Consider columns that have one or more of the following attributes:</span></span>  
  
-   <span data-ttu-id="bcdf2-323">Sie sind eindeutig oder enthalten zahlreiche unterschiedliche Werte.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-323">Are unique or contain many distinct values</span></span>  
  
     <span data-ttu-id="bcdf2-324">Eine Mitarbeiter-ID identifiziert einen Mitarbeiter z. B. eindeutig.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-324">For example, an employee ID uniquely identifies employees.</span></span> <span data-ttu-id="bcdf2-325">Ein gruppierter Index oder eine PRIMARY KEY-Einschränkung für die `EmployeeID` -Spalte verbessert die Leistung von Abfragen, durch die Mitarbeiterinformationen anhand der Mitarbeiter-ID gesucht werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-325">A clustered index or PRIMARY KEY constraint on the `EmployeeID` column would improve the performance of queries that search for employee information based on the employee ID number.</span></span> <span data-ttu-id="bcdf2-326">Alternativ kann ein gruppierter Index für `LastName`, `FirstName`und `MiddleName` erstellt werden, weil Mitarbeiterdatensätze häufig auf diese Weise gruppiert und abgefragt werden und die Kombination dieser Spalten jedoch trotzdem einen hohen Differenzierungsgrad bietet.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-326">Alternatively, a clustered index could be created on `LastName`, `FirstName`, `MiddleName` because employee records are frequently grouped and queried in this way, and the combination of these columns would still provide a high degree of difference.</span></span>  
  
-   <span data-ttu-id="bcdf2-327">Der Zugriff auf sie erfolgt sequenziell.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-327">Are accessed sequentially</span></span>  
  
     <span data-ttu-id="bcdf2-328">Durch eine Produkt-ID werden Produkte in der `Production.Product` -Tabelle der [!INCLUDE[ssSampleDBobject](../includes/sssampledbobject-md.md)] -Datenbank beispielsweise eindeutig identifiziert.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-328">For example, a product ID uniquely identifies products in the `Production.Product` table in the [!INCLUDE[ssSampleDBobject](../includes/sssampledbobject-md.md)] database.</span></span> <span data-ttu-id="bcdf2-329">Abfragen, in denen eine sequenzielle Suche angegeben wird, z. B. `WHERE ProductID BETWEEN 980 and 999`, profitieren von einem gruppierten Index für `ProductID`.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-329">Queries in which a sequential search is specified, such as `WHERE ProductID BETWEEN 980 and 999`, would benefit from a clustered index on `ProductID`.</span></span> <span data-ttu-id="bcdf2-330">Die Ursache liegt darin, dass die Zeilen für diese Schlüsselspalte in sortierter Reihenfolge gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-330">This is because the rows would be stored in sorted order on that key column.</span></span>  
  
-   <span data-ttu-id="bcdf2-331">Definiert als IDENTITY.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-331">Defined as IDENTITY.</span></span>  
  
-   <span data-ttu-id="bcdf2-332">Sie wird häufig verwendet, um die aus einer Tabelle abgerufenen Daten zu sortieren.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-332">Used frequently to sort the data retrieved from a table.</span></span>  
  
     <span data-ttu-id="bcdf2-333">Es kann sinnvoll sein, die Tabelle für die betreffende Spalte zu gruppieren (d. h., physisch zu sortieren), damit nicht bei jeder Abfrage der Spalte Kosten für einen Sortiervorgang entstehen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-333">It can be a good idea to cluster, that is physically sort, the table on that column to save the cost of a sort operation every time the column is queried.</span></span>  
  
 <span data-ttu-id="bcdf2-334">Die Verwendung eines gruppierten Indexes ist nicht empfehlenswert, wenn die Spalten die folgenden Merkmale aufweisen:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-334">Clustered indexes are not a good choice for the following attributes:</span></span>  
  
-   <span data-ttu-id="bcdf2-335">Spalten, die häufig geändert werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-335">Columns that undergo frequent changes</span></span>  
  
     <span data-ttu-id="bcdf2-336">Dies bewirkt, dass die gesamte Zeile verschoben wird, da die [!INCLUDE[ssDE](../includes/ssde-md.md)] Datenwerte einer Zeile in physischer Reihenfolge beibehalten muss.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-336">This causes the whole row to move, because the [!INCLUDE[ssDE](../includes/ssde-md.md)] must keep the data values of a row in physical order.</span></span> <span data-ttu-id="bcdf2-337">Dieser Aspekt sollte insbesondere bei Systemen berücksichtigt werden, in denen Transaktionsverarbeitung in großem Umfang erfolgt und Daten nur selten von Dauer sind.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-337">This is an important consideration in high-volume transaction processing systems in which data is typically volatile.</span></span>  
  
-   <span data-ttu-id="bcdf2-338">Ausführliche Schlüssel.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-338">Wide keys</span></span>  
  
     <span data-ttu-id="bcdf2-339">Ausführliche Schlüssel sind aus mehreren Spalten oder mehreren großen Spalten zusammengesetzt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-339">Wide keys are a composite of several columns or several large-size columns.</span></span> <span data-ttu-id="bcdf2-340">Die Schlüsselwerte aus dem gruppierten Index werden von allen nicht gruppierten Indizes als Suchschlüssel verwendet.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-340">The key values from the clustered index are used by all nonclustered indexes as lookup keys.</span></span> <span data-ttu-id="bcdf2-341">Alle nicht gruppierten Indizes, die für dieselbe Tabelle definiert werden, sind erheblich größer, da die Einträge des nicht gruppierten Indexes den Gruppierungsschlüssel sowie die Schlüsselspalten enthalten, die für diesen nicht gruppierten Index definiert wurden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-341">Any nonclustered indexes defined on the same table will be significantly larger because the nonclustered index entries contain the clustering key and also the key columns defined for that nonclustered index.</span></span>  
  
 <span data-ttu-id="bcdf2-342">![Pfeilsymbol mit dem Link "zurück zum Anfang](media/uparrow16x16.gif "Pfeilsymbol, das mit dem Link „Zurück zum Anfang“ verwendet wird") " [in diesem Handbuch](#Top)</span><span class="sxs-lookup"><span data-stu-id="bcdf2-342">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="nonclustered-index-design-guidelines"></a><a name="Nonclustered"></a> <span data-ttu-id="bcdf2-343">Entwurfsrichtlinien für einen nicht gruppierten Index</span><span class="sxs-lookup"><span data-stu-id="bcdf2-343">Nonclustered Index Design Guidelines</span></span>  

 <span data-ttu-id="bcdf2-344">Ein nicht gruppierter Index enthält Indexschlüsselwerte sowie Zeilenlokatoren, die auf den Speicherort der Tabellendaten verweisen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-344">A nonclustered index contains the index key values and row locators that point to the storage location of the table data.</span></span> <span data-ttu-id="bcdf2-345">Sie können mehrere nicht gruppierte Indizes für eine Tabelle oder eine indizierte Sicht erstellen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-345">You can create multiple nonclustered indexes on a table or indexed view.</span></span> <span data-ttu-id="bcdf2-346">Im Allgemeinen sollten nicht gruppierte Indizes so entworfen werden, dass sich die Leistung häufig verwendeter Abfragen verbessert, die nicht vom gruppierten Index abgedeckt werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-346">Generally, nonclustered indexes should be designed to improve the performance of frequently used queries that are not covered by the clustered index.</span></span>  
  
 <span data-ttu-id="bcdf2-347">Vergleichbar mit der Art und Weise wie Sie einen Index in einem Buch verwenden, sucht der Abfrageoptimierer nach einem Datenwert, indem er den nicht gruppierten Index durchsucht, um so den Speicherort des Datenwerts in der Tabelle zu ermitteln. Anschließend werden die Daten direkt von diesem Speicherort abgerufen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-347">Similar to the way you use an index in a book, the query optimizer searches for a data value by searching the nonclustered index to find the location of the data value in the table and then retrieves the data directly from that location.</span></span> <span data-ttu-id="bcdf2-348">Aus diesem Grund sind nicht gruppierte Indizes optimal für Abfragen geeignet, die nach genauen Übereinstimmungen suchen, da der Index Einträge enthält, die in der Tabelle den genauen Speicherort der Datenwerte beschreiben, die in den Abfragen gesucht werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-348">This makes nonclustered indexes the optimal choice for exact match queries because the index contains entries describing the exact location in the table of the data values being searched for in the queries.</span></span> <span data-ttu-id="bcdf2-349">Wenn beispielsweise die `HumanResources. Employee` -Tabelle nach sämtlichen Mitarbeitern abgefragt werden soll, die einem bestimmten Abteilungsleiter unterstehen, verwendet der Abfrageoptimierer möglicherweise den nicht gruppierten Index `IX_Employee_ManagerID`; hier ist `ManagerID` die Schlüsselspalte.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-349">For example, to query the `HumanResources. Employee` table for all employees that report to a specific manager, the query optimizer might use the nonclustered index `IX_Employee_ManagerID`; this has `ManagerID` as its key column.</span></span> <span data-ttu-id="bcdf2-350">Der Abfrageoptimierer kann schnell alle Einträge im Index finden, die mit der angegebenen `ManagerID`übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-350">The query optimizer can quickly find all entries in the index that match the specified `ManagerID`.</span></span> <span data-ttu-id="bcdf2-351">Jeder Indexeinträg verweist auf die genaue Seite und Zeile in der Tabelle bzw. im gruppierten Index, in der die entsprechenden Daten zu finden sind.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-351">Each index entry points to the exact page and row in the table, or clustered index, in which the corresponding data can be found.</span></span> <span data-ttu-id="bcdf2-352">Nachdem der Abfrageoptimierer sämtliche Einträge im Index gefunden hat, kann er sich direkt zu der genauen Seite und Zeile begeben, um die Daten abzurufen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-352">After the query optimizer finds all entries in the index, it can go directly to the exact page and row to retrieve the data.</span></span>  
  
### <a name="nonclustered-index-architecture"></a><span data-ttu-id="bcdf2-353">Architektur nicht gruppierter Indizes</span><span class="sxs-lookup"><span data-stu-id="bcdf2-353">Nonclustered Index Architecture</span></span>  

 <span data-ttu-id="bcdf2-354">Nicht gruppierte Indizes weisen dieselbe B-Baumstruktur auf wie gruppierte Indizes, mit Ausnahme der beiden folgenden signifikanten Unterschiede:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-354">Nonclustered indexes have the same B-tree structure as clustered indexes, except for the following significant differences:</span></span>  
  
-   <span data-ttu-id="bcdf2-355">Die Datenzeilen der zugrunde liegenden Tabelle werden nicht auf der Grundlage ihrer nicht gruppierten Schlüssel sortiert und gespeichert.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-355">The data rows of the underlying table are not sorted and stored in order based on their nonclustered keys.</span></span>  
  
-   <span data-ttu-id="bcdf2-356">Die Blattebene eines nicht gruppierten Indexes besteht aus Indexseiten, nicht aus Datenseiten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-356">The leaf layer of a nonclustered index is made up of index pages instead of data pages.</span></span>  
  
 <span data-ttu-id="bcdf2-357">Zeilenlokatoren in nicht gruppierten Indexzeilen bestehen entweder aus Zeigern, die auf jeweils eine Zeile zeigen, oder aus einem Schlüssel eines gruppierten Indexes für eine Zeile, wie im Folgenden erläutert:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-357">The row locators in nonclustered index rows are either a pointer to a row or are a clustered index key for a row, as described in the following:</span></span>  
  
-   <span data-ttu-id="bcdf2-358">Wenn es sich bei der Tabelle um einen Heap handelt (d. h. sie hat keinen gruppierten Index), entspricht der Zeilenlokator einem Zeiger auf die Zeile.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-358">If the table is a heap, which means it does not have a clustered index, the row locator is a pointer to the row.</span></span> <span data-ttu-id="bcdf2-359">Der Zeiger setzt sich aus dem Dateibezeichner (ID), der Seitennummer und der Nummer der Zeile auf der Seite zusammen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-359">The pointer is built from the file identifier (ID), page number, and number of the row on the page.</span></span> <span data-ttu-id="bcdf2-360">Der ganze Zeiger wird als Zeilen-ID (RID) bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-360">The whole pointer is known as a Row ID (RID).</span></span>  
  
-   <span data-ttu-id="bcdf2-361">Wenn die Tabelle einen gruppierten Index besitzt oder der Index für eine indizierte Sicht erstellt wurde, ist der Zeilenlokator der Schlüssel des gruppierten Indexes für die Zeile.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-361">If the table has a clustered index, or the index is on an indexed view, the row locator is the clustered index key for the row.</span></span>  
  
 <span data-ttu-id="bcdf2-362">Nicht gruppierte Indizes verfügen in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql) für jede vom Index verwendete Partition über eine Zeile, deren **index_id** >1 ist.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-362">Nonclustered indexes have one row in [sys.partitions](/sql/relational-databases/system-catalog-views/sys-partitions-transact-sql) with **index_id** >1 for each partition used by the index.</span></span> <span data-ttu-id="bcdf2-363">Standardmäßig besitzen nicht gruppierte Indizes nur eine Partition.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-363">By default, a nonclustered index has a single partition.</span></span> <span data-ttu-id="bcdf2-364">Wenn ein nicht gruppierter Index mehrere Partitionen besitzt, weist jede Partition eine B-Baumstruktur auf, die die Indexzeilen der entsprechenden Partition enthält.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-364">When a nonclustered index has multiple partitions, each partition has a B-tree structure that contains the index rows for that specific partition.</span></span> <span data-ttu-id="bcdf2-365">Wenn ein nicht gruppierter Index beispielsweise vier Partitionen besitzt, gibt es vier B-Baumstrukturen – jeweils eine in jeder Partition.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-365">For example, if a nonclustered index has four partitions, there are four B-tree structures, with one in each partition.</span></span>  
  
 <span data-ttu-id="bcdf2-366">Abhängig von den Datentypen des nicht gruppierten Indexes erhält jede Struktur mindestens eine Zuordnungseinheit, in der die Daten einer bestimmten Partition gespeichert und verwaltet werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-366">Depending on the data types in the nonclustered index, each nonclustered index structure will have one or more allocation units in which to store and manage the data for a specific partition.</span></span> <span data-ttu-id="bcdf2-367">Jeder nicht gruppierte Index besitzt also eine IN_ROW_DATA-Zuordnungseinheit pro Partition, die die B-Baumstrukturseiten des Indexes speichert.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-367">At a minimum, each nonclustered index will have one IN_ROW_DATA allocation unit per partition that stores the index B-tree pages.</span></span> <span data-ttu-id="bcdf2-368">Außerdem besitzt der nicht gruppierte Index eine LOB_DATA-Zuordnungseinheit, wenn er LOB-Spalten (Large Object) enthält.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-368">The nonclustered index will also have one LOB_DATA allocation unit per partition if it contains large object (LOB) columns .</span></span> <span data-ttu-id="bcdf2-369">Endlich besitzt er eine ROW_OVERFLOW_DATA-Zuordnungseinheit pro Partition, wenn er Spalten variabler Länge enthält, die das Zeilengrößenlimit von 8.060 Byte überschreiten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-369">Additionally, it will have one ROW_OVERFLOW_DATA allocation unit per partition if it contains variable length columns that exceed the 8,060 byte row size limit.</span></span>  
  
 <span data-ttu-id="bcdf2-370">Die folgende Abbildung veranschaulicht die Struktur eines gruppierten Indexes einer einzigen Partition.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-370">The following illustration shows the structure of a nonclustered index in a single partition.</span></span>  
  
 <span data-ttu-id="bcdf2-371">![Ebenen eines nicht gruppierten Index](media/bokind1.gif "Ebenen eines nicht gruppierten Index")</span><span class="sxs-lookup"><span data-stu-id="bcdf2-371">![Levels of a nonclustered index](media/bokind1.gif "Levels of a nonclustered index")</span></span>  
  
### <a name="database-considerations"></a><span data-ttu-id="bcdf2-372">Überlegungen zu Datenbanken</span><span class="sxs-lookup"><span data-stu-id="bcdf2-372">Database Considerations</span></span>  

 <span data-ttu-id="bcdf2-373">Berücksichtigen Sie beim Entwerfen nicht gruppierter Indizes die Merkmale der jeweiligen Datenbank.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-373">Consider the characteristics of the database when designing nonclustered indexes.</span></span>  
  
-   <span data-ttu-id="bcdf2-374">Datenbanken oder Tabellen mit geringen Updateanforderungen, aber großem Datenvolumen, können von zahlreichen nicht gruppierten Indizes zur Verbesserung der Abfrageleistung profitieren.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-374">Databases or tables with low update requirements, but large volumes of data can benefit from many nonclustered indexes to improve query performance.</span></span> <span data-ttu-id="bcdf2-375">Mit gefilterten Indizes mit klar definierten Teilmengen von Daten können Sie im Vergleich zu nicht gruppierten Tabellenindizes die Abfrageleistung verbessern und den Aufwand für die Indexverwaltung und die Indexspeicherung reduzieren.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-375">Consider creating filtered indexes for well-defined subsets of data to improve query performance, reduce index storage costs, and reduce index maintenance costs compared with full-table nonclustered indexes.</span></span>  
  
     <span data-ttu-id="bcdf2-376">Entscheidungsunterstützungssystem-Anwendungen und -Datenbanken, die hauptsächlich schreibgeschützte Daten enthalten, können von zahlreichen nicht gruppierten Indizes profitieren.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-376">Decision Support System applications and databases that contain primarily read-only data can benefit from many nonclustered indexes.</span></span> <span data-ttu-id="bcdf2-377">Der Abfrageoptimierer hat hinsichtlich des Ermittelns der schnellsten Zugriffsmethode eine größere Auswahl an Indizes, und da die Datenbankmerkmale auf einen geringen Updateaufwand schließen lassen, wird die Leistung durch die Indexwartung nicht beeinträchtigt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-377">The query optimizer has more indexes to choose from to determine the fastest access method, and the low update characteristics of the database mean index maintenance will not impede performance.</span></span>  
  
-   <span data-ttu-id="bcdf2-378">Bei Anwendungen und Datenbanken zur Onlinetransaktionsverarbeitung mit Tabellen, die umfassend aktualisiert werden, sollte ein Übermaß an Indizierung vermieden werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-378">Online Transaction Processing applications and databases that contain heavily updated tables should avoid over-indexing.</span></span> <span data-ttu-id="bcdf2-379">Zusätzlich sollten die Indizes schmal sein, also so wenig Spalten wie möglich enthalten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-379">Additionally, indexes should be narrow, that is, with as few columns as possible.</span></span>  
  
     <span data-ttu-id="bcdf2-380">Eine große Anzahl an Indizes für eine Tabelle beeinträchtigt die Leistung von INSERT-, UPDATE-, DELETE- und MERGE-Anweisungen, da alle Indizes entsprechend angepasst werden müssen, sobald Daten in der Tabelle geändert werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-380">Large numbers of indexes on a table affect the performance of INSERT, UPDATE, DELETE, and MERGE  statements because all indexes must be adjusted appropriately as data in the table changes.</span></span>  
  
### <a name="query-considerations"></a><span data-ttu-id="bcdf2-381">Überlegungen zu Abfragen</span><span class="sxs-lookup"><span data-stu-id="bcdf2-381">Query Considerations</span></span>  

 <span data-ttu-id="bcdf2-382">Bevor Sie nicht gruppierte Indizes erstellen, sollten Sie sich darüber im Klaren sein, wie der Zugriff auf Ihre Daten erfolgt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-382">Before you create nonclustered indexes, you should understand how your data will be accessed.</span></span> <span data-ttu-id="bcdf2-383">Erwägen Sie das Verwenden eines nicht gruppierten Indexes für Abfragen mit folgenden Attributen:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-383">Consider using a nonclustered index for queries that have the following attributes:</span></span>  
  
-   <span data-ttu-id="bcdf2-384">Verwenden von JOIN- oder GROUP BY-Klauseln.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-384">Use JOIN or GROUP BY clauses.</span></span>  
  
     <span data-ttu-id="bcdf2-385">Erstellen Sie mehrere nicht gruppierte Indizes für Spalten, die an Join- und Gruppierungsvorgängen beteiligt sind, sowie einen gruppierten Index für eine beliebige Fremdschlüsselspalte.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-385">Create multiple nonclustered indexes on columns involved in join and grouping operations, and a clustered index on any foreign key columns.</span></span>  
  
-   <span data-ttu-id="bcdf2-386">Kein Zurückgeben großer Resultsets.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-386">Queries that do not return large result sets.</span></span>  
  
     <span data-ttu-id="bcdf2-387">Erstellen Sie gefilterte Indizes für Abfragen, die eine klar definierte Zeilenteilmenge aus einer großen Tabelle zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-387">Create filtered indexes to cover queries that return a well-defined subset of rows from a large table.</span></span>  
  
-   <span data-ttu-id="bcdf2-388">Enthalten von Spalten, die häufig an Suchbedingungen einer Abfrage beteiligt sind (z. B. WHERE-Klausel), die genaue Übereinstimmungen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-388">Contain columns frequently involved in search conditions of a query, such as WHERE clause, that return exact matches.</span></span>  
  
### <a name="column-considerations"></a><span data-ttu-id="bcdf2-389">Überlegungen zu Spalten</span><span class="sxs-lookup"><span data-stu-id="bcdf2-389">Column Considerations</span></span>  

 <span data-ttu-id="bcdf2-390">Ziehen Sie Spalten mit einem oder mehrerer dieser Attribute in Betracht:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-390">Consider columns that have one or more of these attributes:</span></span>  
  
-   <span data-ttu-id="bcdf2-391">Abdecken der Abfrage.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-391">Cover the query.</span></span>  
  
     <span data-ttu-id="bcdf2-392">Leistungsgewinne werden erzielt, wenn der Index alle Spalten in der Abfrage enthält.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-392">Performance gains are achieved when the index contains all columns in the query.</span></span> <span data-ttu-id="bcdf2-393">Der Abfrageoptimierer kann alle Spaltenwerte im Index finden; da auf Daten der Tabelle oder des gruppierten Indexes nicht zugegriffen wird, kommt es zu weniger Datenträger-E/A-Vorgängen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-393">The query optimizer can locate all the column values within the index; table or clustered index data is not accessed resulting in fewer disk I/O operations.</span></span> <span data-ttu-id="bcdf2-394">Verwenden Sie einen Index mit eingeschlossenen Spalten, um mehrere Spalten abzudecken, anstatt einen breiten Indexschlüssel zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-394">Use index with included columns to add covering columns instead of creating a wide index key.</span></span>  
  
     <span data-ttu-id="bcdf2-395">Wenn die Tabelle einen gruppierten Index aufweist, werden die im gruppierten Index definierten Spalten automatisch an das Ende sämtlicher nicht gruppierter Indizes für die Tabelle angefügt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-395">If the table has a clustered index, the column or columns defined in the clustered index are automatically appended to the end of each nonclustered index on the table.</span></span> <span data-ttu-id="bcdf2-396">Auf diese Weise kann eine abgedeckte Abfrage erstellt werden, ohne dass die Spalten des gruppierten Indexes in der Definition des nicht gruppierten Indexes angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-396">This can produce a covered query without specifying the clustered index columns in the definition of the nonclustered index.</span></span> <span data-ttu-id="bcdf2-397">Wenn eine Tabelle beispielsweise einen gruppierten Index für Spalte `C`besitzt, weist ein nicht gruppierter Index für die Spalten `B` und `A` die Schlüsselwertspalten `B`, `A`und `C`auf.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-397">For example, if a table has a clustered index on column `C`, a nonclustered index on columns `B` and `A` will have as its key values columns `B`, `A`, and `C`.</span></span>  
  
-   <span data-ttu-id="bcdf2-398">Große Anzahl unterschiedlicher Werte, beispielsweise eine Kombination aus Nachname und Vorname, wenn für andere Spalten ein gruppierter Index verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-398">Lots of distinct values, such as a combination of last name and first name, if a clustered index is used for other columns.</span></span>  
  
     <span data-ttu-id="bcdf2-399">Wenn nur sehr wenige unterschiedliche Werte vorhanden sind, beispielsweise nur 1 und 0, verwenden die meisten Abfragen den Index nicht, da ein Tabellenscan im Allgemeinen effizienter ist.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-399">If there are very few distinct values, such as only 1 and 0, most queries will not use the index because a table scan is generally more efficient.</span></span> <span data-ttu-id="bcdf2-400">Für diesen Datentyp sollten Sie einen gefilterten Index anhand eines anderen Werts erstellen, der in weniger Zeilen vorkommt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-400">For this type of data, consider creating a filtered index on a distinct value that only occurs in a small number of rows.</span></span> <span data-ttu-id="bcdf2-401">Beispiel: Wenn die meisten Werte 0 sind, kann der Abfrageoptimierer einen gefilterten Index für die Zeilen verwenden, die den Wert 1 enthalten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-401">For example, if most of the values are 0, the query optimizer might use a filtered index for the data rows that contain 1.</span></span>  
  
####  <a name="use-included-columns-to-extend-nonclustered-indexes"></a><a name="Included_Columns"></a> <span data-ttu-id="bcdf2-402">Verwenden eingeschlossener Spalten, um nicht gruppierte Indizes zu erweitern</span><span class="sxs-lookup"><span data-stu-id="bcdf2-402">Use Included Columns to Extend Nonclustered Indexes</span></span>  

 <span data-ttu-id="bcdf2-403">Sie können die Funktionen nicht gruppierter Indizes erweitern, indem Sie der Blattebene des nicht gruppierten Indexes Nichtschlüsselspalten hinzufügen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-403">You can extend the functionality of nonclustered indexes by adding nonkey columns to the leaf level of the nonclustered index.</span></span> <span data-ttu-id="bcdf2-404">Indem Sie Nichtschlüsselspalten einschließen, erstellen Sie nicht gruppierte Indizes, die eine größere Anzahl von Abfragen abdecken.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-404">By including nonkey columns, you can create nonclustered indexes that cover more queries.</span></span> <span data-ttu-id="bcdf2-405">Dies ist der Fall, weil Nichtschlüsselspalten die folgenden Vorteile aufweisen:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-405">This is because the nonkey columns have the following benefits:</span></span>  
  
-   <span data-ttu-id="bcdf2-406">Es kann sich um Datentypen handeln, die als Indexschlüsselspalten nicht zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-406">They can be data types not allowed as index key columns.</span></span>  
  
-   <span data-ttu-id="bcdf2-407">Sie werden von [!INCLUDE[ssDE](../includes/ssde-md.md)] beim Berechnen der Indexschlüsselspalten oder Indexschlüsselgröße nicht berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-407">They are not considered by the [!INCLUDE[ssDE](../includes/ssde-md.md)] when calculating the number of index key columns or index key size.</span></span>  
  
 <span data-ttu-id="bcdf2-408">Ein Index mit eingeschlossenen Nichtschlüsselspalten kann die Abfrageleistung erheblich steigern, wenn alle Spalten in der Abfrage in den Index als Schlüssel- oder Nichtschlüsselspalten eingeschlossen werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-408">An index with included nonkey columns can significantly improve query performance when all columns in the query are included in the index either as key or nonkey columns.</span></span> <span data-ttu-id="bcdf2-409">Leistungsvorteile werden erzielt, weil der Abfrageoptimierer alle Spaltenwerte im Index finden kann; auf Daten der Tabelle oder des gruppierten Indexes wird nicht zugegriffen, sodass als Ergebnis weniger Datenträger-E/A-Vorgänge auftreten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-409">Performance gains are achieved because the query optimizer can locate all the column values within the index; table or clustered index data is not accessed resulting in fewer disk I/O operations.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="bcdf2-410">Wenn ein Index alle Spalten enthält, auf die die Abfrage verweist, wird dies normalerweise als Abdecken der Abfrage bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-410">When an index contains all the columns referenced by the query it is typically referred to as covering the query.</span></span>  
  
 <span data-ttu-id="bcdf2-411">Die Schlüsselspalten werden auf allen Ebenen des Indexes gespeichert, die Nichtschlüsselspalten nur auf der Blattebene.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-411">While key columns are stored at all levels of the index, nonkey columns are stored only at the leaf level.</span></span>  
  
##### <a name="using-included-columns-to-avoid-size-limits"></a><span data-ttu-id="bcdf2-412">Verwenden eingeschlossener Spalten, um Größenbeschränkungen zu umgehen</span><span class="sxs-lookup"><span data-stu-id="bcdf2-412">Using Included Columns to Avoid Size Limits</span></span>  

 <span data-ttu-id="bcdf2-413">Sie können Nichtschlüsselspalten in einen nicht gruppierten Index einschließen, damit die Größenbegrenzungen des aktuellen Indexes von maximal 16 Schlüsselspalten und einer maximalen Größe des Indexschlüssels von 900 Byte nicht überschritten werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-413">You can include nonkey columns in a nonclustered index to avoid exceeding the current index size limitations of a maximum of 16 key columns and a maximum index key size of 900 bytes.</span></span> <span data-ttu-id="bcdf2-414">Nichtschlüsselspalten werden von [!INCLUDE[ssDE](../includes/ssde-md.md)] beim Berechnen der Indexschlüsselspalten oder Indexschlüsselgröße nicht berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-414">The [!INCLUDE[ssDE](../includes/ssde-md.md)] does not consider nonkey columns when calculating the number of index key columns or index key size.</span></span>  
  
 <span data-ttu-id="bcdf2-415">Angenommen, Sie möchten die folgenden Spalten in der `Document` -Tabelle indizieren:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-415">For example, assume that you want to index the following columns in the `Document` table:</span></span>  
  
 `Title nvarchar(50)`  
  
 `Revision nchar(5)`  
  
 `FileName nvarchar(400)`  
  
 <span data-ttu-id="bcdf2-416">Da für die Datentypen `nchar` und `nvarchar` 2 Bytes für jedes Zeichen erforderlich sind, überschreitet ein Index, der diese drei Spalten enthält, die Größenbeschränkung von 900 Bytes um 10 Bytes (455 \* 2).</span><span class="sxs-lookup"><span data-stu-id="bcdf2-416">Because the `nchar` and `nvarchar` data types require 2 bytes for each character, an index that contains these three columns would exceed the 900 byte size limitation by 10 bytes (455 \* 2).</span></span> <span data-ttu-id="bcdf2-417">Indem die `INCLUDE` -Klausel der `CREATE INDEX` -Anweisung verwendet wird, kann der Indexschlüssel als (`Title, Revision`) und `FileName` als Nichtschlüsselspalte definiert werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-417">By using the `INCLUDE` clause of the `CREATE INDEX` statement, the index key could be defined as (`Title, Revision`) and `FileName` defined as a nonkey column.</span></span> <span data-ttu-id="bcdf2-418">Auf diese Weise beträgt die Größe des Indexschlüssels 110 Byte (55 \* 2), und der Index enthält dennoch alle erforderlichen Spalten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-418">In this way, the index key size would be 110 bytes (55 \* 2), and the index would still contain all the required columns.</span></span> <span data-ttu-id="bcdf2-419">Die folgende Anweisung erstellt einen solchen Index:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-419">The following statement creates such an index.</span></span>  
  
```sql
CREATE INDEX IX_Document_Title   
ON Production.Document (Title, Revision)   
INCLUDE (FileName);   
```  
  
##### <a name="index-with-included-columns-guidelines"></a><span data-ttu-id="bcdf2-420">Richtlinien für Indizes mit eingeschlossenen Spalten</span><span class="sxs-lookup"><span data-stu-id="bcdf2-420">Index with Included Columns Guidelines</span></span>  

 <span data-ttu-id="bcdf2-421">Wenn Sie nicht gruppierte Indizes mit eingeschlossenen Spalten entwerfen, sollten Sie die folgenden Richtlinien beachten:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-421">When you design nonclustered indexes with included columns consider the following guidelines:</span></span>  
  
-   <span data-ttu-id="bcdf2-422">Nichtschlüsselspalten werden in der INCLUDE-Klausel der CREATE INDEX-Anweisung definiert.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-422">Nonkey columns are defined in the INCLUDE clause of the CREATE INDEX statement.</span></span>  
  
-   <span data-ttu-id="bcdf2-423">Nichtschlüsselspalten können nur für nicht gruppierte Indizes für Tabellen oder indizierte Sichten definiert werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-423">Nonkey columns can only be defined on nonclustered indexes on tables or indexed views.</span></span>  
  
-   <span data-ttu-id="bcdf2-424">Mit Ausnahme von `text`, `ntext` und `image` sind alle Datentypen zulässig.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-424">All data types are allowed except `text`, `ntext`, and `image`.</span></span>  
  
-   <span data-ttu-id="bcdf2-425">Bei berechneten Spalten, die deterministisch und präzise oder unpräzise sind, kann es sich um eingeschlossene Spalten handeln.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-425">Computed columns that are deterministic and either precise or imprecise can be included columns.</span></span> <span data-ttu-id="bcdf2-426">Weitere Informationen finden Sie unter [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span><span class="sxs-lookup"><span data-stu-id="bcdf2-426">For more information, see [Indexes on Computed Columns](../relational-databases/indexes/indexes-on-computed-columns.md).</span></span>  
  
-   <span data-ttu-id="bcdf2-427">Ebenso wie Schlüsselspalten können berechnete Spalten, die aus `image`-, `ntext`- und `text`-Datentypen abgeleitet werden, Nichtschlüsselspalten (eingeschlossene Spalten) sein, wenn der Datentyp der berechneten Spalte als Nichtschlüssel-Indexspalte zulässig ist.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-427">As with key columns, computed columns derived from `image`, `ntext`, and `text` data types can be nonkey (included) columns as long as the computed column data type is allowed as a nonkey index column.</span></span>  
  
-   <span data-ttu-id="bcdf2-428">Spaltennamen dürfen nicht sowohl in der INCLUDE-Liste als auch in der Schlüsselspaltenliste angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-428">Column names cannot be specified in both the INCLUDE list and in the key column list.</span></span>  
  
-   <span data-ttu-id="bcdf2-429">Spaltennamen können nicht in der INCLUDE-Liste wiederholt werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-429">Column names cannot be repeated in the INCLUDE list.</span></span>  
  
##### <a name="column-size-guidelines"></a><span data-ttu-id="bcdf2-430">Richtlinien für die Spaltengröße</span><span class="sxs-lookup"><span data-stu-id="bcdf2-430">Column Size Guidelines</span></span>  
  
-   <span data-ttu-id="bcdf2-431">Es muss mindestens eine Schlüsselspalte definiert werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-431">At least one key column must be defined.</span></span> <span data-ttu-id="bcdf2-432">Die maximal zulässige Anzahl der Nichtschlüsselspalten beträgt 1023 Spalten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-432">The maximum number of nonkey columns is 1023 columns.</span></span> <span data-ttu-id="bcdf2-433">Dies ist die maximale Anzahl der Tabellenspalten minus 1.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-433">This is the maximum number of table columns minus 1.</span></span>  
  
-   <span data-ttu-id="bcdf2-434">Indexschlüsselspalten (ausschließlich der Nichtschlüsselspalten) unterliegen der Begrenzung der Indexgröße auf maximal 16 Schlüsselspalten und der Gesamtgröße des Indexschlüssels von 900 Byte.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-434">Index key columns, excluding nonkeys, must follow the existing index size restrictions of 16 key columns maximum, and a total index key size of 900 bytes.</span></span>  
  
-   <span data-ttu-id="bcdf2-435">Die Gesamtgröße aller Nichtschlüsselspalten wird nur durch die in der INCLUDE-Klausel angegebene Größe der Spalten beschränkt; `varchar(max)`-Spalten sind z. B. auf 2 GB beschränkt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-435">The total size of all nonkey columns is limited only by the size of the columns specified in the INCLUDE clause; for example, `varchar(max)` columns are limited to 2 GB.</span></span>  
  
##### <a name="column-modification-guidelines"></a><span data-ttu-id="bcdf2-436">Richtlinien für die Spaltenänderung</span><span class="sxs-lookup"><span data-stu-id="bcdf2-436">Column Modification Guidelines</span></span>  

 <span data-ttu-id="bcdf2-437">Wenn Sie eine Tabellenspalte ändern, die als eingeschlossene Spalte definiert wurde, gelten die folgenden Einschränkungen:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-437">When you modify a table column that has been defined as an included column, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="bcdf2-438">Nichtschlüsselspalten können nur aus der Tabelle gelöscht werden, wenn der Index zuvor gelöscht wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-438">Nonkey columns cannot be dropped from the table unless the index is dropped first.</span></span>  
  
-   <span data-ttu-id="bcdf2-439">Nichtschlüsselspalten können nur zum Ausführen der folgenden Aufgaben geändert werden:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-439">Nonkey columns cannot be changed, except to do the following:</span></span>  
  
    -   <span data-ttu-id="bcdf2-440">Ändern der NULL-Zulässigkeit der Spalte von NOT NULL in NULL.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-440">Change the nullability of the column from NOT NULL to NULL.</span></span>  
  
    -   <span data-ttu-id="bcdf2-441">Vergrößern der Länge von `varchar`-, `nvarchar`- oder `varbinary`-Spalten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-441">Increase the length of `varchar`, `nvarchar`, or `varbinary` columns.</span></span>  
  
        > [!NOTE]  
        >  <span data-ttu-id="bcdf2-442">Diese Einschränkungen hinsichtlich der Spaltenänderung gelten für Indexschlüsselspalten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-442">These column modification restrictions also apply to index key columns.</span></span>  
  
##### <a name="design-recommendations"></a><span data-ttu-id="bcdf2-443">Entwurfsempfehlungen</span><span class="sxs-lookup"><span data-stu-id="bcdf2-443">Design Recommendations</span></span>  

 <span data-ttu-id="bcdf2-444">Überarbeiten Sie nicht gruppierte Indizes mit großen Indexschlüsseln so, dass nur Spalten, die für Suchen und Suchvorgänge verwendet werden, Schlüsselspalten sind.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-444">Redesign nonclustered indexes with a large index key size so that only columns used for searching and lookups are key columns.</span></span> <span data-ttu-id="bcdf2-445">Erklären Sie alle anderen Spalten, die die Abfrage abdecken, zu eingeschlossenen Nichtschlüsselspalten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-445">Make all other columns that cover the query included nonkey columns.</span></span> <span data-ttu-id="bcdf2-446">Auf diese Weise sind alle Spalten vorhanden, die zum Abdecken der Abfrage erforderlich sind, der Indexschlüssel selbst ist jedoch klein und effizient.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-446">In this way, you will have all columns needed to cover the query, but the index key itself is small and efficient.</span></span>  
  
 <span data-ttu-id="bcdf2-447">Angenommen, Sie möchten z. B. einen Index entwerfen, der die folgende Abfrage abdeckt:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-447">For example, assume that you want to design an index to cover the following query.</span></span>  
  
```sql
SELECT AddressLine1, AddressLine2, City, StateProvinceID, PostalCode  
FROM Person.Address  
WHERE PostalCode BETWEEN N'98000' and N'99999';  
```  
  
 <span data-ttu-id="bcdf2-448">Damit die Abfrage abgedeckt wird, muss jede Spalte im Index definiert werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-448">To cover the query, each column must be defined in the index.</span></span> <span data-ttu-id="bcdf2-449">Sie könnten zwar alle Spalten als Schlüsselspalten definieren, die Schlüsselgröße würde dann aber 334 Byte betragen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-449">Although you could define all columns as key columns, the key size would be 334 bytes.</span></span> <span data-ttu-id="bcdf2-450">Da die einzige Spalte, die tatsächlich als Suchkriterium verwendet wird, die `PostalCode` -Spalte mit einer Länge von 30 Byte ist, definiert der bessere Indexentwurf `PostalCode` als Schlüsselspalte und schließt alle anderen Spalten als Nichtschlüsselspalten ein.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-450">Because the only column actually used as search criteria is the `PostalCode` column, having a length of 30 bytes, a better index design would define `PostalCode` as the key column and include all other columns as nonkey columns.</span></span>  
  
 <span data-ttu-id="bcdf2-451">Die folgende Anweisung erstellt einen Index mit eingeschlossenen Spalten, um die Abfrage abzudecken:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-451">The following statement creates an index with included columns to cover the query.</span></span>  
  
```sql
CREATE INDEX IX_Address_PostalCode  
ON Person.Address (PostalCode)  
INCLUDE (AddressLine1, AddressLine2, City, StateProvinceID);  
```  
  
##### <a name="performance-considerations"></a><span data-ttu-id="bcdf2-452">Überlegungen zur Leistung</span><span class="sxs-lookup"><span data-stu-id="bcdf2-452">Performance Considerations</span></span>  

 <span data-ttu-id="bcdf2-453">Vermeiden Sie es, nicht erforderliche Spalten hinzuzufügen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-453">Avoid adding unnecessary columns.</span></span> <span data-ttu-id="bcdf2-454">Das Hinzufügen einer zu großen Anzahl von Schlüssel- oder Nichtschlüssel-Indexspalten kann zu folgenden Auswirkungen auf die Leistung führen:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-454">Adding too many index columns, key or nonkey, can have the following performance implications:</span></span>  
  
-   <span data-ttu-id="bcdf2-455">Es passen weniger Indexzeilen auf eine Seite.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-455">Fewer index rows will fit on a page.</span></span> <span data-ttu-id="bcdf2-456">Dies kann zu einer Zunahme der E/A und verringerter Cacheeffizienz führen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-456">This could create I/O increases and reduced cache efficiency.</span></span>  
  
-   <span data-ttu-id="bcdf2-457">Zum Speichern des Indexes ist eine größere Menge an Speicherplatz erforderlich.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-457">More disk space will be required to store the index.</span></span> <span data-ttu-id="bcdf2-458">Insbesondere das Hinzufügen von `varchar(max)`-, `nvarchar(max)`-, `varbinary(max)`- oder `xml`-Datentypen als Nichtschlüssel-Indexspalten kann die Anforderungen an den Speicherplatz erheblich erhöhen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-458">In particular, adding `varchar(max)`, `nvarchar(max)`, `varbinary(max)`, or `xml` data types as nonkey index columns may significantly increase disk space requirements.</span></span> <span data-ttu-id="bcdf2-459">Der Grund liegt darin, dass die Spaltenwerte in die Blattebene des Indexes kopiert werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-459">This is because the column values are copied into the index leaf level.</span></span> <span data-ttu-id="bcdf2-460">Daher werden sie sowohl im Index als auch in der Basistabelle gespeichert.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-460">Therefore, they reside in both the index and the base table.</span></span>  
  
-   <span data-ttu-id="bcdf2-461">Die Indexwartung kann zu einem größeren Zeitaufwand für das Ausführen von Änderungen, Einfügungen, Updates oder Löschvorgängen an der zugrunde liegenden Tabelle oder indizierten Sicht führen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-461">Index maintenance may increase the time that it takes to perform modifications, inserts, updates, or deletes, to the underlying table or indexed view.</span></span>  
  
 <span data-ttu-id="bcdf2-462">Sie müssen überprüfen, ob die Steigerungen der Abfrageleistung die negativen Auswirkungen auf die Leistung während der Datenänderung sowie hinsichtlich zusätzlicher Speicherplatzanforderungen aufwiegen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-462">You will have to determine whether the gains in query performance outweigh the affect to performance during data modification and in additional disk space requirements.</span></span>  
  
 <span data-ttu-id="bcdf2-463">![Pfeilsymbol mit dem Link "zurück zum Anfang](media/uparrow16x16.gif "Pfeilsymbol, das mit dem Link „Zurück zum Anfang“ verwendet wird") " [in diesem Handbuch](#Top)</span><span class="sxs-lookup"><span data-stu-id="bcdf2-463">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="unique-index-design-guidelines"></a><a name="Unique"></a> <span data-ttu-id="bcdf2-464">Richtlinien zum Entwerfen eindeutiger Indizes</span><span class="sxs-lookup"><span data-stu-id="bcdf2-464">Unique Index Design Guidelines</span></span>  

 <span data-ttu-id="bcdf2-465">Ein eindeutiger Index garantiert, dass der Indexschlüssel keine doppelten Werte enthält und dass deshalb jede Zeile in der Tabelle in gewisser Weise eindeutig ist.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-465">A unique index guarantees that the index key contains no duplicate values and therefore every row in the table is in some way unique.</span></span> <span data-ttu-id="bcdf2-466">Das Angeben eines eindeutigen Indexes ist nur dann sinnvoll, wenn die Eindeutigkeit ein Merkmal der Daten ist.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-466">Specifying a unique index makes sense only when uniqueness is a characteristic of the data itself.</span></span> <span data-ttu-id="bcdf2-467">Wenn Sie z. B. sicherstellen möchten, dass die Werte in der `NationalIDNumber` -Spalte der `HumanResources.Employee` -Tabelle eindeutig sind, wenn der Primärschlüssel `EmployeeID`entspricht, erstellen Sie eine UNIQUE-Einschränkung für die `NationalIDNumber` -Spalte.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-467">For example, if you want to make sure that the values in the `NationalIDNumber` column in the `HumanResources.Employee` table are unique, when the primary key is `EmployeeID`, create a UNIQUE constraint on the `NationalIDNumber` column.</span></span> <span data-ttu-id="bcdf2-468">Wenn der Benutzer versucht, denselben Wert für mehrere Mitarbeiter in diese Spalte einzugeben, wird eine Fehlermeldung angezeigt, und der doppelte Wert wird nicht eingegeben.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-468">If the user tries to enter the same value in that column for more than one employee, an error message is displayed and the duplicate value is not entered.</span></span>  
  
 <span data-ttu-id="bcdf2-469">Durch eindeutige Indizes für mehrere Spalten stellt der Index sicher, dass jede Kombination der Werte in der indizierten Spalte eindeutig ist.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-469">With multicolumn unique indexes, the index guarantees that each combination of values in the index key is unique.</span></span> <span data-ttu-id="bcdf2-470">Wenn z. B. ein eindeutiger Index für eine Kombination der Spalten `LastName`, `FirstName`und `MiddleName` erstellt wird, können zwei Zeilen in der Tabelle nicht über dieselbe Wertekombination für diese Spalten verfügen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-470">For example, if a unique index is created on a combination of `LastName`, `FirstName`, and `MiddleName` columns, no two rows in the table could have the same combination of values for these columns.</span></span>  
  
 <span data-ttu-id="bcdf2-471">Sowohl gruppierte als auch nicht gruppierte Indizes können eindeutig sein.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-471">Both clustered and nonclustered indexes can be unique.</span></span> <span data-ttu-id="bcdf2-472">Unter der Voraussetzung, dass die Daten in der Spalte eindeutig sind, können Sie einen eindeutigen gruppierten Index und mehrere eindeutige nicht gruppierte Indizes für dieselbe Tabelle erstellen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-472">Provided that the data in the column is unique, you can create both a unique clustered index and multiple unique nonclustered indexes on the same table.</span></span>  
  
 <span data-ttu-id="bcdf2-473">Eindeutige Indizes haben folgende Vorteile:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-473">The benefits of unique indexes include the following:</span></span>  
  
-   <span data-ttu-id="bcdf2-474">Die Datenintegrität der definierten Spalten ist sichergestellt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-474">Data integrity of the defined columns is ensured.</span></span>  
  
-   <span data-ttu-id="bcdf2-475">Es werden zusätzliche, für den Abfrageoptimierer hilfreiche Informationen bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-475">Additional information helpful to the query optimizer is provided.</span></span>  
  
 <span data-ttu-id="bcdf2-476">Durch das Erstellen einer PRIMARY KEY- oder einer UNIQUE-Einschränkung wird automatisch ein eindeutiger Index für die angegebenen Spalten erstellt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-476">Creating a PRIMARY KEY or UNIQUE constraint automatically creates a unique index on the specified columns.</span></span> <span data-ttu-id="bcdf2-477">Es gibt keine deutlichen Unterschiede zwischen dem Erstellen einer UNIQUE-Einschränkung und dem Erstellen eines eindeutigen Indexes unabhängig von einer Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-477">There are no significant differences between creating a UNIQUE constraint and creating a unique index independent of a constraint.</span></span> <span data-ttu-id="bcdf2-478">Die Datenüberprüfung erfolgt auf dieselbe Weise, und der Abfrageoptimierer macht keinen Unterschied zwischen einem durch eine Einschränkung erstellten eindeutigen Index und einem manuell erstellten Index.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-478">Data validation occurs in the same manner and the query optimizer does not differentiate between a unique index created by a constraint or manually created.</span></span> <span data-ttu-id="bcdf2-479">Allerdings sollten sie eine UNIQUE- oder PRIMARY KEY-Einschränkung für die Spalte erstellen, wenn Datenintegrität das Ziel ist.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-479">However, you should create a UNIQUE or PRIMARY KEY constraint on the column when data integrity is the objective.</span></span> <span data-ttu-id="bcdf2-480">Dadurch wird das Ziel des Indexes klar.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-480">By doing this the objective of the index will be clear.</span></span>  
  
### <a name="considerations"></a><span data-ttu-id="bcdf2-481">Überlegungen</span><span class="sxs-lookup"><span data-stu-id="bcdf2-481">Considerations</span></span>  
  
-   <span data-ttu-id="bcdf2-482">Ein eindeutiger Index, die UNIQUE-Einschränkung oder die PRIMARY KEY-Einschränkung kann nicht erstellt werden, wenn in den Daten doppelte Schlüsselwerte vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-482">A unique index, UNIQUE constraint, or PRIMARY KEY constraint cannot be created if duplicate key values exist in the data.</span></span>  
  
-   <span data-ttu-id="bcdf2-483">Wenn die Daten eindeutig sind und Sie die Eindeutigkeit erzwingen wollen, werden durch das Erstellen eines eindeutigen Indexes anstelle eines nicht eindeutigen Indexes für dieselbe Spaltenkombination zusätzliche Informationen für den Abfrageoptimierer bereitgestellt, mit deren Hilfe effizientere Ausführungspläne erstellt werden können.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-483">If the data is unique and you want uniqueness enforced, creating a unique index instead of a nonunique index on the same combination of columns provides additional information for the query optimizer that can produce more efficient execution plans.</span></span> <span data-ttu-id="bcdf2-484">Das Erstellen eines eindeutigen Indexes (vorzugsweise durch Erstellen einer UNIQUE-Einschränkung) ist in diesem Fall empfohlen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-484">Creating a unique index (preferably by creating a UNIQUE constraint) is recommended in this case.</span></span>  
  
-   <span data-ttu-id="bcdf2-485">Ein eindeutiger, nicht gruppierter Index kann eingeschlossene Nichtschlüsselspalten enthalten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-485">A unique nonclustered index can contain included nonkey columns.</span></span> <span data-ttu-id="bcdf2-486">Weitere Informationen finden Sie unter [Index mit eingeschlossenen Spalten](#Included_Columns).</span><span class="sxs-lookup"><span data-stu-id="bcdf2-486">For more information, see [Index with Included Columns](#Included_Columns).</span></span>  
  
 <span data-ttu-id="bcdf2-487">![Pfeilsymbol mit dem Link "zurück zum Anfang](media/uparrow16x16.gif "Pfeilsymbol, das mit dem Link „Zurück zum Anfang“ verwendet wird") " [in diesem Handbuch](#Top)</span><span class="sxs-lookup"><span data-stu-id="bcdf2-487">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="filtered-index-design-guidelines"></a><a name="Filtered"></a> <span data-ttu-id="bcdf2-488">Richtlinien für den Entwurf gefilterter Indizes</span><span class="sxs-lookup"><span data-stu-id="bcdf2-488">Filtered Index Design Guidelines</span></span>  

 <span data-ttu-id="bcdf2-489">Ein gefilterter Index ist ein optimierter nicht gruppierter Index, der sich besonders für Abfragen eignet, bei denen aus einer fest definierten Teilmenge von Daten ausgewählt wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-489">A filtered index is an optimized nonclustered index, especially suited to cover queries that select from a well-defined subset of data.</span></span> <span data-ttu-id="bcdf2-490">Dieser verwendet ein Filterprädikat, um einen Teil der Zeilen in der Tabelle zu indizieren.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-490">It uses a filter predicate to index a portion of rows in the table.</span></span> <span data-ttu-id="bcdf2-491">Mit einem sorgfältig entworfenen gefilterten Index können im Gegensatz zu Tabellenindizes die Abfrageleistung verbessert und der Aufwand für die Indexverwaltung und -speicherung reduziert werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-491">A well-designed filtered index can improve query performance, reduce index maintenance costs, and reduce index storage costs compared with full-table indexes.</span></span>  
  
||  
|-|  
|<span data-ttu-id="bcdf2-492">**Gilt für**: [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] bis [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span><span class="sxs-lookup"><span data-stu-id="bcdf2-492">**Applies to**: [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] through [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
  
 <span data-ttu-id="bcdf2-493">Gefilterte Indizes können gegenüber Tabellenindizes folgende Vorteile bieten:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-493">Filtered indexes can provide the following advantages over full-table indexes:</span></span>  
  
-   <span data-ttu-id="bcdf2-494">**Verbesserte Abfrageleistung und Planqualität**</span><span class="sxs-lookup"><span data-stu-id="bcdf2-494">**Improved query performance and plan quality**</span></span>  
  
     <span data-ttu-id="bcdf2-495">Mit einem sorgfältig entworfenen gefilterten Index wird die Abfrageleistung und die Ausführungsplanqualität verbessert, da dieser kleiner ist als ein nicht gruppierter Tabellenindex und mit gefilterten Statistiken arbeitet.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-495">A well-designed filtered index improves query performance and execution plan quality because it is smaller than a full-table nonclustered index and has filtered statistics.</span></span> <span data-ttu-id="bcdf2-496">Die gefilterten Statistiken sind genauer als Tabellenstatistiken, da diese nur die Zeilen im gefilterten Index umfassen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-496">The filtered statistics are more accurate than full-table statistics because they cover only the rows in the filtered index.</span></span>  
  
-   <span data-ttu-id="bcdf2-497">**Reduzierter Aufwand bei der Indexverwaltung**</span><span class="sxs-lookup"><span data-stu-id="bcdf2-497">**Reduced index maintenance costs**</span></span>  
  
     <span data-ttu-id="bcdf2-498">Ein Index wird nur beibehalten, wenn DML-Anweisungen (Data Manipulation Language) die Daten im Index beeinflussen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-498">An index is maintained only when data manipulation language (DML) statements affect the data in the index.</span></span> <span data-ttu-id="bcdf2-499">Ein gefilterter Index reduziert im Vergleich zu einem nicht gruppierten Tabellenindex den Aufwand für die Indexverwaltung, da dieser kleiner ist und nur beibehalten wird, wenn die Daten im Index beeinflusst werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-499">A filtered index reduces index maintenance costs compared with a full-table nonclustered index because it is smaller and is only maintained when the data in the index is affected.</span></span> <span data-ttu-id="bcdf2-500">Eine große Anzahl von gefilterten Indizes ist insbesondere dann von Vorteil, wenn diese Daten enthalten, die nur selten beeinflusst werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-500">It is possible to have a large number of filtered indexes, especially when they contain data that is affected infrequently.</span></span> <span data-ttu-id="bcdf2-501">Ebenso reduziert die geringere Indexgröße den Aufwand für die Aktualisierung der Statistiken, wenn ein gefilterter Index nur die häufig beeinflussten Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-501">Similarly, if a filtered index contains only the frequently affected data, the smaller size of the index reduces the cost of updating the statistics.</span></span>  
  
-   <span data-ttu-id="bcdf2-502">**Reduzierter Aufwand bei der Indexspeicherung**</span><span class="sxs-lookup"><span data-stu-id="bcdf2-502">**Reduced index storage costs**</span></span>  
  
     <span data-ttu-id="bcdf2-503">Ein gefilterter Index kann den Speicherplatzbedarf von nicht gruppierten Indizes reduzieren, wenn ein Tabellenindex nicht erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-503">Creating a filtered index can reduce disk storage for nonclustered indexes when a full-table index is not necessary.</span></span> <span data-ttu-id="bcdf2-504">Sie können einen nicht gruppierten Tabellenindex durch mehrere gefilterte Indizes ersetzen, ohne damit die Speicherplatzanforderungen wesentlich zu erhöhen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-504">You can replace a full-table nonclustered index with multiple filtered indexes without significantly increasing the storage requirements.</span></span>  
  
 <span data-ttu-id="bcdf2-505">Gefilterte Indizes sind nützlich, wenn Spalten klar definierte Teilmengen von Daten enthalten, auf die Abfragen in SELECT-Anweisungen verweisen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-505">Filtered indexes are useful when columns contain well-defined subsets of data that queries reference in SELECT statements.</span></span> <span data-ttu-id="bcdf2-506">Beispiele:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-506">Examples are:</span></span>  
  
-   <span data-ttu-id="bcdf2-507">Spalten mit geringer Dichte, die nur wenige Werte ungleich NULL enthalten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-507">Sparse columns that contain only a few non-NULL values.</span></span>  
  
-   <span data-ttu-id="bcdf2-508">Heterogene Spalten, die Datenkategorien enthalten.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-508">Heterogeneous columns that contain categories of data.</span></span>  
  
-   <span data-ttu-id="bcdf2-509">Spalten, die Wertebereiche enthalten, z.&nbsp;B. Dollarmengen, Zeit- und Datumsangaben.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-509">Columns that contain ranges of values such as dollar amounts, time, and dates.</span></span>  
  
-   <span data-ttu-id="bcdf2-510">Tabellenpartitionen, die durch einfache Vergleichslogik für Spaltenwerte definiert werden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-510">Table partitions that are defined by simple comparison logic for column values.</span></span>  
  
 <span data-ttu-id="bcdf2-511">Der reduzierte Verwaltungsaufwand für gefilterte Indizes ist am deutlichsten, wenn die Zeilenanzahl im Index verglichen mit der eines Tabellenindex klein ist.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-511">Reduced maintenance costs for filtered indexes are most noticeable when the number of rows in the index is small compared with a full-table index.</span></span> <span data-ttu-id="bcdf2-512">Wenn der gefilterte Index die meisten Zeilen in der Tabelle einschließt, ist der Verwaltungsaufwand möglicherweise größer als bei einem Tabellenindex.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-512">If the filtered index includes most of the rows in the table, it could cost more to maintain than a full-table index.</span></span> <span data-ttu-id="bcdf2-513">In diesem Fall sollten Sie anstelle eines gefilterten Index einen Tabellenindex verwenden.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-513">In this case, you should use a full-table index instead of a filtered index.</span></span>  
  
 <span data-ttu-id="bcdf2-514">Gefilterte Indizes werden für eine Tabelle definiert und unterstützen nur einfache Vergleichsoperatoren.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-514">Filtered indexes are defined on one table and only support simple comparison operators.</span></span> <span data-ttu-id="bcdf2-515">Wenn Sie einen Filterausdruck benötigen, der auf mehrere Tabellen verweist oder eine komplexe Logik aufweist, sollten Sie eine Sicht erstellen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-515">If you need a filter expression that references multiple tables or has complex logic, you should create a view.</span></span>  
  
### <a name="design-considerations"></a><span data-ttu-id="bcdf2-516">Entwurfsaspekte</span><span class="sxs-lookup"><span data-stu-id="bcdf2-516">Design Considerations</span></span>  

 <span data-ttu-id="bcdf2-517">Wenn Sie effektive gefilterte Indizes entwerfen möchten, müssen Sie wissen, welche Abfragen von Ihrer Anwendung verwendet werden und wie diese mit Teilmengen Ihrer Daten in Beziehung stehen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-517">In order to design effective filtered indexes, it is important to understand what queries your application uses and how they relate to subsets of your data.</span></span> <span data-ttu-id="bcdf2-518">Einige Beispiele für Daten mit fest definierten Teilmengen sind Spalten, die größtenteils nur NULL-Werte enthalten, Spalten mit heterogenen Wertekategorien und Spalten mit verschiedenen Wertebereichen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-518">Some examples of data that have well-defined subsets are columns with mostly NULL values, columns with heterogeneous categories of values and columns with distinct ranges of values.</span></span> <span data-ttu-id="bcdf2-519">Die folgenden Entwurfsüberlegungen zeigen, wann ein gefilterter Index Vorteile gegenüber Tabellenindizes hat.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-519">The following design considerations give a variety of scenarios for when a filtered index can provide advantages over full-table indexes.</span></span>  
  
#### <a name="filtered-indexes-for-subsets-of-data"></a><span data-ttu-id="bcdf2-520">Gefilterte Indizes für Datenteilmengen</span><span class="sxs-lookup"><span data-stu-id="bcdf2-520">Filtered Indexes for Subsets of Data</span></span>  

 <span data-ttu-id="bcdf2-521">Wenn eine Spalte nur wenig relevante Werte für Abfragen aufweist, können Sie für die Teilmenge der Werte einen gefilterten Index erstellen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-521">When a column only has a small number of relevant values for queries, you can create a filtered index on the subset of values.</span></span> <span data-ttu-id="bcdf2-522">Wenn beispielsweise die Werte in einer Spalte größtenteils NULL sind und die Abfrage nur die Werte ungleich NULL berücksichtigt, können Sie für die Datenzeilen mit den Werten ungleich NULL einen gefilterten Index erstellen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-522">For example, when the values in a column are mostly NULL and the query selects only from the non-NULL values, you can create a filtered index for the non-NULL data rows.</span></span> <span data-ttu-id="bcdf2-523">Der resultierende Index ist kleiner und verursacht weniger Verwaltungsaufwand als ein nicht gruppierter Tabellenindex, der für dieselben Schlüsselspalten festgelegt wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-523">The resulting index will be smaller and cost less to maintain than a full-table nonclustered index defined on the same key columns.</span></span>  
  
 <span data-ttu-id="bcdf2-524">Die Datenbank `AdventureWorks2012` enthält z. B. eine `Production.BillOfMaterials` -Tabelle mit 2679 Zeilen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-524">For example, the `AdventureWorks2012` database has a `Production.BillOfMaterials` table with 2679 rows.</span></span> <span data-ttu-id="bcdf2-525">Die `EndDate` -Spalte hat nur 199 Zeilen mit einem Wert ungleich NULL. Die anderen 2.480 Zeilen enthalten einen NULL-Wert.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-525">The `EndDate` column has only 199 rows that contain a non-NULL value and the other 2480 rows contain NULL.</span></span> <span data-ttu-id="bcdf2-526">Der folgende gefilterte Index würde Abfragen abdecken, die die im Index definierten Spalten zurückgeben und die für `EndDate`nur Zeilen mit einem Wert ungleich NULL auswählen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-526">The following filtered index would cover queries that return the columns defined in the index and that select only rows with a non-NULL value for `EndDate`.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX FIBillOfMaterialsWithEndDate  
    ON Production.BillOfMaterials (ComponentID, StartDate)  
    WHERE EndDate IS NOT NULL ;  
GO  
```  
  
 <span data-ttu-id="bcdf2-527">Der gefilterte Index `FIBillOfMaterialsWithEndDate` ist für die folgende Abfrage gültig.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-527">The filtered index `FIBillOfMaterialsWithEndDate` is valid for the following query.</span></span> <span data-ttu-id="bcdf2-528">Sie können den Abfrageausführungsplan anzeigen, um zu bestimmen, ob der Abfrageoptimierer den gefilterten Index verwendet hat.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-528">You can display the query execution plan to determine if the query optimizer used the filtered index.</span></span>  
  
```sql
SELECT ProductAssemblyID, ComponentID, StartDate   
FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL   
    AND ComponentID = 5   
    AND StartDate > '20080101' ;  
```  
  
 <span data-ttu-id="bcdf2-529">Weitere Informationen zum Erstellen von gefilterten Indizes und zum Definieren des Prädikatausdrucks für gefilterte Indizes finden Sie unter [Create Filtered Indexes](../relational-databases/indexes/create-filtered-indexes.md).</span><span class="sxs-lookup"><span data-stu-id="bcdf2-529">For more information about how to create filtered indexes and how to define the filtered index predicate expression, see [Create Filtered Indexes](../relational-databases/indexes/create-filtered-indexes.md).</span></span>  
  
#### <a name="filtered-indexes-for-heterogeneous-data"></a><span data-ttu-id="bcdf2-530">Gefilterte Indizes für heterogene Daten</span><span class="sxs-lookup"><span data-stu-id="bcdf2-530">Filtered Indexes for Heterogeneous Data</span></span>  

 <span data-ttu-id="bcdf2-531">Wenn eine Tabelle heterogene Datenzeilen enthält, können Sie einen gefilterten Index für eine oder mehrere Datenkategorien erstellen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-531">When a table has heterogeneous data rows, you can create a filtered index for one or more categories of data.</span></span>  
  
 <span data-ttu-id="bcdf2-532">Zum Beispiel wird jedes Produkt, das in der `Production.Product` -Tabelle aufgelistet ist, einer `ProductSubcategoryID`zugewiesen, die wiederum den Produktkategorien Fahrräder, Bauteile, Bekleidung oder Zubehör zugeordnet wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-532">For example, the products listed in the `Production.Product` table are each assigned to a `ProductSubcategoryID`, which are in turn associated with the product categories Bikes, Components, Clothing, or Accessories.</span></span> <span data-ttu-id="bcdf2-533">Diese Kategorien sind heterogen, da ihre Spaltenwerte in der `Production.Product` -Tabelle nicht eng zueinander in Beziehung stehen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-533">These categories are heterogeneous because their column values in the `Production.Product` table are not closely correlated.</span></span> <span data-ttu-id="bcdf2-534">Beispielsweise besitzen die Spalten `Color`, `ReorderPoint`, `ListPrice`, `Weight`, `Class`und `Style` eindeutige Merkmale für jede Produktkategorie.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-534">For example, the columns `Color`, `ReorderPoint`, `ListPrice`, `Weight`, `Class`, and `Style` have unique characteristics for each product category.</span></span> <span data-ttu-id="bcdf2-535">Angenommen, es werden häufig Abfragen für Zubehör mit Unterkategorien zwischen 27 und 36 einschließlich ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-535">Suppose that there are frequent queries for accessories which have subcategories between 27 and 36 inclusive.</span></span> <span data-ttu-id="bcdf2-536">Sie können die Abfrageleistung für Zubehör verbessern, indem Sie einen gefilterten Index für die Unterkategorien von Zubehör erstellen, wie im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-536">You can improve the performance of queries for accessories by creating a filtered index on the accessories subcategories as shown in the following example.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX FIProductAccessories  
    ON Production.Product (ProductSubcategoryID, ListPrice)   
        Include (Name)  
WHERE ProductSubcategoryID >= 27 AND ProductSubcategoryID <= 36;
```  
  
 <span data-ttu-id="bcdf2-537">Der gefilterte Index `FIProductAccessories` deckt die folgende Abfrage ab, da die Abfrageergebnisse</span><span class="sxs-lookup"><span data-stu-id="bcdf2-537">The filtered index `FIProductAccessories` covers the following query because the query</span></span>  
  
 <span data-ttu-id="bcdf2-538">im Index enthalten sind und der Abfrageplan keine Basistabellensuche einschließt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-538">results are contained in the index and the query plan does not include a base table lookup.</span></span> <span data-ttu-id="bcdf2-539">Der Abfrageprädikatausdruck `ProductSubcategoryID = 33` ist z. B. eine Teilmenge der gefilterten Indexprädikate `ProductSubcategoryID >= 27` und `ProductSubcategoryID <= 36`, die Spalten `ProductSubcategoryID` und `ListPrice` im Abfrageprädikat sind beides Schlüsselspalten im Index, und der Name wird in der Blattebene des Indexes als einbezogene Spalte gespeichert.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-539">For example, the query predicate expression `ProductSubcategoryID = 33` is a subset of the filtered index predicate `ProductSubcategoryID >= 27` and `ProductSubcategoryID <= 36`, the `ProductSubcategoryID` and `ListPrice` columns in the query predicate are both key columns in the index, and name is stored in the leaf level of the index as an included column.</span></span>  
  
```sql
SELECT Name, ProductSubcategoryID, ListPrice  
FROM Production.Product  
WHERE ProductSubcategoryID = 33 AND ListPrice > 25.00 ;  
```  
  
#### <a name="key-columns"></a><span data-ttu-id="bcdf2-540">Schlüsselspalten</span><span class="sxs-lookup"><span data-stu-id="bcdf2-540">Key Columns</span></span>  

 <span data-ttu-id="bcdf2-541">Die bewährte Methode besteht darin, eine geringe Anzahl von Schlüsselspalten oder eingeschlossenen Spalten in eine Definition des gefilterten Indexes einzuschließen und nur die Spalten einzubeziehen, die der Abfrageoptimierer benötigt, um den gefilterten Index für den Abfrageausführungsplan auszuwählen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-541">It is a best practice to include a small number of key or included columns in a filtered index definition, and to incorporate only the columns that are necessary for the query optimizer to choose the filtered index for the query execution plan.</span></span> <span data-ttu-id="bcdf2-542">Der Abfrageoptimierer kann einen gefilterten Index für die Abfrage auswählen, unabhängig davon, ob dieser die Abfrage abdeckt oder nicht.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-542">The query optimizer can choose a filtered index for the query regardless of whether it does or does not cover the query.</span></span> <span data-ttu-id="bcdf2-543">Der Abfrageoptimierer wählt jedoch eher einen gefilterten Index aus, der die Abfrage abdeckt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-543">However, the query optimizer is more likely to choose a filtered index if it covers the query.</span></span>  
  
 <span data-ttu-id="bcdf2-544">In einigen Fällen deckt ein gefilterter Index die Abfrage ab, ohne die Spalten im gefilterten Indexausdruck als Schlüsselspalten oder eingeschlossene Spalten in der Definition des gefilterten Indexes einzuschließen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-544">In some cases, a filtered index covers the query without including the columns in the filtered index expression as key or included columns in the filtered index definition.</span></span> <span data-ttu-id="bcdf2-545">Die folgenden Richtlinien erläutern, wann eine Spalte im gefilterten Indexausdruck eine Schlüsselspalte oder eingeschlossene Spalte in der Definition des gefilterten Indexes sein sollte.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-545">The following guidelines explain when a column in the filtered index expression should be a key or included column in the filtered index definition.</span></span> <span data-ttu-id="bcdf2-546">Die Beispiele beziehen sich auf den gefilterten Index `FIBillOfMaterialsWithEndDate` , der zuvor erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-546">The examples refer to the filtered index, `FIBillOfMaterialsWithEndDate` that was created previously.</span></span>  
  
 <span data-ttu-id="bcdf2-547">Eine Spalte im gefilterten Indexausdruck muss in der Definition des gefilterten Indexes keine Schlüsselspalte oder eingeschlossene Spalte sein, wenn der gefilterte Indexausdruck dem Abfrageprädikat entspricht und die Abfrage die Spalte im gefilterten Indexausdruck mit den Abfrageergebnissen nicht zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-547">A column in the filtered index expression does not need to be a key or included column in the filtered index definition if the filtered index expression is equivalent to the query predicate and the query does not return the column in the filtered index expression with the query results.</span></span> <span data-ttu-id="bcdf2-548">Zum Beispiel deckt `FIBillOfMaterialsWithEndDate` die folgende Abfrage ab, da das Abfrageprädikat dem Filterausdruck entspricht und `EndDate` nicht mit den Abfrageergebnissen zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-548">For example, `FIBillOfMaterialsWithEndDate` covers the following query because the query predicate is equivalent to the filter expression, and `EndDate` is not returned with the query results.</span></span> <span data-ttu-id="bcdf2-549">`FIBillOfMaterialsWithEndDate` erfordert nicht, dass `EndDate` eine Schlüsselspalte oder eingeschlossene Spalte in der Definition des gefilterten Indexes ist.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-549">`FIBillOfMaterialsWithEndDate` does not need `EndDate` as a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL;   
```  
  
 <span data-ttu-id="bcdf2-550">Eine Spalte im gefilterten Indexausdruck sollte in der Definition des gefilterten Indexes eine Schlüsselspalte oder eingeschlossene Spalte sein, wenn das Abfrageprädikat die Spalte in einem Vergleich verwendet, der nicht dem gefilterten Indexausdruck entspricht.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-550">A column in the filtered index expression should be a key or included column in the filtered index definition if the query predicate uses the column in a comparison that is not equivalent to the filtered index expression.</span></span> <span data-ttu-id="bcdf2-551">Zum Beispiel ist `FIBillOfMaterialsWithEndDate` für die folgende Abfrage gültig, da damit aus dem gefilterten Index eine Teilmenge von Zeilen ausgewählt wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-551">For example, `FIBillOfMaterialsWithEndDate` is valid for the following query because it selects a subset of rows from the filtered index.</span></span> <span data-ttu-id="bcdf2-552">Damit wird jedoch nicht die folgende Abfrage abgedeckt, da `EndDate` im Vergleich `EndDate > '20040101'`verwendet wird, der nicht dem gefilterten Indexausdruck entspricht.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-552">However, it does not cover the following query because `EndDate` is used in the comparison `EndDate > '20040101'`, which is not equivalent to the filtered index expression.</span></span> <span data-ttu-id="bcdf2-553">Der Abfrageprozessor kann diese Abfrage nicht ausführen, ohne die Werte von `EndDate`abzurufen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-553">The query processor cannot execute this query without looking up the values of `EndDate`.</span></span> <span data-ttu-id="bcdf2-554">Deshalb sollte `EndDate` eine Schlüsselspalte oder eingeschlossene Spalte in der Definition des gefilterten Indexes darstellen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-554">Therefore, `EndDate` should be a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate FROM Production.BillOfMaterials  
WHERE EndDate > '20040101';   
```  
  
 <span data-ttu-id="bcdf2-555">Eine Spalte im gefilterten Indexausdruck sollte in der Definition des gefilterten Indexes eine Schlüsselspalte oder eingeschlossene Spalte sein, wenn die Spalte im Abfrageresultset enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-555">A column in the filtered index expression should be a key or included column in the filtered index definition if the column is in the query result set.</span></span> <span data-ttu-id="bcdf2-556">Zum Beispiel deckt `FIBillOfMaterialsWithEndDate` die folgende Abfrage nicht ab, da damit die `EndDate` -Spalte in den Abfrageergebnissen zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-556">For example, `FIBillOfMaterialsWithEndDate` does not cover the following query because it returns the `EndDate` column in the query results.</span></span> <span data-ttu-id="bcdf2-557">Deshalb sollte `EndDate` eine Schlüsselspalte oder eingeschlossene Spalte in der Definition des gefilterten Indexes darstellen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-557">Therefore, `EndDate` should be a key or included column in the filtered index definition.</span></span>  
  
```sql
SELECT ComponentID, StartDate, EndDate FROM Production.BillOfMaterials  
WHERE EndDate IS NOT NULL;  
```  
  
 <span data-ttu-id="bcdf2-558">Der Schlüssel des gruppierten Indexes für die Tabelle muss in der Definition des gefilterten Indexes keine Schlüsselspalte oder eingeschlossene Spalte sein.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-558">The clustered index key of the table does not need to be a key or included column in the filtered index definition.</span></span> <span data-ttu-id="bcdf2-559">Der Schlüssel des gruppierten Indexes ist automatisch in allen nicht gruppierten Indizes enthalten, wozu auch gefilterte Indizes zählen.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-559">The clustered index key is automatically included in all nonclustered indexes, including filtered indexes.</span></span>  
  
#### <a name="data-conversion-operators-in-the-filter-predicate"></a><span data-ttu-id="bcdf2-560">Datenkonvertierungsoperatoren im Filterprädikat</span><span class="sxs-lookup"><span data-stu-id="bcdf2-560">Data Conversion Operators in the Filter Predicate</span></span>  

 <span data-ttu-id="bcdf2-561">Wenn der im gefilterten Indexausdruck der gefilterten Indexergebnisse angegebene Vergleichsoperator eine implizite oder explizite Datenkonvertierung ergibt, kommt es zu einem Fehler, wenn die Konvertierung auf der linken Seite eines Vergleichsoperators auftritt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-561">If the comparison operator specified in the filtered index expression of the filtered index results in an implicit or explicit data conversion, an error will occur if the conversion occurs on the left side of a comparison operator.</span></span> <span data-ttu-id="bcdf2-562">Eine mögliche Lösung besteht darin, den gefilterten Indexausdruck mit dem Datenkonvertierungsoperator (CAST oder CONVERT) auf die rechte Seite des Vergleichsoperators zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-562">A solution is to write the filtered index expression with the data conversion operator (CAST or CONVERT) on the right side of the comparison operator.</span></span>  
  
 <span data-ttu-id="bcdf2-563">Im folgenden Beispiel wird eine Tabelle mit einer Vielzahl von Datentypen erstellt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-563">The following example creates a table with a variety of data types.</span></span>  
  
```sql
USE AdventureWorks2012;  
GO  
CREATE TABLE dbo.TestTable (a int, b varbinary(4));  
```  
  
 <span data-ttu-id="bcdf2-564">In der folgenden Definition des gefilterten Indexes wird die Spalte `b` implizit in einen ganzzahligen Datentyp konvertiert, um sie mit der Konstante 1 vergleichen zu können.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-564">In the following filtered index definition, column `b` is implicitly converted to an integer data type for the purpose of comparing it to the constant 1.</span></span> <span data-ttu-id="bcdf2-565">Dadurch wird die Fehlermeldung 10611 erzeugt, da die Konvertierung auf der linken Seite des Operators im gefilterten Prädikat auftritt.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-565">This generates error message 10611 because the conversion occurs on the left hand side of the operator in the filtered predicate.</span></span>  
  
```sql
CREATE NONCLUSTERED INDEX TestTabIndex ON dbo.TestTable(a,b)  
WHERE b = 1;  
```  
  
 <span data-ttu-id="bcdf2-566">Die Lösung besteht darin, die Konstante auf der rechten Seite zu konvertieren, damit diese vom gleichen Typ ist wie Spalte `b`, wie aus dem folgenden Beispiel hervorgeht:</span><span class="sxs-lookup"><span data-stu-id="bcdf2-566">The solution is to convert the constant on the right hand side to be of the same type as column `b`, as seen in the following example:</span></span>  
  
```sql
CREATE INDEX TestTabIndex ON dbo.TestTable(a,b)  
WHERE b = CONVERT(Varbinary(4), 1);  
```  
  
 <span data-ttu-id="bcdf2-567">Durch das Verschieben der Datenkonvertierung von der linken Seite auf die rechte Seite eines Vergleichsoperators wird möglicherweise die Bedeutung der Konvertierung geändert.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-567">Moving the data conversion from the left side to the right side of a comparison operator might change the meaning of the conversion.</span></span> <span data-ttu-id="bcdf2-568">Im obigen Beispiel wurde aus einem Integer-Vergleich ein `varbinary`-Vergleich, als der CONVERT-Operator der rechten Seite hinzugefügt wurde.</span><span class="sxs-lookup"><span data-stu-id="bcdf2-568">In the above example, when the CONVERT operator was added to the right side, the comparison changed from an integer comparison to a `varbinary` comparison.</span></span>  
  
 <span data-ttu-id="bcdf2-569">![Pfeilsymbol mit dem Link "zurück zum Anfang](media/uparrow16x16.gif "Pfeilsymbol, das mit dem Link „Zurück zum Anfang“ verwendet wird") " [in diesem Handbuch](#Top)</span><span class="sxs-lookup"><span data-stu-id="bcdf2-569">![Arrow icon used with Back to Top link](media/uparrow16x16.gif "Arrow icon used with Back to Top link") [In This Guide](#Top)</span></span>  
  
##  <a name="additional-reading"></a><a name="Additional_Reading"></a> <span data-ttu-id="bcdf2-570">Zusätzliches Lesematerial</span><span class="sxs-lookup"><span data-stu-id="bcdf2-570">Additional Reading</span></span>  

 <span data-ttu-id="bcdf2-571">[Verbessern der Leistung mit indizierten Sichten in SQL Server 2008](https://msdn.microsoft.com/library/dd171921(v=sql.100).aspx)</span><span class="sxs-lookup"><span data-stu-id="bcdf2-571">[Improving Performance with SQL Server 2008 Indexed Views](https://msdn.microsoft.com/library/dd171921(v=sql.100).aspx)</span></span>  
  
 [<span data-ttu-id="bcdf2-572">Partitionierte Tabellen und Indizes</span><span class="sxs-lookup"><span data-stu-id="bcdf2-572">Partitioned Tables and Indexes</span></span>](../relational-databases/partitions/partitioned-tables-and-indexes.md)  
  
  
