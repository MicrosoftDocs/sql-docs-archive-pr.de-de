---
title: Referenz zu logischen und physischen Showplanoperatoren | Microsoft-Dokumentation
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
f1_keywords:
- sql12.swb.showplan.nestedloops.f1
- sql12.swb.showplan.dynamic.f1
- sql12.swb.showplan.tableinsert.f1
- sql12.swb.showplan.remoteinsert.f1
- sql12.swb.showplan.lazyspool.f1
- sql12.swb.showplan.RIDLookup
- sql12.swb.showplan.hashmatchteam.f1
- sql12.swb.showplan.tablespool.f1
- sql12.swb.showplan.print.f1
- sql12.swb.showplan.clusteredindexupdate.f1
- sql12.swb.showplan.assert.f1
- sql12.swb.showplan.columnstoreindexscan.f1
- sql12.swb.showplan.tablevaluedfunction.f1
- sql12.swb.showplan.split.f1
- sql12.swb.showplan.union.f1
- sql12.swb.showplan.clusteredindexseek.f1
- sql12.swb.showplan.indexspool.f1
- sql12.swb.showplan.indexinsert.f1
- sql12.swb.showplan.clusteredindexscan.f1
- sql12.swb.showplan.buildhash.f1
- sql12.swb.showplan.clusteredindexmerge.f1
- sql12.swb.showplan.sequence.f1
- sql12.swb.showplan.hashmatchroot.f1
- sql12.swb.showplan.columnstoreindexupdate.f1
- sql12.swb.showplan.rightsemijoin.f1
- sql12.swb.showplan.fetchquery.f1
- sql12.swb.showplan.distinct.f1
- sql12.swb.showplan.hashmatch.f1
- sql12.swb.showplan.segment.f1
- sql12.swb.showplan.top.f1
- sql12.swb.showplan.columnstoreindexdelete.f1
- sql12.swb.showplan.gatherstreams.f1
- sql12.swb.showplan.remotedelete.f1
- sql12.swb.showplan.insert.f1
- sql12.swb.showplan.declare.f1
- sql12.swb.showplan.snapshot.f1
- sql12.swb.showplan.assign.f1
- sql12.swb.showplan.intrinsic.f1
- sql12.swb.showplan.mergejoin.f1
- sql12.swb.showplan.concatenation.f1
- sql12.swb.showplan.rowcountspool.f1
- sql12.swb.showplan.parametertablescan.f1
- sql12.swb.showplan.indexscan.f1
- sql12.swb.showplan.while.f1
- sql12.swb.showplan.columnstoreindexinsert.f1
- sql12.swb.showplan.tablemerge.f1
- sql12.swb.showplan.spool.f1
- sql12.swb.showplan.streamaggregate.f1
- sql12.swb.showplan.update.f1
- sql12.swb.showplan.innerjoin.f1
- sql12.swb.showplan.flowdistinct.f1
- sql12.swb.showplan.tableupdate.f1
- sql12.swb.showplan.result.f1
- sql12.swb.showplan.bitmap.f1
- sql12.swb.showplan.remoteindexseek.f1
- sql12.swb.showplan.populationquery.f1
- sql12.swb.showplan.rightouterjoin.f1
- sql12.swb.showplan.columnstoreindexmerge.f1
- sql12.swb.showplan.remotescan.f1
- sql12.swb.showplan.remoteupdate.f1
- sql12.swb.showplan.keyset.f1
- sql12.swb.showplan.collapse.f1
- sql12.swb.showplan.arithmeticexpression.f1
- sql12.swb.showplan.clusteredindexinsert.f1
- sql12.swb.showplan.computescalar
- sql12.swb.showplan.sort.f1
- sql12.swb.showplan.locate.f1
- sql12.swb.showplan.constantscan.f1
- sql12.swb.showplan.computescalar.f1
- sql12.swb.showplan.indexseek.f1
- sql12.swb.showplan.leftsemijoin.f1
- sql12.swb.showplan.leftantisemijoin.f1
- sql12.swb.showplan.fullouterjoin.f1
- sql12.swb.showplan.filter.f1
- sql12.swb.showplan.indexdelete.f1
- sql12.swb.showplan.repartitionstreams.f1
- sql12.swb.showplan.crossjoin.f1
- sql12.swb.showplan.mergeinterval.f1
- sql12.swb.showplan.bookmarklookup.f1
- sql12.swb.showplan.convert.f1
- sql12.swb.showplan.refreshquery.f1
- sql12.swb.showplan.distinctsort.f1
- sql12.swb.showplan.leftouterjoin.f1
- sql12.swb.showplan.rightantisemijoin.f1
- sql12.swb.showplan.deletedscan.f1
- sql12.swb.showplan.udx.f1
- sql12.swb.showplan.broadcast.f1
- sql12.swb.showplan.delete.f1
- sql12.swb.showplan.aggregate.f1
- sql12.swb.showplan.setfunction.f1
- sql12.swb.showplan.switch.f1
- sql12.swb.showplan.remoteindexscan.f1
- sql12.swb.showplan.eagerspool.f1
- sql12.swb.showplan.indexupdate.f1
- sql12.swb.showplan.keylookup.f1
- sql12.swb.showplan.branchrepartition.f1
- sql12.swb.showplan.rank.f1
- sql12.swb.showplan.tablescan.f1
- sql12.swb.showplan.distributestreams.f1
- sql12.swb.showplan.logrowscan.f1
- sql12.swb.showplan.parallelism.f1
- sql12.swb.showplan.bitmapcreate.f1
- sql12.swb.showplan.insertedscan.f1
- sql12.swb.showplan.tabledelete.f1
- sql12.swb.showplan.clusteredindexdelete.f1
- sql12.swb.showplan.remotequery.f1
- sql12.swb.showplan.if.f1
- sql12.swb.showplan.cache.f1
- sql12.swb.showplan.partialaggregate.f1
- sql12.swb.showplan.sql.f1
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
author: rothja
ms.author: jroth
ms.openlocfilehash: bc45a5fa14785294093385e6f90b47a8bdb6dff3
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/04/2020
ms.locfileid: "87717689"
---
# <a name="showplan-logical-and-physical-operators-reference"></a>Referenz zu logischen und physischen Showplanoperatoren
  Operatoren beschreiben, wie eine Abfrage oder eine DML-Anweisung (Data Manipulation Language) in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] ausgeführt wird. Der Abfrageoptimierer verwendet Operatoren, um einen Abfrageplan für das in der Abfrage angegebene Ergebnis zu erstellen, oder zum Ausführen des in der DML-Anweisung angegebenen Vorgangs. Der Abfrageplan ist eine Struktur, die aus physischen Operatoren besteht. Sie können den Abfrageplan mit den SET SHOWPLAN-Anweisungen, den grafischen Ausführungsplanoptionen in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], oder den SQL Server Profiler Showplan-Ereignisklassen anzeigen.  
  
 Operatoren werden als logische und physische Operatoren klassifiziert.  
  
 **Logische Operatoren**  
 Logische Operatoren beschreiben den relationalen algebraischen Vorgang, der für die Anweisungsverarbeitung verwendet wird. Mit anderen Worten, logische Operatoren beschreiben konzeptionell den auszuführenden Vorgang.  
  
 **Physische Operatoren**  
 Physische Operatoren implementieren den durch logische Operatoren beschriebenen Vorgang. Jeder physische Operator ist ein Objekt oder eine Routine, das bzw. die einen Vorgang ausführt. Einige Operatoren greifen z. B. auf Spalten oder Zeilen einer Tabelle, eines Index oder einer Sicht zu. Andere physische Operatoren führen andere Vorgänge aus, z. B. Berechnungen, Aggregationen, Datenintegritätsprüfungen oder Joins. Physischen Operatoren sind Kosten zugeordnet.  
  
 Über die physischen Operatoren werden Daten initialisiert, aufgelistet und beendet. Der physische Operator kann insbesondere die folgenden drei Methodenaufrufe beantworten:  
  
-   **Init():** Mit der Methode **Init()** wird ein physischer Operator initialisiert und dazu angewiesen, erforderliche Datenstrukturen einzurichten. Der physische Operator kann mehrere **Init()** -Aufrufe empfangen; in der Regel empfängt er jedoch nur einen.  
  
-   **GetNext():** Mit der Methode **GetNext()** wird ein Operator angewiesen, die erste oder nächste Datenzeile abzurufen. Der physische Operator kann null oder mehrere **GetNext()** -Aufrufe empfangen.  
  
-   **Close():** Mit der Methode **Close()** wird der physische Operator dazu angewiesen, einige Cleanupvorgänge auszuführen und sich selbst zu beenden. Ein physischer Operator empfängt nur einen **Close()** -Aufruf.  
  
 Die **GetNext()**-Methode gibt eine Datenzeile zurück, und die Anzahl der Aufrufe wird als **ActualRows** in der durch SET STATISTICS PROFILE ON oder SET STATISTICS XML ON erstellten Showplanausgabe angezeigt. Weitere Informationen zu diesen SET-Optionen finden Sie unter [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) und [SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql).  
  
 Die **ActualRebinds**- und **ActualRewinds**-Zähler, die in der Showplanausgabe angezeigt werden, beziehen sich auf die Anzahl der Aufrufe der **Init()** -Methode. **ActualRebinds** entspricht 1 und **ActualRewinds** entspricht 0, es sei denn, ein Operator befindet sich innerhalb eines Schleifenjoins. Wenn sich ein Operator innerhalb eines Schleifenjoins befindet, muss die Summe der erneuten Bindungen und Zurückspulvorgänge der Anzahl der verarbeiteten Vorgänge außerhalb des Joins entsprechen. Unter 'erneuter Bindung' wird verstanden, dass sich mindestens ein korrelierter Parameter des Joins geändert hat und daher das Innere des Joins neu ausgewertet werden muss. Unter 'Zurückspulvorgang' wird verstanden, dass sich keiner der korrelierten Parameter geändert hat und das vorherige innere Resultset daher wiederverwendet werden kann.  
  
 **ActualRebinds** und **ActualRewinds** sind in der mithilfe von SET STATISTICS XML ON erstellten XML-Showplanausgabe vorhanden. Sie werden nur für die Operatoren **Nonclustered Index Spool**, `Remote Query` , **Row Count Spool**, `Sort` **Table Spool**und **Table-Wert Function** aufgefüllt. **Actualrebindungen** und **ActualRewinds** können auch für den `Assert` -Operator und den- **Filter** -Operator aufgefüllt werden, wenn das **StartupExpression** -Attribut auf true festgelegt ist.  
  
 Wenn **ActualRebinds** und **ActualRewinds** in einem XML-Showplan vorhanden sind, können sie mit **EstimateRebinds** und **EstimateRewinds**verglichen werden. Wenn sie nicht vorhanden sind, kann die geschätzte Zeilenanzahl (**EstimateRows**) mit der tatsächlichen Zeilenanzahl (**ActualRows**) verglichen werden. Beachten Sie, dass die tatsächliche grafische Showplanausgabe für tatsächliche erneute Bindungen und Zurückspulvorgänge Nullen anzeigt, wenn letztere nicht vorhanden sind.  
  
 Ein entsprechender Zähler, **ActualEndOfScans**, ist verfügbar, wenn die Showplanausgabe mithilfe von SET STATISTICS XML ON erstellt wird. Wenn ein physischer Operator das Ende seines Datenstroms erreicht, wird dieser Zähler um 1 erhöht. Wenn ein physischer Operator das Ende seines Datenstroms erreicht, wird dieser Zähler um 1 erhöht. Wie bei erneuten Bindungen und Zurückspulvorgängen kann die Anzahl für das Scanende größer als 1 sein; aber nur, wenn sich der Operator innerhalb eines Schleifenjoins befindet. Die Anzahl für Scanende muss kleiner oder gleich der Summe der erneuten Bindungen und Zurückspulvorgänge sein.  
  
## <a name="mapping-physical-and-logical-operators"></a>Zuordnen von physischen und logischen Operatoren  
 Der Abfrageoptimierer erstellt einen Abfrageplan als Struktur, die aus logischen Operatoren besteht. Nach dem Erstellen des Abfrageplans wählt der Abfrageoptimierer für jeden logischen Operator den effizientesten physischen Operator aus. Der Abfrageoptimierer entscheidet auf Basis der Kosten, welcher physischer Operator einen logischen Operator implementieren soll.  
  
 Normalerweise kann ein logischer Vorgang von mehreren physischen Operatoren implementiert werden. Ein physischer Operator kann jedoch in seltenen Fällen mehrere logische Vorgänge implementieren.  
  
## <a name="operator-descriptions"></a>Beschreibung der Operatoren  
 In diesem Abschnitt finden Sie Beschreibungen der logischen und physischen Operatoren.  
  
|Symbol für grafischen Ausführungsplan|Showplanoperator|BESCHREIBUNG|  
|-----------------------------------|-----------------------|-----------------|  
|Keine|`Aggregate`|Mit dem `Aggregate`-Operator wird ein Ausdruck berechnet, der MIN, MAX, SUM, COUNT oder AVG enthält. Der `Aggregate`-Operator kann ein logischer oder physischer Operator sein.|  
|![Operator für arithmetische Ausdrücke (Symbol)](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Operator für arithmetische Ausdrücke (Symbol)")|`Arithmetic Expression`|Der `Arithmetic Expression`-Operator berechnet einen neuen Wert anhand vorhandener Werte in einer Zeile. `Arithmetic Expression` wird in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] nicht verwendet.|  
|![Assert-Operator (Symbol)](../../2014/database-engine/media/assert-32x.gif "Assert-Operator (Symbol)")|`Assert`|Der `Assert`-Operator überprüft eine Bedingung. Beispielsweise überprüft er die referenzielle Integrität, oder er stellt sicher, dass eine skalare Unterabfrage eine Zeile zurückgibt. Für jede Eingabezeile wertet der- `Assert` Operator den Ausdruck in der- `Argument` Spalte des Ausführungs Plans aus. Wird der Ausdruck mit NULL ausgewertet, so wird die Zeile an den `Assert`-Operator übergeben, und die Ausführung der Abfrage wird fortgesetzt. Wird dieser Ausdruck zu einem Nicht-NULL-Wert ausgewertet, so wird der entsprechende Fehler ausgelöst. Der `Assert`-Operator ist ein physischer Operator.|  
|![Assign-Sprachelement (Symbol)](../../2014/database-engine/media/assign-32.gif "Assign-Sprachelement (Symbol)")|`Assign`|Der `Assign`-Operator weist einer Variablen den Wert eines Ausdrucks oder einer Konstanten zu. `Assign` ist ein Sprachelement.|  
|Keine|`Asnyc Concat`|Der `Asnyc Concat`-Operator wird nur in Remoteabfragen (verteilten Abfragen) verwendet. Diese Anweisung weist *n* untergeordnete Knoten und einen übergeordneten Knoten auf. Gewöhnlich sind manche untergeordnete Knoten Remotecomputer, die an einer verteilten Abfrage beteiligt sind. `Asnyc Concat` gibt `open()`-Aufrufe für alle untergeordneten Knoten gleichzeitig aus und wendet dann auf jeden untergeordneten Knoten eine Bitmap an. Für jedes Bit, das 1 ist, sendet `Async Concat` auf Anfrage die Ausgabezeilen an den übergeordneten Knoten.|  
|![Bitmap-Operator (Symbol)](../../2014/database-engine/media/bitmap-32x.gif "Bitmap-Operatorsymbol")|`Bitmap`|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]verwendet den- `Bitmap` Operator, um das Filtern von Bitmaps in parallelen Abfrage Plänen zu implementieren. Durch das Filtern von Bitmaps wird die Ausführung der Abfrage beschleunigt, indem Zeilen mit Schlüsselwerten eliminiert werden, die keine joindatensätze ausgeben können, bevor Zeilen durch einen anderen Operator wie den Operator übergeben werden `Parallelism` Ein Bitmapfilter verwendet eine kompakte Darstellung einer Gruppe von Werten aus einer Tabelle in einem Bereich der Operatorstruktur, um Zeilen aus einer zweiten Tabelle in einem anderen Bereich der Struktur zu filtern. Durch das Entfernen unnötiger Zeilen zu einem frühen Zeitpunkt in der Abfrage müssen nachfolgende Operatoren weniger Zeilen verarbeiten, wodurch eine Steigerung der Gesamtleistung der Abfrage erzielt werden kann. Der Optimierer bestimmt, wann eine Bitmap eine ausreichende Selektivität aufweist, damit sie verwendet werden kann, und in welchen Operatoren der Filter angewendet wird. `Bitmap` ist ein physischer Operator.|  
|![Bitmap-Operator (Symbol)](../../2014/database-engine/media/bitmap-32x.gif "Bitmap-Operatorsymbol")|`Bitmap Create`|Der `Bitmap Create`-Operator wird in der Showplanausgabe dort angezeigt, wo Bitmaps erstellt werden. `Bitmap Create` ist ein logischer Operator.|  
|![Bookmark Lookup-Operator (Symbol)](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark Lookup-Operator (Symbol)")|`Bookmark Lookup`|Der `Bookmark Lookup`-Operator verwendet ein Lesezeichen (Zeilen-ID oder Gruppierungsschlüssel), um die zugehörige Zeile in der Tabelle oder im gruppierten Index nachzuschlagen. Die `Argument` Spalte enthält die Lesezeichen Bezeichnung, mit der die Zeile in der Tabelle oder im gruppierten Index gesucht wird. Die `Argument` Spalte enthält auch den Namen der Tabelle oder des gruppierten Indexes, in der die Zeile gesucht wird. Wenn die with Prefetch-Klausel in der- `Argument` Spalte angezeigt wird, hat der Abfrage Prozessor ermittelt, dass es optimal ist, beim Suchen von Lesezeichen in der Tabelle oder im gruppierten Index das asynchrone vorab abrufen (Read-Ahead) zu verwenden.<br /><br /> `Bookmark Lookup` wird in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] nicht verwendet. `Clustered Index Seek` und `RID Lookup` stellen hingegen Suchfunktionen für Lesezeichen bereit. Auch der `Key Lookup`-Operator stellt diese Funktionalität bereit.|  
|Keine|`Branch Repartition`|Ein paralleler Abfrageplan kann mitunter logische Bereiche von Iteratoren enthalten. Alle Iteratoren innerhalb eines solchen Bereichs können durch parallele Threads ausgeführt werden. Die Bereiche selbst müssen seriell ausgeführt werden. Einige der `Parallelism`-Iteratoren innerhalb eines einzelnen Bereichs werden `Branch Repartition` genannt. Der `Parallelism`-Iterator an der Grenze zwischen zwei Bereichen wird `Segment Repartition` genannt. `Branch Repartition` und `Segment Repartition` sind logische Operatoren.|  
|Keine|`Broadcast`|`Broadcast`weist einen untergeordneten Knoten und *n* übergeordnete Knoten auf. `Broadcast` sendet die Eingabezeilen bei Bedarf an mehrere Consumer. Jeder Consumer erhält alle Zeilen. Wenn z.B. alle Consumer sich auf der Erstellungsseite eines Hashjoins befinden, werden *n* Kopien der Hashtabellen erstellt.|  
|![Build Hash-Operator (Symbol)](../../2014/database-engine/media/build-hash.gif "Build Hash-Operator (Symbol)")|`Build Hash`|Gibt die Erstellung einer Batchhashtabelle für einen speicheroptimierten xVelocity-columnstore-Index an.|  
|Keine|`Cache`|`Cache`ist eine spezialisierte Version des **Spool** -Operators. Er speichert nur eine Datenzeile. `Cache` ist ein logischer Operator. `Cache` wird in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] nicht verwendet.|  
|![Clustered Index Delete-Operator (Symbol)](../../2014/database-engine/media/clustered-index-delete-32x.gif "Clustered Index Delete-Operator (Symbol)")|`Clustered Index Delete`|Der `Clustered Index Delete`-Operator löscht Zeilen aus dem gruppierten Index, der in der Argument-Spalte des Abfrageausführungsplans angegeben ist. Wenn ein WHERE:()-Prädikat in der Argument-Spalte vorhanden ist, werden nur die Zeilen gelöscht, die das Prädikat erfüllen.`Clustered Index Delete`  ist ein physischer Operator.|  
|![Clustered Index Insert-Operator (Symbol)](../../2014/database-engine/media/clustered-index-insert-32x.gif "Clustered Index Insert-Operator (Symbol)")|`Clustered Index Insert`|Der `Clustered Index Insert`-Showplanoperator fügt die Eingabezeilen in den gruppierten Index ein, der in der Argument-Spalte angegeben ist. Die Argument-Spalte enthält auch ein SET:()-Prädikat, das den für die einzelnen Spalten festgelegten Wert anzeigt. Wenn `Clustered Index Insert` keine untergeordneten Elemente für Einfügewerte aufweist, wird die eingefügte Zeile aus dem `Insert` Operator selbst übernommen.`Clustered Index Insert`  ist ein physischer Operator.|  
|![Clustered Index Merge-Operator](../../2014/database-engine/media/clustered-index-merge-32x.gif "Clustered Index Merge-Operator")|**Clustered Index Merge**|Der **Clustered Index Merge** -Operator übernimmt einen Mergedatenstrom für einen gruppierten Index. Der-Operator löscht oder aktualisiert Zeilen aus dem gruppierten Index, der in der-Spalte des-Operators angegeben ist, oder fügt diese Zeilen ein `Argument` . Der tatsächlich ausgeführte Vorgang hängt vom Lauf Zeitwert der **Aktions** Spalte ab, die in der- `Argument` Spalte des-Operators angegeben ist. **Clustered Index Merge** ist ein physischer Operator.|  
|![Clustered Index Scan-Operator (Symbol)](../../2014/database-engine/media/clustered-index-scan-32x.gif "Clustered Index Scan-Operator (Symbol)")|`Clustered Index Scan`|Der `Clustered Index Scan`-Operator scannt den gruppierten Index, der in der Argument-Spalte des Abfrageausführungsplans angegeben ist. Wenn ein optionales WHERE:()-Prädikat vorhanden ist, werden nur die Zeilen zurückgegeben, die das Prädikat erfüllen. Wenn die Argument-Spalte die ORDERED-Klausel enthält, hat der Abfrageprozessor angefordert, dass die Ausgabe der Zeilen in der Reihenfolge zurückgegeben wird, in der sie vom gruppierten Index sortiert wurden. Wurde die ORDERED-Klausel nicht angegeben, scannt die Speicher-Engine den Index optimal (wobei die Ausgabe nicht unbedingt sortiert ist). `Clustered Index Scan` ist ein logischer und physischer Operator.|  
|![Clustered Index Seek-Operator (Symbol)](../../2014/database-engine/media/clustered-index-seek-32x.gif "Clustered Index Seek-Operator (Symbol)")|`Clustered Index Seek`|Der `Clustered Index Seek`-Operator verwendet die Suchfunktionen der Indizes, um Zeilen aus einem gruppierten Index abzurufen. Die `Argument` Spalte enthält den Namen des verwendeten gruppierten Indexes und das Seek:()-Prädikat. Die Speicher-Engine verarbeitet mit diesem Index nur die Zeilen, die das SEEK:()-Prädikat erfüllen. Es kann auch ein WHERE:()-Prädikat einschließen, das die Speicher-Engine für alle Zeilen auswertet, die das SEEK:()-Prädikat erfüllen. Dies ist jedoch optional, und es werden keine Indizes für diesen Prozess verwendet.<br /><br /> Wenn die `Argument` Spalte die sortierte Klausel enthält, hat der Abfrage Prozessor ermittelt, dass die Zeilen in der Reihenfolge zurückgegeben werden müssen, in der Sie vom gruppierten Index sortiert wurden. Wurde die ORDERED-Klausel nicht angegeben, durchsucht die Speicher-Engine den Index optimal (wobei die Ausgabe nicht unbedingt sortiert ist). Die Ausgabe in der ursprünglichen Reihenfolge kann weniger effizient sein als die unsortierte Ausgabe. Bei der Anzeige des LOOKUP-Schlüsselworts, wird ein Bookmark Lookup ausgeführt. In [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] und höheren Versionen stellt der- `Key Lookup` Operator die Bookmark Suche-Funktionalität bereit. `Clustered Index Seek` ist ein logischer und physischer Operator.|  
|![Clustered Index Update-Operator (Symbol)](../../2014/database-engine/media/clustered-index-update-32x.gif "Clustered Index Update-Operator (Symbol)")|`Clustered Index Update`|Der- `Clustered Index Update` Operator aktualisiert die Eingabezeilen in dem gruppierten Index, der in der-Spalte angegeben ist `Argument` . Wenn ein WHERE:()-Prädikat vorhanden ist, werden nur die Zeilen aktualisiert, die dieses Prädikat erfüllen. Wenn ein SET:()-Prädikat vorhanden ist, wird jede aktualisierte Spalte auf diesen Wert festgelegt. Wenn ein DEFINE:()-Prädikat vorhanden ist, werden die durch diesen Operator definierten Werte aufgelistet. Auf diese Werte kann in der SET-Klausel oder an anderer Stelle in diesem Operator sowie in dieser Abfrage verwiesen werden. `Clustered Index Update` ist ein logischer und physischer Operator.|  
|![Collapse-Operator (Symbol)](../../2014/database-engine/media/collapse-32x.gif "Collapse-Operator (Symbol)")|`Collapse`|Der `Collapse`-Operator optimiert die Verarbeitung von Aktualisierungen. Eine Aktualisierung kann bei ihrer Ausführung mithilfe des `Split`-Operators in einen Lösch- und einen Einfügevorgang aufgeteilt werden. Die `Argument` Spalte enthält eine Group by:()-Klausel, die eine Liste von Schlüssel Spalten angibt. Wenn der Abfrageprozessor benachbarte Zeilen erkennt, die dieselben Schlüsselwerte löschen und einfügen, werden diese separaten Vorgänge durch einen einzigen effektiveren Updatevorgang ersetzt. `Collapse` ist ein logischer und physischer Operator.|  
|![Columnstore-Indexscan](../../2014/database-engine/media/columnstoreindexscan.gif "Columnstore-Indexscan")|`Columnstore Index Scan`|Der- `Columnstore Index Scan` Operator scannt den columnstore--Index, der in der- `Argument` Spalte des Abfrage Ausführungs Plans angegeben ist.|  
|![Compute Scalar-Operator (Symbol)](../../2014/database-engine/media/compute-scalar-32x.gif "Compute Scalar-Operator (Symbol)")|`Compute Scalar`|Der- `Compute Scalar` Operator wertet einen Ausdruck aus, um einen berechneten skalaren Wert zu erhalten. Dieser kann an den Benutzer zurückgegeben und/oder an anderer Stelle in der Abfrage als Verweis verwendet werden. Ein Beispiel für beide Fälle ist ein Filterprädikat oder Joinprädikat. `Compute Scalar` ist ein logischer und physischer Operator.<br /><br /> `Compute Scalar`Operatoren, die in von SET STATISTICS XML generierten Showplans angezeigt werden, enthalten möglicherweise das- `RunTimeInformation` Element nicht. In grafischen Showplans können **Tatsächliche Zeilen**, **Tatsächlich erneuerte Bindungen**und **Tatsächliche Zurückspulvorgänge** im Fenster **Eigenschaften** fehlen, wenn die Option **Tatsächlichen Ausführungsplan einschließen** in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]aktiviert wurde. Wenn diese Situation eintritt, bedeutet das, dass diese Operatoren zwar im kompilierten Abfrageplan verwendet wurden, ihre Arbeit jedoch von anderen Operatoren im Laufzeitabfrageplan verrichtet wurde. Beachten Sie außerdem, dass die Anzahl der Ausführungen in der von SET STATISTICS PROFILE generierten Showplanausgabe gleich der Summe der erneuten Bindungen und Zurückspulvorgänge in den von SET STATISTICS XML generierten Showplans ist.|  
|![Concatenation-Operator (Symbol)](../../2014/database-engine/media/concatenation-32x.gif "Concatenation-Operator (Symbol)")|**Concatenation**|Der **Concatenation** -Operator scannt mehrere Eingaben und gibt die gescannten Zeilen zurück. **Concatenation** wird im Allgemeinen verwendet, um das [!INCLUDE[tsql](../includes/tsql-md.md)] -Konstrukt UNION ALL zu implementieren. Der physische Operator **Concatenation** verfügt über mindestens zwei Eingaben und eine Ausgabe. Concatenation kopiert Zeilen aus dem ersten Eingabedatenstrom in den Ausgabedatenstrom und wiederholt diese Operation anschließend für jeden weiteren Eingabedatenstrom. **Concatenation** ist sowohl ein logischer als auch ein physischer Operator.|  
|![Constant Scan-Operator (Symbol)](../../2014/database-engine/media/constant-scan-32x.gif "Constant Scan-Operator (Symbol)")|`Constant Scan`|Der- `Constant Scan` Operator führt eine oder mehrere Konstante Zeilen in eine Abfrage ein. Ein- `Compute Scalar` Operator wird häufig nach einem verwendet `Constant Scan` , um einer Zeile, die vom-Operator erzeugt wurde, Spalten hinzuzufügen `Constant Scan` .|  
|![Symbol für Convert-Sprachelement (Datenbank-Engine)](../../2014/database-engine/media/convert-32x.gif "Symbol für Convert-Sprachelement (Datenbank-Engine)")|`Convert`|Der `Convert`-Operator wandelt einen skalaren Datentyp in einen anderen um. `Convert` ist ein Sprachelement.|  
|Keine|`Cross Join`|Der `Cross Join`-Operator verknüpft jede Zeile der ersten (oberen) Eingabe mit jeder Zeile der zweiten (unteren) Eingabe. `Cross Join` ist ein logischer Operator.|  
|![Cursor Catchall-Cursoroperator (Symbol)](../../2014/database-engine/media/cursor-catch-all.gif "Cursor Catchall-Cursoroperator (Symbol)")|`catchall`|Das Sammelsymbol wird angezeigt, wenn von der Logik, die grafische Showplans erzeugt, kein geeignetes Symbol für den Iterator gefunden werden kann. Das Sammelsymbol zeigt nicht notwendigerweise eine Fehlerbedingung an. Es stehen drei Sammelsymbole zur Verfügung: blau (für Iteratoren), orange (für Cursor) und grün (für [!INCLUDE[tsql](../includes/tsql-md.md)] -Sprachelemente).|  
|Keine|**Cursor**|Die logischen und physischen **Cursor** -Operatoren beschreiben, wie eine Abfrage oder Aktualisierung mit Cursoroperationen ausgeführt wird. Die physischen Operatoren beschreiben den Algorithmus, der für die physische Implementierung der Cursorverarbeitung verwendet wird, wie z. B. Verwenden eines keysetgesteuerten Cursors. Jeder Schritt bei der Ausführung eines Cursors benötigt einen physischen Operator. Die logischen Operatoren beschreiben eine Cursoreigenschaft, z. B. der Cursor ist schreibgeschützt.<br /><br /> Zu den logischen Operatoren zählen Asynchronous, Optimistic, Primary, Read Only, Scroll Locks sowie Secondary und Synchronous.<br /><br /> Zu den physischen Operatoren zählen Dynamic, Fetch Query, Keyset, Population Query, Refresh Query und Snapshot.|  
|![Declare-Sprachelement (Symbol)](../../2014/database-engine/media/declare-32x.gif "Declare-Sprachelement (Symbol)")|`Declare`|Der- `Declare` Operator weist eine lokale Variable im Abfrageplan zu. `Declare` ist ein Sprachelement.|  
|![Delete-Operatorsymbol (Datenbank-Engine)](../../2014/database-engine/media/delete-32x.gif "Delete-Operatorsymbol (Datenbank-Engine)")|`Delete`|Der- `Delete` Operator löscht aus den Objekt Zeilen, die das optionale Prädikat in der `Argument` Spalte erfüllen.|  
|![Delete Scan-Operator (Symbol)](../../2014/database-engine/media/delete-scan-32x.gif "Delete Scan-Operator (Symbol)")|`Deleted Scan`|Der `Deleted Scan`-Operator scannt die deleted-Tabelle in einem Trigger.|  
|Keine|`Distinct`|Mithilfe des `Distinct`-Operators werden Duplikate aus einem Rowset oder aus einer Sammlung von Werten entfernt. `Distinct` ist ein logischer Operator.|  
|Keine|`Distinct Sort`|Der `Distinct Sort` logische Operator scannt die Eingabe, entfernt Duplikate und sortiert nach den Spalten, die im eindeutigen Order by:()-Prädikat der `Argument` Spalte angegeben sind. `Distinct Sort` ist ein logischer Operator.|  
|![Distribute Streams Parallelism-Operator (Symbol)](../../2014/database-engine/media/parallelism-distribute-stream.gif "Distribute Streams Parallelism-Operator (Symbol)")|**Distribute Streams**|Der **Distribute Streams** -Operator wird nur in parallelen Abfrageplänen verwendet. Der **Distribute Streams** -Operator nimmt genau einen Eingabedatenstrom von Datensätzen an und erzeugt mehrere Ausgabedatenströme. Inhalt und Format der Datensätze werden nicht geändert. Jeder Datensatz aus dem Eingabedatenstrom wird in genau einem der Ausgabedatenströme angezeigt. Dieser Operator behält die relative Reihenfolge der Eingabedatensätze in den Ausgabedatenströmen bei. In der Regel wird mit einem Hashingverfahren festgelegt, zu welchem Ausgabedatenstrom ein bestimmter Eingabedatensatz gehört.<br /><br /> Wenn die Ausgabe partitioniert ist, enthält die `Argument` Spalte ein Partition columns:()-Prädikat und die Partitionierungs Spalten. **Distribute Streams** ist ein logischer Operator.|  
|![Dynamic-Cursoroperator (Symbol)](../../2014/database-engine/media/dynamic-32x.gif "Dynamic-Cursoroperator (Symbol)")|`Dynamic`|Der `Dynamic`-Operator verwendet einen Cursor, der alle von anderen vorgenommenen Änderungen wahrnimmt.|  
|![Spool-Operator (Symbol)](../../2014/database-engine/media/spool-32x.gif "Spool-Operator (Symbol)")|**Eager Spool**|Der **eifrige Spool** -Operator übernimmt die gesamte Eingabe und speichert jede Zeile in einem verborgenen temporären Objekt, das in der Datenbank gespeichert ist `tempdb` . Wenn der Operator zurückgesetzt wird (z. b. durch einen `Nested Loops` Operator), aber keine erneute Bindung erforderlich ist, werden die gespoolten Daten verwendet, anstatt die Eingabe erneut zu scannen. Wenn eine erneute Zuordnung erforderlich ist, werden die gespoolten Daten gelöscht, und das Spoolobjekt wird durch erneutes Scannen der (neu zugeordneten) Eingabe neu erstellt. Der **Eager Spool** -Operator erstellt seine Spooldatei unverzüglich: Wenn der übergeordnete Operator des Spoolvorgangs die erste Zeile anfordert, verarbeitet der Spool-Operator alle Zeilen aus dem Eingabeoperator und speichert sie im Spool. **Eager Spool** ist ein logischer Operator.|  
|![Fetch Query-Cursoroperator (Symbol)](../../2014/database-engine/media/fetch-query-32x.gif "Fetch Query-Cursoroperator (Symbol)")|`Fetch Query`|Der `Fetch Query`-Operator ruft Zeilen ab, wenn eine Abrufoperation für einen Cursor ausgegeben wird.|  
|![Filter-Operatorsymbol (Datenbank-Engine)](../../2014/database-engine/media/filter-32x.gif "Filter-Operatorsymbol (Datenbank-Engine)")|**Filter**|Der **Filter** -Operator scannt die Eingabe und gibt nur die Zeilen zurück, die den in der Spalte angezeigten Filter Ausdruck (Prädikat) erfüllen `Argument` .|  
|Keine|`Flow Distinct`|Der logische Operator `Flow Distinct` scannt die Eingabe und entfernt Duplikate. Während der- `Distinct` Operator alle Eingaben verarbeitet, bevor eine Ausgabe erzeugt wird, gibt der **flowverschieden** -Operator jede Zeile zurück, wie Sie aus der Eingabe abgerufen wird (es sei denn, diese Zeile ist ein Duplikat, in diesem Fall wird sie verworfen).|  
|Keine|`Full Outer Join`|Der logische `Full Outer Join`-Operator gibt alle Zeilen zurück, die das JOIN-Prädikat aus der ersten (oberen) Eingabe, verknüpft mit jeder Zeile aus der zweiten (unteren) Eingabe, erfüllen. Er gibt außerdem die folgenden Zeilen zurück:<br /><br /> – Zeilen aus der ersten Eingabe, für die in der zweiten Eingabe keine Übereinstimmung besteht.<br /><br /> – Zeilen aus der zweiten Eingabe, für die in der ersten Eingabe keine Übereinstimmung besteht.<br /><br /> <br /><br /> Eingaben, die keine übereinstimmenden Werte enthalten, werden als NULL-Wert zurückgegeben. `Full Outer Join` ist ein logischer Operator.|  
|![Gather Streams Parallelism-Operator (Symbol)](../../2014/database-engine/media/parallelism-32x.gif "Gather Streams Parallelism-Operator (Symbol)")|**Gather Streams**|Der **Gather Streams** -Operator wird nur in parallelen Abfrageplänen verwendet. Der **Gather Streams** -Operator verarbeitet mehrere Eingabedatenströme, fasst diese zusammen und erzeugt genau einen Ausgabedatenstrom von Datensätzen. Inhalt und Format der Datensätze werden nicht geändert. Wenn dieser Operator die Reihenfolge beibehalten soll, müssen alle Eingabedatenströme entsprechend geordnet vorliegen. Wenn die Ausgabe sortiert ist, `Argument` enthält die Spalte ein Order by:()-Prädikat und die Namen der Spalten, die sortiert werden. **Gather Streams** ist ein logischer Operator.|  
|![Hash Match-Operator (Symbol)](../../2014/database-engine/media/hash-match-32x.gif "Hash Match-Operator (Symbol)")|`Hash Match`|Der `Hash Match`-Operator erzeugt eine Hashtabelle, indem er für jede Zeile der Erstellungseingabe einen Hashwert berechnet. Ein Hash:()-Prädikat mit einer Liste von Spalten, die zum Erstellen eines Hashwerts verwendet wird, wird in der- `Argument` Spalte angezeigt. Anschließend wird, soweit möglich, für jede Einfügezeile ein Hashwert (mithilfe derselben Hashfunktion) berechnet und in der Hashtabelle nach Übereinstimmungen gesucht. Wenn ein Rest-Prädikat vorhanden ist (identifiziert durch "Rest:()" in der `Argument` Spalte), muss dieses Prädikat ebenfalls erfüllt sein, damit Zeilen als Übereinstimmung angesehen werden. Das Verhalten des Operators hängt von dem auszuführenden logischen Vorgang ab:<br /><br /> Für jeden Join wird die erste (obere) Eingabe verwendet, um die Hashtabelle zu erstellen, und die zweite (untere) Eingabe zum Einfügen in die Hashtabelle. Die Ausgabeübereinstimmungen (oder Nichtübereinstimmungen) werden vom Jointyp bestimmt. Wenn mehrere Joins dieselbe Joinspalte verwenden, werden diese Vorgänge in einem Hashteam gruppiert.<br /><br /> Für die Operatoren Distinct oder Aggregate wird die Eingabe verwendet, um die Hashtabelle zu erstellen (wobei Duplikate entfernt und Aggregatausdrücke berechnet werden). Wenn die Hashtabelle erstellt ist, wird die Tabelle gescannt, und alle Einträge werden ausgegeben.<br /><br /> Für den Union-Operator wird die erste Eingabe verwendet, um die Hashtabelle zu erstellen (wobei Duplikate entfernt werden). Die zweite Eingabe (die keine Duplikate haben darf) wird zum Einfügen in die Hashtabelle verwendet, wobei alle nicht übereinstimmenden Zeilen zurückgegeben werden, anschließend wird die Hashtabelle gescannt, und alle Einträge werden zurückgegeben.<br /><br /> <br /><br /> `Hash Match` ist ein physischer Operator.|  
|![If-Sprachelement (Symbol)](../../2014/database-engine/media/if-32x.gif "If-Sprachelement (Symbol)")|`If`|Der `If`-Operator führt eine bedingte Verarbeitung basierend auf einem Ausdruck aus. `If` ist ein Sprachelement.|  
|Keine|`Inner Join`|Der logische `Inner Join`-Operator gibt alle Zeilen zurück, die die Verknüpfung der ersten (oberen) Eingabe mit der zweiten (unteren) Eingabe erfüllen.|  
|![Insert-Operatorsymbol (Datenbank-Engine)](../../2014/database-engine/media/insert-32x.gif "Insert-Operatorsymbol (Datenbank-Engine)")|`Insert`|Der `Insert` logische Operator fügt jede Zeile aus der Eingabe in das-Objekt ein, das in der-Spalte angegeben ist `Argument` . Der physische Operator ist entweder der Operator `Table Insert`, `Index Insert` oder `Clustered Index Insert`.|  
|![Inserted Scan-Operator (Symbol)](../../2014/database-engine/media/inserted-scan-32x.gif "Inserted Scan-Operator (Symbol)")|**Inserted Scan**|Der **Inserted Scan** -Operator scannt die **inserted** -Tabelle. **Inserted Scan** ist sowohl ein logischer als auch ein physischer Operator.|  
|![Intrinsic-Sprachelement (Symbol)](../../2014/database-engine/media/intrinsic-32x.gif "Intrinsic-Sprachelement (Symbol)")|`Intrinsic`|Der `Intrinsic`-Operator ruft eine interne [!INCLUDE[tsql](../includes/tsql-md.md)]-Funktion auf. `Intrinsic` ist ein Sprachelement.|  
|![Iterator Catchall-Operator (Symbol)](../../2014/database-engine/media/iterator-catch-all.gif "Iterator Catchall-Operator (Symbol)")|`Iterator`|Das `Iterator`-Sammelsymbol wird angezeigt, wenn von der Logik, die grafische Showplans erzeugt, kein geeignetes Symbol für den Iterator gefunden werden kann. Das Sammelsymbol zeigt nicht notwendigerweise eine Fehlerbedingung an. Es stehen drei Sammelsymbole zur Verfügung: blau (für Iteratoren), orange (für Cursor) und grün (für [!INCLUDE[tsql](../includes/tsql-md.md)] -Sprachkonstrukte).|  
|![Bookmark Lookup-Operator (Symbol)](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark Lookup-Operator (Symbol)")|`Key Lookup`|Der- `Key Lookup` Operator ist eine Lesezeichen Suche für eine Tabelle mit einem gruppierten Index. Die `Argument` Spalte enthält den Namen des gruppierten Indexes und den gruppierten Schlüssel, der zum Nachschlagen der Zeile im gruppierten Index verwendet wird. `Key Lookup`wird immer von einem- `Nested Loops` Operator begleitet. Wenn die with Prefetch-Klausel in der- `Argument` Spalte angezeigt wird, hat der Abfrage Prozessor ermittelt, dass das asynchrone vorab abrufen (Read-Ahead) beim Suchen von Lesezeichen im gruppierten Index optimal verwendet werden kann.<br /><br /> Die Verwendung eines- `Key Lookup` Operators in einem Abfrageplan gibt an, dass die Abfrage möglicherweise von der Leistungsoptimierung profitiert. Beispielsweise kann die Leistung durch Hinzufügen eines abdeckenden Indexes optimiert werden.|  
|![Keyset-Cursoroperator (Symbol)](../../2014/database-engine/media/keyset-32x.gif "Keyset-Cursoroperator (Symbol)")|`Keyset`|Der `Keyset`-Operator verwendet einen Cursor, für den Aktualisierungen, jedoch keine von anderen vorgenommenen Einfügungen, sichtbar sind.|  
|![Language Element Catchall-Operator (Symbol)](../../2014/database-engine/media/language-construct-catch-all.gif "Language Element Catchall-Operator (Symbol)")|`Language Element`|Das `Language Element`-Sammelsymbol wird angezeigt, wenn von der Logik, die grafische Showplans erzeugt, kein geeignetes Symbol für den Iterator gefunden werden kann. Das Sammelsymbol zeigt nicht notwendigerweise eine Fehlerbedingung an. Es stehen drei Sammelsymbole zur Verfügung: blau (für Iteratoren), orange (für Cursor) und grün (für [!INCLUDE[tsql](../includes/tsql-md.md)] -Sprachkonstrukte).|  
|![Spool-Operator (Symbol)](../../2014/database-engine/media/spool-32x.gif "Spool-Operator (Symbol)")|**Lazy Spool**|Der logische Operator **Lazy Spool** speichert jede Zeile aus der Eingabe in einem verborgenen temporären Objekt, das in der Datenbank gespeichert ist `tempdb` . Wenn der Operator zurückgesetzt wird (z. b. durch einen `Nested Loops` Operator), aber keine erneute Bindung erforderlich ist, werden die gespoolten Daten verwendet, anstatt die Eingabe erneut zu scannen. Wenn eine erneute Zuordnung erforderlich ist, werden die gespoolten Daten gelöscht, und das Spoolobjekt wird durch erneutes Scannen der (neu zugeordneten) Eingabe neu erstellt. Der **Lazy Spool** -Operator erstellt seine Spooldatei mit Verzögerung. Das bedeutet, dass der Spooloperator jedes Mal, wenn der übergeordnete Operator des Spoolvorgangs eine Zeile anfordert, eine Zeile aus seinem Eingabeoperator erhält und sie im Spool speichert, anstatt alle Zeilen gleichzeitig zu verarbeiten. Lazy Spool ist ein logischer Operator.|  
|Keine|`Left Anti Semi Join`|Der `Left Anti Semi Join`-Operator gibt jede Zeile aus der ersten (oberen) Eingabe zurück, für die keine übereinstimmende Zeile in der zweiten (unteren) Eingabe vorhanden ist. Wenn kein Joinprädikat in der Spalte vorhanden ist `Argument` , ist jede Zeile eine übereinstimmende Zeile. `Left Anti Semi Join` ist ein logischer Operator.|  
|Keine|`Left Outer Join`|Der `Left Outer Join`-Operator gibt alle Zeilen zurück, die die Verknüpfung der ersten (oberen) Eingabe mit der zweiten (unteren) Eingabe erfüllen. Er gibt auch alle Zeilen aus der ersten Eingabe zurück, für die keine übereinstimmende Zeile in der zweiten Eingabe vorhanden ist. Die nicht übereinstimmenden Zeilen in der zweiten Eingabe werden als NULL-Werte zurückgegeben. Wenn kein Joinprädikat in der Spalte vorhanden ist `Argument` , ist jede Zeile eine übereinstimmende Zeile. `Left Outer Join` ist ein logischer Operator.|  
|Keine|`Left Semi Join`|Der Operator `Left Semi Join` gibt jede Zeile aus der ersten (oberen) Eingabe zurück, für die eine übereinstimmende Zeile in der zweiten (unteren) Eingabe vorhanden ist. Wenn kein Joinprädikat in der Spalte vorhanden ist `Argument` , ist jede Zeile eine übereinstimmende Zeile. `Left Semi Join` ist ein logischer Operator.|  
|![Log Row Scan-Operator (Symbol)](../../2014/database-engine/media/log-row-scan-32x.gif "Log Row Scan-Operator (Symbol)")|`Log Row Scan`|Der `Log Row Scan`-Operator scannt das Transaktionsprotokoll. `Log Row Scan` ist ein logischer und physischer Operator.|  
|![Merge Interval-Operator (Symbol)](../../2014/database-engine/media/merge-interval-32x.gif "Merge Interval-Operator (Symbol)")|`Merge Interval`|Der Operator `Merge Interval` führt mehrere (möglicherweise überlappende) Intervalle zusammen, um minimale, nicht überlappende Intervalle zu erzeugen, die anschließend zum Suchen von Indexeinträgen verwendet werden. Dieser Operator erscheint in der Regel über einem oder mehreren `Compute Scalar` Operatoren über `Constant Scan` Operatoren, die die Intervalle (dargestellt als Spalten in einer Zeile) erstellen, die dieser Operator zusammenführt. `Merge Interval` ist ein logischer und physischer Operator.|  
|![Merge Join-Operator (Symbol)](../../2014/database-engine/media/merge-join-32x.gif "Merge Join-Operator (Symbol)")|**Merge Join**|Der **Merge Join** -Operator führt die logischen Vorgänge „innere Verknüpfung“, „linke äußere Verknüpfung“, „linke Semiverknüpfung“, „linke Antisemiverknüpfung“, „rechte äußere Verknüpfung“, „rechte Semiverknüpfung“, „rechte Antisemiverknüpfung“ und „Vereinigung“ aus.<br /><br /> In der- `Argument` Spalte enthält der **Merge Join** -Operator ein Merge:()-Prädikat, wenn der Vorgang einen 1: n-Join ausführt, oder ein many-to-many Merge:()-Prädikat, wenn der Vorgang einen m:n-Join ausführt. Die `Argument` Spalte enthält auch eine durch Trennzeichen getrennte Liste von Spalten, die zum Ausführen des Vorgangs verwendet werden. Der **Merge Join** -Operator benötigt zwei Eingaben, die nach den jeweiligen Spalten sortiert sind, möglicherweise durch Einfügen von expliziten Sortiervorgängen in den Abfrageplan. Ein Zusammenführungsjoin ist vor allem effizient, wenn kein expliziter Sortiervorgang erforderlich ist, beispielsweise wenn ein geeigneter B-Struktur-Index in der Datenbank vorhanden ist oder die Datenbank für mehrere Vorgänge, z. B. ein Zusammenführungsjoin und Gruppierung mit Rollup, verwendet werden kann. Bei**Merge Join** handelt es sich um einen physischen Operator.|  
|![Nested Loops-Operator (Symbol)](../../2014/database-engine/media/nested-loops-32x.gif "Nested Loops-Operator (Symbol)")|`Nested Loops`|Der `Nested Loops`-Operator führt die logischen Operationen Inner Join, Left Outer Join, Left Semi Join und Left Anti Semi Join aus. Nested Loops-Joins führen für jede Zeile der äußeren Tabelle eine Suche in der inneren Tabelle aus, in der Regel mithilfe eines Indexes. Der Abfrageprozessor legt auf der Grundlage der geschätzten Kosten fest, ob die äußere Eingabe sortiert werden soll, um die Treffsicherheit der Suchvorgänge auf dem Index über die innere Eingabe zu verbessern. Alle Zeilen, die das (optionale) Prädikat in der `Argument` Spalte erfüllen, werden auf der Grundlage der ausgeführten logischen Operation als anwendbar zurückgegeben. `Nested Loops` ist ein physischer Operator.|  
|![Nonclustered Index Delete-Operator (Symbol)](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Nonclustered Index Delete-Operator (Symbol)")|`Nonclustered Index Delete`|Der- `Nonclustered Index Delete` Operator löscht Eingabezeilen aus dem nicht gruppierten Index, der in der-Spalte angegeben ist `Argument` . `Nonclustered Index Delete` ist ein physischer Operator.|  
|![Nonclustered Index Insert-Operator (Symbol)](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Nonclustered Index Insert-Operator (Symbol)")|`Index Insert`|Der- `Index Insert` Operator Fügt Zeilen aus der Eingabe in den nicht gruppierten Index ein, der in der-Spalte angegeben ist `Argument` . Die `Argument`-Spalte enthält auch ein SET:()-Prädikat, das den für die einzelnen Spalten festgelegten Wert anzeigt. `Index Insert` ist ein physischer Operator.|  
|![Nonclustered Index Scan-Operator (Symbol)](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Nonclustered Index Scan-Operator (Symbol)")|`Index Scan`|Der- `Index Scan` Operator Ruft alle Zeilen aus dem nicht gruppierten Index ab, der in der-Spalte angegeben ist `Argument` . Wenn ein optionales WHERE:()-Prädikat in der `Argument` Spalte angezeigt wird, werden nur die Zeilen zurückgegeben, die das Prädikat erfüllen. `Index Scan` ist ein logischer und physischer Operator.|  
|![Nonclustered Index Seek-Operator (Symbol)](../../2014/database-engine/media/index-seek-32x.gif "Nonclustered Index Seek-Operator (Symbol)")|`Index Seek`|Der `Index Seek`-Operator verwendet die Suchfunktionen der Indizes, um Zeilen aus einem nicht gruppierten Index abzurufen. Die `Argument` Spalte enthält den Namen des verwendeten nicht gruppierten Indexes. Außerdem enthält sie auch das SEEK:()-Prädikat. Mit diesem Index werden von der Speicher-Engine nur die Zeilen verarbeitet, die das SEEK:()-Prädikat erfüllen. Optional kann ein WHERE:()-Prädikat enthalten sein, das von der Speicher-Engine für alle Zeilen ausgewertet wird, bei denen das SEEK:()-Prädikat erfüllt wird (es werden hierfür keine Indizes verwendet). Wenn die `Argument` Spalte die sortierte Klausel enthält, hat der Abfrage Prozessor ermittelt, dass die Zeilen in der Reihenfolge zurückgegeben werden müssen, in der Sie vom nicht gruppierten Index sortiert wurden. Wurde die ORDERED-Klausel nicht angegeben, so durchsucht die Speicher-Engine den Index auf die optimale Art (wobei die Ausgabe nicht unbedingt sortiert ist). Die Ausgabe in der ursprünglichen Reihenfolge kann weniger effizient sein als die unsortierte Ausgabe. `Index Seek` ist ein logischer und physischer Operator.|  
|![Nonclustered Index Spool-Operator (Symbol)](../../2014/database-engine/media/index-spool-32x.gif "Nonclustered Index Spool-Operator (Symbol)")|**Index Spool**|Der physische Operator **Index Spool** enthält ein Seek:()-Prädikat in der `Argument` Spalte. Der **Index Spool** -Operator scannt seine Eingabezeilen und platziert eine Kopie jeder Zeile in einer verborgenen Spooldatei (die in der `tempdb` Datenbank gespeichert ist und nur für die Lebensdauer der Abfrage vorhanden ist) und erstellt einen nicht gruppierten Index für die Zeilen. Dies ermöglicht es Ihnen, mithilfe der Indexsuchfunktionen nur die Zeilen auszugeben, die das SEEK:()-Prädikat erfüllen. Wenn der Operator zurückgesetzt wird (z. b. durch einen `Nested Loops` Operator), aber keine erneute Bindung erforderlich ist, werden die gespoolten Daten verwendet, anstatt die Eingabe erneut zu scannen.|  
|![Nonclustered Index Update-Operator (Symbol)](../../2014/database-engine/media/nonclust-index-update-32x.gif "Nonclustered Index Update-Operator (Symbol)")|`Nonclustered Index Update`|Der `Nonclustered Index Update` physische Operator Aktualisiert Zeilen aus der Eingabe in dem nicht gruppierten Index, der in der Spalte angegeben ist `Argument` . Wenn ein SET:()-Prädikat vorhanden ist, wird jede aktualisierte Spalte auf diesen Wert festgelegt. `Nonclustered Index Update` ist ein physischer Operator.|  
|![Online Index Insert-Operator (Symbol)](../../2014/database-engine/media/online-index-32x.gif "Online Index Insert-Operator (Symbol)")|**Online Index Insert**|Der physische Operator **Online Index Insert** gibt an, dass ein Index online erstellt, geändert oder gelöscht wird. Die zugrunde liegenden Tabellendaten bleiben daher während des Indexvorgangs für Benutzer verfügbar.|  
|Keine|`Parallelism`|Der- `Parallelism` Operator führt die logischen Vorgänge verteilungsstreams, Gather Streams und Repartition Streams durch. Die `Argument` Spalten können ein Partition columns:()-Prädikat mit einer durch Trennzeichen getrennten Liste der Spalten enthalten, die partitioniert werden. Die `Argument` Spalten können auch ein Order by:()-Prädikat enthalten, das die Spalten auflistet, für die die Sortierreihenfolge während der Partitionierung beibehalten wird. `Parallelism` ist ein physischer Operator.<br /><br /> Hinweis: Wenn eine Abfrage als parallele Abfrage kompiliert wurde, aber zur Laufzeit als serielle Abfrage ausgeführt wird, enthält die durch SET STATISTICS XML oder mit der Option **tatsächlichen Ausführungs Plan einschließen** von generierte Show Plan Ausgabe [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] kein- `RunTimeInformation` Element für den- `Parallelism` Operator. In der Ausgabe des Statistik Profils festlegen werden bei der tatsächlichen Zeilen Anzahl und der tatsächlichen Anzahl von Ausführungen Nullen für den `Parallelism` Operator angezeigt. Wenn eine Bedingung auftritt, bedeutet dies, dass der `Parallelism` Operator nur während der Kompilierung der Abfrage und nicht im Lauf Zeit Abfrageplan verwendet wurde. Beachten Sie, dass parallele Abfragepläne mitunter seriell ausgeführt werden, wenn der Server stark ausgelastet ist.|  
|![Parameter Table Scan-Operator (Symbol)](../../2014/database-engine/media/parameter-table-scan-32x.gif "Parameter Table Scan-Operator (Symbol)")|`Parameter Table Scan`|Der `Parameter Table Scan`-Operator scannt eine Tabelle, die als Parameter in der aktuellen Abfrage dient. In der Regel wird dieser Operator für INSERT-Abfragen in einer gespeicherten Prozedur verwendet. `Parameter Table Scan` ist ein logischer und physischer Operator.|  
|Keine|**Partial Aggregate**|**Partial Aggregate** wird in parallelen Plänen verwendet. Hiermit wird eine Aggregatfunktion auf möglichst viele Eingabezeilen angewandt, damit das Schreiben auf den Datenträger (der so genannte "Überlauf") nicht erforderlich ist. `Hash Match`ist der einzige physische Operator (Iterator), der die Partitions Aggregation implementiert. **Partial Aggregate** ist ein logischer Operator.|  
|![Population Query-Cursoroperator (Symbol)](../../2014/database-engine/media/poulation-query-32x.gif "Population Query-Cursoroperator (Symbol)")|`Population Query`|Der `Population Query`-Operator füllt die Arbeitstabelle eines Cursors auf, wenn der Cursor geöffnet wird.|  
|![Refresh Query-Cursoroperator (Symbol)](../../2014/database-engine/media/refresh-query-32x.gif "Refresh Query-Cursoroperator (Symbol)")|`Refresh Query`|Der `Refresh Query`-Operator ruft aktuelle Daten für die Zeilen im Fetchpuffer ab.|  
|![Remote Delete-Operator (Symbol)](../../2014/database-engine/media/remote-delete-32x.gif "Remote Delete-Operator (Symbol)")|`Remote Delete`|Der `Remote Delete`-Operator löscht die Eingabezeilen in einem Remoteobjekt. `Remote Delete` ist ein logischer und physischer Operator.|  
|![Remote Index Seek (Show Plan Operator)](../../2014/database-engine/media/remote-index-scan-32x.gif "Remote Index Seek-Showplanoperator")|**Remote Index Scan**|Der **Remote Index Scan** -Operator durchsucht den in der Argumentspalte angegebenen Remoteindex. **Remote Index Scan** ist ein logischer und physischer Operator.|  
|![Remote Index Seek (Show Plan Operator)](../../2014/database-engine/media/remote-index-seek-32x.gif "Remote Index Seek-Showplanoperator")|**Remote Index Seek**|Der **Remote Index Seek** -Operator verwendet die Suchmöglichkeiten eines Remoteindexobjekts, um Zeilen abzurufen. Die `Argument` Spalte enthält den Namen des verwendeten Remote Indexes und das Seek:()-Prädikat. **Remote Index Seek** ist ein logischer und physischer Operator.|  
|![Remote Insert-Operator (Symbol)](../../2014/database-engine/media/remote-insert-32x.gif "Remote Insert-Operator (Symbol)")|**Remote Insert**|Der **Remote Insert** -Operator fügt die Eingabezeilen in ein Remoteobjekt ein. **Remote Insert** ist ein logischer und physischer Operator.|  
|![Remote Query-Operator (Symbol)](../../2014/database-engine/media/remote-query-32x.gif "Remote Query-Operator (Symbol)")|`Remote Query`|Durch den Operator `Remote Query` wird eine Abfrage an eine Remotequelle übermittelt. Der Text der an den Remote Server gesendeten Abfrage wird in der- `Argument` Spalte angezeigt. `Remote Query` ist ein logischer und physischer Operator.|  
|![Remote Scan-Operator (Symbol)](../../2014/database-engine/media/remote-scan-32x.gif "Remote Scan-Operator (Symbol)")|`Remote Scan`|Der Operator `Remote Scan` überprüft ein Remoteobjekt. Der Name des Remote Objekts wird in der `Argument` Spalte angezeigt. `Remote Scan` ist ein logischer und physischer Operator.|  
|![Remote Update-Operator (Symbol)](../../2014/database-engine/media/remote-update-32x.gif "Remote Update-Operator (Symbol)")|`Remote Update`|Der `Remote Update`-Operator aktualisiert die Eingabezeilen in einem Remoteobjekt. `Remote Update` ist ein logischer und physischer Operator.|  
|![Repartition Streams Parallelism-Operator (Symbol)](../../2014/database-engine/media/parallelism-repartition-stream.gif "Repartition Streams Parallelism-Operator (Symbol)")|**Repartition Streams**|Der **Repartition Streams** -Operator verarbeitet und generiert mehrere Datenströme von Datensätzen. Inhalt und Format der Datensätze werden nicht geändert. Wenn der Abfrageoptimierer einen Bitmapfilter verwendet, wird die Anzahl der Zeilen im Ausgabedatenstrom reduziert. Jeder Datensatz aus einem Eingabedatenstrom wird in einem Ausgabedatenstrom platziert. Wenn dieser Operator die Reihenfolge beibehalten soll, müssen alle Eingabedatenströme entsprechend geordnet vorliegen und in mehrere geordnete Ausgabedatenströme zusammengeführt werden. Wenn die Ausgabe partitioniert ist, `Argument` enthält die Spalte ein Partition columns:()-Prädikat und die Partitionierungs Spalten. Wenn die Ausgabe sortiert ist, `Argument` enthält die Spalte ein Order by:()-Prädikat und die Spalten, die sortiert werden. **Repartition Streams** ist ein logischer Operator. Der Operator wird nur in parallelen Abfrageplänen verwendet.|  
|![Result-Sprachelement (Symbol)](../../2014/database-engine/media/result-32x.gif "Result-Sprachelement (Symbol)")|`Result`|Der `Result`-Operator stellt die Daten dar, die am Ende eines Abfrageplans zurückgegeben werden. Dies ist normalerweise das Stammelement eines Showplans. `Result` ist ein Sprachelement.|  
|![RID Lookup-Operator (Symbol)](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "RID Lookup-Operator (Symbol)")|`RID Lookup`|`RID Lookup` ist ein Bookmark Lookup für einen Heap, der eine bereitgestellte Zeilen-ID (RID) verwendet. Die `Argument` Spalte enthält die Lesezeichen Bezeichnung, mit der die Zeile in der Tabelle und der Name der Tabelle, in der die Zeile gesucht wird, nachschlagen. `RID Lookup` wird stets durch eine NESTED LOOP JOIN-Anweisung begleitet. `RID Lookup` ist ein physischer Operator. Weitere Informationen zu Bookmark Lookups finden Sie unter „[Bookmark Lookup](https://go.microsoft.com/fwlink/?LinkId=132568)“ im SQL Server-Blog von MSDN.|  
|Keine|`Right Anti Semi Join`|Der logische Operator `Right Anti Semi Join` gibt alle Zeilen aus der zweiten (unteren) Eingabe aus, für die keine übereinstimmende Zeile in der ersten (oberen) Eingabe vorhanden ist. Eine übereinstimmende Zeile wird als Zeile definiert, die das Prädikat in der `Argument` Spalte erfüllt (wenn kein Prädikat vorhanden ist, ist jede Zeile eine übereinstimmende Zeile). `Right Anti Semi Join` ist ein logischer Operator.|  
|Keine|`Right Outer Join`|Der `Right Outer Join`-Operator gibt alle Zeilen zurück, die den Join der zweiten (unteren) Eingabe mit der ersten (oberen) Eingabe erfüllen. Er gibt auch alle Zeilen aus der zweiten Eingabe mit NULL-Werten zurück, für die keine übereinstimmende Zeile in der ersten Eingabe vorhanden ist. Wenn kein Joinprädikat in der Spalte vorhanden ist `Argument` , ist jede Zeile eine übereinstimmende Zeile. `Right Outer Join` ist ein logischer Operator.|  
|Keine|`Right Semi Join`|Der `Right Semi Join`-Operator gibt alle Zeilen aus der zweiten (unteren) Eingabe zurück, für die eine übereinstimmende Zeile in der ersten (oberen) Eingabe vorhanden ist. Wenn kein Joinprädikat in der Spalte vorhanden ist `Argument` , ist jede Zeile eine übereinstimmende Zeile. `Right Semi Join` ist ein logischer Operator.|  
|![Row Count Spool-Operator (Symbol)](../../2014/database-engine/media/remote-count-spool-32x.gif "Row Count Spool-Operator (Symbol)")|**Row Count Spool**|Der **Row Count Spool** -Operator scannt die Eingabe, zählt, wie viele Zeilen vorhanden sind, und gibt dieselbe Anzahl an leeren Zeilen zurück. Dieser Operator wird verwendet, wenn es darauf ankommt, die Existenz von Zeilen und nicht ihren Inhalt zu überprüfen. Wenn z. b. ein `Nested Loops` Operator einen Left Semi Join-Vorgang ausführt und das Joinprädikat auf die innere Eingabe angewendet wird, kann ein Row Count Spool-Vorgang am Anfang der inneren Eingabe des Operators platziert werden `Nested Loops` . Anschließend `Nested Loops` kann der Operator bestimmen, wie viele Zeilen vom spoolzeilen Zähler ausgegeben werden (da die eigentlichen Daten der inneren Seite nicht benötigt werden), um zu bestimmen, ob die äußere Zeile zurückgegeben werden soll. Beim**Row Count Spool** -Operator handelt es sich um einen physischen Operator.|  
|![Segment-Operator (Symbol)](../../2014/database-engine/media/segment-32x.gif "Segment-Operator (Symbol)")|**Segment**|**Segment** ist ein physischer und logischer Operator. Dieser Operator teilt die Eingabeset basierend auf dem Wert von mindestens einer Spalte in Segmente auf. Diese Spalten werden als Argumente im Operator **Segment** angezeigt. Anschließend gibt der Operator ein Segment nach dem anderen aus.|  
|Keine|`Segment Repartition`|Ein paralleler Abfrageplan kann mitunter logische Bereiche von Iteratoren enthalten. Alle Iteratoren innerhalb eines solchen Bereichs können durch parallele Threads ausgeführt werden. Die Bereiche selbst müssen seriell ausgeführt werden. Einige der `Parallelism`-Iteratoren innerhalb eines einzelnen Bereichs werden `Branch Repartition` genannt. Der `Parallelism`-Iterator an der Grenze zwischen zwei Bereichen wird `Segment Repartition` genannt. `Branch Repartition` und `Segment Repartition` sind logische Operatoren.|  
|![Sequence-Operator (Symbol)](../../2014/database-engine/media/sequence-32x.gif "Sequence-Operator (Symbol)")|`Sequence`|Der `Sequence`-Operator steuert umfangreiche Aktualisierungspläne. Er führt die Eingaben sequenziell aus (von oben nach unten). Jede Eingabe stellt in der Regel ein Update eines anderen Objekts dar. Der Operator gibt nur die Zeilen zurück, die aus der letzten (unteren) Eingabe stammen. `Sequence` ist ein logischer und physischer Operator.|  
|![Sequence Project-Operator (Symbol)](../../2014/database-engine/media/sequence-project-32x.gif "Sequence Project-Operator (Symbol)")|`Sequence Project`|Der `Sequence Project`-Operator fügt Spalten hinzu, um für eine geordnete Menge Berechnungen auszuführen. Dieser Operator teilt die Eingabeset basierend auf dem Wert von mindestens einer Spalte in Segmente auf. Anschließend gibt der Operator ein Segment nach dem anderen aus. Diese Spalten werden im `Sequence Project`-Operator als Argumente angezeigt. `Sequence Project` ist ein logischer und physischer Operator.|  
|![Snapshot-Cursoroperator (Symbol)](../../2014/database-engine/media/snapshot-32x.gif "Snapshot-Cursoroperator (Symbol)")|**Momentaufnahme**|Mit dem **Snapshot** -Operator wird ein Cursor erstellt, der von anderen vorgenommene Änderungen nicht wahrnimmt.|  
|![Sort-Operator (Symbol)](../../2014/database-engine/media/sort-32x.gif "Sort-Operator (Symbol)")|`Sort`|Der- `Sort` Operator sortiert alle eingehenden Zeilen. Die `Argument` Spalte enthält entweder ein eindeutiges Order by:()-Prädikat, wenn Duplikate von diesem Vorgang entfernt werden, oder ein Order by:()-Prädikat mit einer durch Trennzeichen getrennten Liste der sortierten Spalten. Die Spalten werden mit dem Präfix ASC versehen, wenn sie in aufsteigender Reihenfolge sortiert werden, oder mit der Zeichenfolge DESC, wenn sie in absteigender Reihenfolge sortiert werden. `Sort` ist ein logischer und physischer Operator.|  
|![Split-Operator (Symbol)](../../2014/database-engine/media/split-32x.gif "Split-Operator (Symbol)")|`Split`|Der- `Split` Operator wird verwendet, um die Update Verarbeitung zu optimieren. Er teilt jeden Aktualisierungsvorgang in einen Lösch- und einen Einfügevorgang auf. `Split` ist ein logischer und physischer Operator.|  
|![Spool-Operator (Symbol)](../../2014/database-engine/media/spool-32x.gif "Spool-Operator (Symbol)")|**Spool**|Der **Spool** -Operator speichert ein zwischen Abfrageergebnis in der `tempdb` Datenbank.|  
|![Stream Aggregate-Operator (Symbol)](../../2014/database-engine/media/stream-aggregate-32x.gif "Stream Aggregate-Operator (Symbol)")|`Stream Aggregate`|Der `Stream Aggregate`-Operator gruppiert Zeilen nach einer oder mehreren Spalten und berechnet einen oder mehrere Aggregatausdrücke, die von der Abfrage zurückgegeben wurden. Auf die Ausgabe dieses Operators kann durch spätere Operatoren in der Abfrage verwiesen werden, die Ausgabe kann an den Client zurückgegeben werden oder beides. Für den `Stream Aggregate`-Operator ist es erforderlich, dass die Eingabe innerhalb der Gruppen nach den Spalten sortiert ist. Der Optimierer verwendet vor diesem Operator einen `Sort`-Operator, wenn die Daten nicht bereits durch einen vorherigen `Sort`-Operator oder durch einen geordneten Indexsuch- oder Scanvorgang sortiert wurden. In der SHOWPLAN_ALL-Anweisung oder im grafischen Ausführungsplan in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] werden die Spalten im Group by-Prädikat in der `Argument` -Spalte aufgelistet, und die Aggregat Ausdrücke sind in der Spalte **definierte Werte** aufgelistet. `Stream Aggregate` ist ein physischer Operator.|  
|![Switch-Operator (Symbol)](../../2014/database-engine/media/switch-32x.gif "Switch-Operator (Symbol)")|**Switch**|**Switch** ist ein spezieller Verkettungsiterator, der über *n* Eingaben verfügt. Mit jedem **Switch** -Operator ist ein Ausdruck verbunden. Abhängig vom Rückgabewert des Ausdrucks (zwischen 0 und *n*-1) kopiert **Switch** den entsprechenden Eingabedatenstrom in den Ausgabedatenstrom. Eine Verwendungsmöglichkeit von **Switch** besteht in der Implementierung von Abfrageplänen, die schnelle Vorwärtscursor mit bestimmten Operatoren, z.B. dem **TOP** -Operator, enthalten. **Switch** ist sowohl ein logischer als auch ein physischer Operator.|  
|![Table Delete-Operator (Symbol)](../../2014/database-engine/media/table-delete-32x.gif "Table Delete-Operator (Symbol)")|`Table Delete`|Der `Table Delete` physische Operator löscht Zeilen aus der Tabelle, die in der- `Argument` Spalte des Abfrage Ausführungs Plans angegeben ist.|  
|![Table Insert-Operator (Symbol)](../../2014/database-engine/media/table-insert-32x.gif "Table Insert-Operator (Symbol)")|`Table Insert`|Der- `Table Insert` Operator Fügt Zeilen aus der Eingabe in die Tabelle ein, die in der- `Argument` Spalte des Abfrage Ausführungs Plans angegeben ist. Die `Argument`-Spalte enthält auch ein SET:()-Prädikat, das den für die einzelnen Spalten festgelegten Wert anzeigt. Wenn `Table Insert` keine untergeordneten Elemente für Eingabewerte enthält, wird die eingefügte Zeile aus dem Insert-Operator selbst übernommen. `Table Insert` ist ein physischer Operator.|  
|![Table Merge-Operator](../../2014/database-engine/media/table-merge-32x.gif "Table Merge-Operator")|**Table Merge**|Der **Table Merge** -Operator wendet einen Mergedatenstrom auf einen Heap an. Der-Operator löscht, aktualisiert oder fügt Zeilen in der Tabelle ein, die in der- `Argument` Spalte des-Operators angegeben ist. Der tatsächlich ausgeführte Vorgang hängt vom Lauf Zeitwert der **Aktions** Spalte ab, die in der- `Argument` Spalte des-Operators angegeben ist. **Table Merge** ist ein physischer Operator.|  
|![Table Scan-Operator (Symbol)](../../2014/database-engine/media/table-scan-32x.gif "Table Scan-Operator (Symbol)")|`Table Scan`|Der- `Table Scan` Operator Ruft alle Zeilen aus der Tabelle ab, die in der- `Argument` Spalte des Abfrage Ausführungs Plans angegeben ist. Wenn ein WHERE:()-Prädikat in der `Argument` Spalte angezeigt wird, werden nur die Zeilen zurückgegeben, die das Prädikat erfüllen. `Table Scan` ist ein logischer und physischer Operator.|  
|![Table Spool-Operator (Symbol)](../../2014/database-engine/media/table-spool-32x.gif "Table Spool-Operator (Symbol)")|**Table Spool**|Der **Table Spool** -Operator scannt die Eingabe und platziert eine Kopie jeder Zeile in einer verborgenen Spooltabelle, die in der [tempdb](../relational-databases/databases/tempdb-database.md) -Datenbank gespeichert und nur für die Dauer der Abfrage vorhanden ist. Wenn der Operator zurückgesetzt wird (z. b. durch einen `Nested Loops` Operator), aber keine erneute Bindung erforderlich ist, werden die gespoolten Daten verwendet, anstatt die Eingabe erneut zu scannen. **Table Spool** ist ein physischer Operator.|  
|![Table Update-Operator (Symbol)](../../2014/database-engine/media/table-update-32x.gif "Table Update-Operator (Symbol)")|`Table Update`|Der `Table Update` physische-Operator aktualisiert die Eingabezeilen in der Tabelle, die in der- `Argument` Spalte des Abfrage Ausführungs Plans angegeben ist. Das SET:()-Prädikat bestimmt den Wert jeder aktualisierten Spalte. Auf diese Werte kann in der SET-Klausel oder an anderer Stelle in diesem Operator sowie an anderer Stelle dieser Abfrage verwiesen werden.|  
|![Tabellenwertfunktion-Operator (Symbol)](../../2014/database-engine/media/table-valued-function-32x.gif "Tabellenwertfunktion-Operator (Symbol)")|**Table-valued Function**|Mit dem Operator **Tabellenwertfunktion** wird eine Tabellenwertfunktion ausgewertet ( [!INCLUDE[tsql](../includes/tsql-md.md)] oder CLR), und die Ergebniszeilen werden in der [tempdb](../relational-databases/databases/tempdb-database.md) -Datenbank gespeichert. Wenn die übergeordneten Iteratoren die Zeilen anfordern, gibt die **Tabellenwert Funktion** die Zeilen aus zurück `tempdb` .<br /><br /> Abfragen mit Aufrufen von Tabellenwertfunktionen generieren Abfragepläne mit dem **Tabellenwertfunktion** -Iterator. Die**Tabellenwertfunktion** kann mit verschiedenen Parameterwerten analysiert werden:<br /><br /> Der**Tabellenwertfunktion-XML-Leser** gibt einen XML-BLOB als Parameter ein und erstellt ein Rowset, das XML-Knoten in der XML-Dokumentreihenfolge darstellt. Andere Eingabeparameter können die zurückgegebenen XML-Knoten auf eine Teilmenge von XML-Dokumenten einschränken.<br /><br /> **Tabellenwertfunktion-XML-Leser mit XPath-Filter** ist ein spezieller Typ von **Tabellenwertfunktion-XML-Leser** , der die Ausgabe auf XML-Knoten einschränkt, die einen XPath-Ausdruck erfüllen.<br /><br /> <br /><br /> Die**Tabellenwertfunktion** ist sowohl ein logischer als auch ein physischer Operator.|  
|![Top-Operator (Symbol)](../../2014/database-engine/media/top-32x.gif "Top-Operator (Symbol)")|**Top**|Der **Top** -Operator scannt die Eingabe und gibt nur die angegebene Anzahl bzw. den angegebenen Prozentsatz von Zeilen zurück, meist basierend auf einer Sortierreihenfolge. Die `Argument` Spalte kann eine Liste der Spalten enthalten, die auf Verknüpfungen geprüft werden. In Updateplänen wird der **Top** -Operator verwendet, um die Einschränkung der Zeilenanzahl zu erzwingen. **Top** ist sowohl ein logischer als auch physischer Operator. **Top** ist sowohl ein logischer als auch physischer Operator.|  
|Keine|**Top N Sort**|**Top N Sort** ähnelt dem `Sort` Iterator, mit dem Unterschied, dass nur die ersten *n* Zeilen benötigt werden und nicht das gesamte Resultset. Bei kleinen Werten für *N* versucht die [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]-Abfrageausführungs-Engine, den gesamten Sortiervorgang im Arbeitsspeicher auszuführen. Bei großen Werten für *N* greift die Abfrageausführungs-Engine auf die mehr generische Methode der Sortierung zurück, für die *N* kein Parameter ist.|  
|![Erweiterter Operator (UDX – Symbol)](../../2014/database-engine/media/udx-32x.gif "Erweiterter Operator (UDX – Symbol)")|`UDX`|Erweiterte Operatoren (UDX) implementieren einen von vielen XQuery- und XPath-Vorgängen in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]. Alle UDX-Operatoren sind sowohl logische als auch physische Operatoren.<br /><br /> Mit dem erweiterten Operator (UDX) `FOR XML` wird das relationale Rowset serialisiert, das in die XML-Darstellung einer einzelnen BLOB-Spalte in einer einzigen Ausgabezeile eingegeben wird. Bei diesem XML-Aggregationsoperator wird die Reihenfolge berücksichtigt.<br /><br /> Der erweiterte Operator (UDX) `XML SERIALIZER` ist ein XML-Aggregationsoperator, bei dem die Reihenfolge berücksichtigt wird. Er gibt Zeilen ein, die XML-Knoten oder XQuery-Skalarwerte in der XML-Dokumentreihenfolge darstellen, und erstellt eine serialisierte XML-BLOB-Spalte in einer einzelnen XML-Spalte in einer einzigen Ausgabezeile.<br /><br /> Der erweiterte Operator (UDX) `XML FRAGMENT SERIALIZER` ist eine Sonderform von `XML SERIALIZER`, womit Eingabezeilen verarbeitet werden, die XML-Fragmente darstellen, die in der XQuery-Erweiterung zum Ändern von Einfügungsdaten eingefügt werden.<br /><br /> Der erweiterte Operator (UDX) `XQUERY STRING` wertet den XQuery-Zeichenfolgenwert von Eingabezeilen aus, die XML-Knoten darstellen. Bei diesem Zeichenfolgen-Aggregationsoperator wird die Reihenfolge berücksichtigt. Er gibt eine Zeile mit Spalten zurück, die den XQuery-Skalarwert darstellt, der den Zeichenfolgenwert der Eingabe enthält.<br /><br /> Der erweiterte Operator (UDX) `XQUERY LIST DECOMPOSER` ist ein XQuery-Listendekompositionsoperator. Für jede Eingabezeile, die einen XML-Knoten darstellt, erstellt dieser Operator mindestens eine Zeile, die einen XQuery-Skalarwert mit einem Listenelementwert darstellt, falls die Eingabe vom XSD-Listentyp ist.<br /><br /> Der erweiterte Operator (UDX) `XQUERY DATA` wertet die XQuery-Funktion fn:data() in Eingabezeilen aus, die XML-Knoten darstellen. Bei diesem Zeichenfolgen-Aggregationsoperator wird die Reihenfolge berücksichtigt. Er gibt eine Zeile mit Spalten zurück, die den XQuery-Skalarwert darstellt, der das Ergebnis von **fn:data()** enthält.<br /><br /> Der erweiterte Operator `XQUERY CONTAINS` wertet die XQuery-Funktion fn:contains() in Eingabezeilen aus, die XML-Knoten darstellen. Bei diesem Zeichenfolgen-Aggregationsoperator wird die Reihenfolge berücksichtigt. Er gibt eine Zeile mit Spalten zurück, die den XQuery-Skalarwert darstellt, der das Ergebnis von **fn:contains()** enthält.<br /><br /> Der erweiterte Operator `UPDATE XML NODE` aktualisiert den XML-Knoten in der XQuery-Erweiterung zum Ersetzen von Daten in der **Modify ()** -Methode für den XML-Typ.|  
|Keine|**Union**|Der **Union** -Operator scannt mehrere Eingaben und gibt alle gescannten Zeilen aus, wobei Duplikate entfernt werden. **Union** ist ein logischer Operator.|  
|![Update-Operatorsymbol (Datenbank-Engine)](../../2014/database-engine/media/update-32x.gif "Update-Operatorsymbol (Datenbank-Engine)")|`Update`|Der- `Update` Operator aktualisiert jede Zeile aus der Eingabe in dem-Objekt, das in der- `Argument` Spalte des Abfrage Ausführungs Plans angegeben ist. `Update` ist ein logischer Operator. Der physische Operator ist `Table Update`, `Index Update` oder `Clustered Index Update`.|  
|![While-Sprachelement (Symbol)](../../2014/database-engine/media/while-32x.gif "While-Sprachelement (Symbol)")|`While`|Der `While`-Operator implementiert die WHILE-Schleife von [!INCLUDE[tsql](../includes/tsql-md.md)]. `While`ist ein sprach Element|  
|![Table Spool-Operator (Symbol)](../../2014/database-engine/media/table-spool-32x.gif "Table Spool-Operator (Symbol)")|`Window Spool`|Der `Window Spool`-Operator erweitert jede Zeile in den Satz von Zeilen, die das ihm zugeordnete Fenster darstellen. In einer Abfrage definiert die OVER-Klausel das Fenster innerhalb eines Abfrageresultsets, und eine Fensterfunktion berechnet dann einen Wert für jede Zeile im Fenster. `Window Spool` ist ein logischer und physischer Operator.|  
  
  
