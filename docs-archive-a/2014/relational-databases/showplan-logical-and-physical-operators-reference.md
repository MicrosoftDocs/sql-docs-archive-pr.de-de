---
title: Referenz zu logischen und physischen Showplanoperatoren | Microsoft-Dokumentation
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
f1_keywords:
- sql12.swb.showplan.nestedloops.f1
- sql12.swb.showplan.dynamic.f1
- sql12.swb.showplan.tableinsert.f1
- sql12.swb.showplan.remoteinsert.f1
- sql12.swb.showplan.lazyspool.f1
- sql12.swb.showplan.RIDLookup
- sql12.swb.showplan.hashmatchteam.f1
- sql12.swb.showplan.tablespool.f1
- sql12.swb.showplan.print.f1
- sql12.swb.showplan.clusteredindexupdate.f1
- sql12.swb.showplan.assert.f1
- sql12.swb.showplan.columnstoreindexscan.f1
- sql12.swb.showplan.tablevaluedfunction.f1
- sql12.swb.showplan.split.f1
- sql12.swb.showplan.union.f1
- sql12.swb.showplan.clusteredindexseek.f1
- sql12.swb.showplan.indexspool.f1
- sql12.swb.showplan.indexinsert.f1
- sql12.swb.showplan.clusteredindexscan.f1
- sql12.swb.showplan.buildhash.f1
- sql12.swb.showplan.clusteredindexmerge.f1
- sql12.swb.showplan.sequence.f1
- sql12.swb.showplan.hashmatchroot.f1
- sql12.swb.showplan.columnstoreindexupdate.f1
- sql12.swb.showplan.rightsemijoin.f1
- sql12.swb.showplan.fetchquery.f1
- sql12.swb.showplan.distinct.f1
- sql12.swb.showplan.hashmatch.f1
- sql12.swb.showplan.segment.f1
- sql12.swb.showplan.top.f1
- sql12.swb.showplan.columnstoreindexdelete.f1
- sql12.swb.showplan.gatherstreams.f1
- sql12.swb.showplan.remotedelete.f1
- sql12.swb.showplan.insert.f1
- sql12.swb.showplan.declare.f1
- sql12.swb.showplan.snapshot.f1
- sql12.swb.showplan.assign.f1
- sql12.swb.showplan.intrinsic.f1
- sql12.swb.showplan.mergejoin.f1
- sql12.swb.showplan.concatenation.f1
- sql12.swb.showplan.rowcountspool.f1
- sql12.swb.showplan.parametertablescan.f1
- sql12.swb.showplan.indexscan.f1
- sql12.swb.showplan.while.f1
- sql12.swb.showplan.columnstoreindexinsert.f1
- sql12.swb.showplan.tablemerge.f1
- sql12.swb.showplan.spool.f1
- sql12.swb.showplan.streamaggregate.f1
- sql12.swb.showplan.update.f1
- sql12.swb.showplan.innerjoin.f1
- sql12.swb.showplan.flowdistinct.f1
- sql12.swb.showplan.tableupdate.f1
- sql12.swb.showplan.result.f1
- sql12.swb.showplan.bitmap.f1
- sql12.swb.showplan.remoteindexseek.f1
- sql12.swb.showplan.populationquery.f1
- sql12.swb.showplan.rightouterjoin.f1
- sql12.swb.showplan.columnstoreindexmerge.f1
- sql12.swb.showplan.remotescan.f1
- sql12.swb.showplan.remoteupdate.f1
- sql12.swb.showplan.keyset.f1
- sql12.swb.showplan.collapse.f1
- sql12.swb.showplan.arithmeticexpression.f1
- sql12.swb.showplan.clusteredindexinsert.f1
- sql12.swb.showplan.computescalar
- sql12.swb.showplan.sort.f1
- sql12.swb.showplan.locate.f1
- sql12.swb.showplan.constantscan.f1
- sql12.swb.showplan.computescalar.f1
- sql12.swb.showplan.indexseek.f1
- sql12.swb.showplan.leftsemijoin.f1
- sql12.swb.showplan.leftantisemijoin.f1
- sql12.swb.showplan.fullouterjoin.f1
- sql12.swb.showplan.filter.f1
- sql12.swb.showplan.indexdelete.f1
- sql12.swb.showplan.repartitionstreams.f1
- sql12.swb.showplan.crossjoin.f1
- sql12.swb.showplan.mergeinterval.f1
- sql12.swb.showplan.bookmarklookup.f1
- sql12.swb.showplan.convert.f1
- sql12.swb.showplan.refreshquery.f1
- sql12.swb.showplan.distinctsort.f1
- sql12.swb.showplan.leftouterjoin.f1
- sql12.swb.showplan.rightantisemijoin.f1
- sql12.swb.showplan.deletedscan.f1
- sql12.swb.showplan.udx.f1
- sql12.swb.showplan.broadcast.f1
- sql12.swb.showplan.delete.f1
- sql12.swb.showplan.aggregate.f1
- sql12.swb.showplan.setfunction.f1
- sql12.swb.showplan.switch.f1
- sql12.swb.showplan.remoteindexscan.f1
- sql12.swb.showplan.eagerspool.f1
- sql12.swb.showplan.indexupdate.f1
- sql12.swb.showplan.keylookup.f1
- sql12.swb.showplan.branchrepartition.f1
- sql12.swb.showplan.rank.f1
- sql12.swb.showplan.tablescan.f1
- sql12.swb.showplan.distributestreams.f1
- sql12.swb.showplan.logrowscan.f1
- sql12.swb.showplan.parallelism.f1
- sql12.swb.showplan.bitmapcreate.f1
- sql12.swb.showplan.insertedscan.f1
- sql12.swb.showplan.tabledelete.f1
- sql12.swb.showplan.clusteredindexdelete.f1
- sql12.swb.showplan.remotequery.f1
- sql12.swb.showplan.if.f1
- sql12.swb.showplan.cache.f1
- sql12.swb.showplan.partialaggregate.f1
- sql12.swb.showplan.sql.f1
helpviewer_keywords:
- execution plans [SQL Server], operators
- ActualRows attribute
- reading execution plan output
- ActualRewinds attribute
- ActualEndOfScans attribute
- query tuning [SQL Server]
- mapping operators [SQL Server]
- operators [Database Engine query tuning]
- logical operators [SQL Server], execution plans
- logical operators [SQL Server], listed
- physical operators [SQL Server]
- ActualRebinds attribute
- execution plans [SQL Server], reading output
ms.assetid: e43fd0fe-5ea7-4ffe-8d52-759ef6a7c361
author: rothja
ms.author: jroth
ms.openlocfilehash: bc45a5fa14785294093385e6f90b47a8bdb6dff3
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/04/2020
ms.locfileid: "87717689"
---
# <a name="showplan-logical-and-physical-operators-reference"></a><span data-ttu-id="74215-102">Referenz zu logischen und physischen Showplanoperatoren</span><span class="sxs-lookup"><span data-stu-id="74215-102">Showplan Logical and Physical Operators Reference</span></span>
  <span data-ttu-id="74215-103">Operatoren beschreiben, wie eine Abfrage oder eine DML-Anweisung (Data Manipulation Language) in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="74215-103">Operators describe how [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] executes a query or a Data Manipulation Language (DML) statement.</span></span> <span data-ttu-id="74215-104">Der Abfrageoptimierer verwendet Operatoren, um einen Abfrageplan für das in der Abfrage angegebene Ergebnis zu erstellen, oder zum Ausführen des in der DML-Anweisung angegebenen Vorgangs.</span><span class="sxs-lookup"><span data-stu-id="74215-104">The query optimizer uses operators to build a query plan to create the result specified in the query, or to perform the operation specified in the DML statement.</span></span> <span data-ttu-id="74215-105">Der Abfrageplan ist eine Struktur, die aus physischen Operatoren besteht.</span><span class="sxs-lookup"><span data-stu-id="74215-105">The query plan is a tree consisting of physical operators.</span></span> <span data-ttu-id="74215-106">Sie können den Abfrageplan mit den SET SHOWPLAN-Anweisungen, den grafischen Ausführungsplanoptionen in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], oder den SQL Server Profiler Showplan-Ereignisklassen anzeigen.</span><span class="sxs-lookup"><span data-stu-id="74215-106">You can view the query plan by using the SET SHOWPLAN statements, the graphical execution plan options in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], or the SQL Server Profiler Showplan event classes.</span></span>  
  
 <span data-ttu-id="74215-107">Operatoren werden als logische und physische Operatoren klassifiziert.</span><span class="sxs-lookup"><span data-stu-id="74215-107">Operators are classified as logical and physical operators.</span></span>  
  
 <span data-ttu-id="74215-108">**Logische Operatoren**</span><span class="sxs-lookup"><span data-stu-id="74215-108">**Logical Operators**</span></span>  
 <span data-ttu-id="74215-109">Logische Operatoren beschreiben den relationalen algebraischen Vorgang, der für die Anweisungsverarbeitung verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="74215-109">Logical operators describe the relational algebraic operation used to process a statement.</span></span> <span data-ttu-id="74215-110">Mit anderen Worten, logische Operatoren beschreiben konzeptionell den auszuführenden Vorgang.</span><span class="sxs-lookup"><span data-stu-id="74215-110">In other words, logical operators describe conceptually what operation needs to be performed.</span></span>  
  
 <span data-ttu-id="74215-111">**Physische Operatoren**</span><span class="sxs-lookup"><span data-stu-id="74215-111">**Physical Operators**</span></span>  
 <span data-ttu-id="74215-112">Physische Operatoren implementieren den durch logische Operatoren beschriebenen Vorgang.</span><span class="sxs-lookup"><span data-stu-id="74215-112">Physical operators implement the operation described by logical operators.</span></span> <span data-ttu-id="74215-113">Jeder physische Operator ist ein Objekt oder eine Routine, das bzw. die einen Vorgang ausführt.</span><span class="sxs-lookup"><span data-stu-id="74215-113">Each physical operator is an object or routine that performs an operation.</span></span> <span data-ttu-id="74215-114">Einige Operatoren greifen z. B. auf Spalten oder Zeilen einer Tabelle, eines Index oder einer Sicht zu.</span><span class="sxs-lookup"><span data-stu-id="74215-114">For example, some physical operators access columns or rows from a table, index or view.</span></span> <span data-ttu-id="74215-115">Andere physische Operatoren führen andere Vorgänge aus, z. B. Berechnungen, Aggregationen, Datenintegritätsprüfungen oder Joins.</span><span class="sxs-lookup"><span data-stu-id="74215-115">Other physical operators perform other operations such as calculations, aggregations, data integrity checks or joins.</span></span> <span data-ttu-id="74215-116">Physischen Operatoren sind Kosten zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="74215-116">Physical operators have costs associated with them.</span></span>  
  
 <span data-ttu-id="74215-117">Über die physischen Operatoren werden Daten initialisiert, aufgelistet und beendet.</span><span class="sxs-lookup"><span data-stu-id="74215-117">The physical operators initialize, collect data, and close.</span></span> <span data-ttu-id="74215-118">Der physische Operator kann insbesondere die folgenden drei Methodenaufrufe beantworten:</span><span class="sxs-lookup"><span data-stu-id="74215-118">Specifically, the physical operator can answer the following three method calls:</span></span>  
  
-   <span data-ttu-id="74215-119">**Init():** Mit der Methode **Init()** wird ein physischer Operator initialisiert und dazu angewiesen, erforderliche Datenstrukturen einzurichten.</span><span class="sxs-lookup"><span data-stu-id="74215-119">**Init()**: The **Init()** method causes a physical operator to initialize itself and set up any required data structures.</span></span> <span data-ttu-id="74215-120">Der physische Operator kann mehrere **Init()** -Aufrufe empfangen; in der Regel empfängt er jedoch nur einen.</span><span class="sxs-lookup"><span data-stu-id="74215-120">The physical operator may receive many **Init()** calls, though typically a physical operator receives only one.</span></span>  
  
-   <span data-ttu-id="74215-121">**GetNext():** Mit der Methode **GetNext()** wird ein Operator angewiesen, die erste oder nächste Datenzeile abzurufen.</span><span class="sxs-lookup"><span data-stu-id="74215-121">**GetNext()**: The **GetNext()** method causes a physical operator to get the first, or subsequent row of data.</span></span> <span data-ttu-id="74215-122">Der physische Operator kann null oder mehrere **GetNext()** -Aufrufe empfangen.</span><span class="sxs-lookup"><span data-stu-id="74215-122">The physical operator may receive zero or many **GetNext()** calls.</span></span>  
  
-   <span data-ttu-id="74215-123">**Close():** Mit der Methode **Close()** wird der physische Operator dazu angewiesen, einige Cleanupvorgänge auszuführen und sich selbst zu beenden.</span><span class="sxs-lookup"><span data-stu-id="74215-123">**Close()**: The **Close()** method causes a physical operator to perform some clean-up operations and shut itself down.</span></span> <span data-ttu-id="74215-124">Ein physischer Operator empfängt nur einen **Close()** -Aufruf.</span><span class="sxs-lookup"><span data-stu-id="74215-124">A physical operator only receives one **Close()** call.</span></span>  
  
 <span data-ttu-id="74215-125">Die **GetNext()**-Methode gibt eine Datenzeile zurück, und die Anzahl der Aufrufe wird als **ActualRows** in der durch SET STATISTICS PROFILE ON oder SET STATISTICS XML ON erstellten Showplanausgabe angezeigt.</span><span class="sxs-lookup"><span data-stu-id="74215-125">The **GetNext()** method returns one row of data, and the number of times it is called appears as **ActualRows** in the Showplan output that is produced by using SET STATISTICS PROFILE ON or SET STATISTICS XML ON.</span></span> <span data-ttu-id="74215-126">Weitere Informationen zu diesen SET-Optionen finden Sie unter [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) und [SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="74215-126">For more information about these SET options, see [SET STATISTICS PROFILE &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-profile-transact-sql) and [SET STATISTICS XML &#40;Transact-SQL&#41;](/sql/t-sql/statements/set-statistics-xml-transact-sql).</span></span>  
  
 <span data-ttu-id="74215-127">Die **ActualRebinds**- und **ActualRewinds**-Zähler, die in der Showplanausgabe angezeigt werden, beziehen sich auf die Anzahl der Aufrufe der **Init()** -Methode.</span><span class="sxs-lookup"><span data-stu-id="74215-127">The **ActualRebinds** and **ActualRewinds** counts that appear in Showplan output refer to the number of times that the **Init()** method is called.</span></span> <span data-ttu-id="74215-128">**ActualRebinds** entspricht 1 und **ActualRewinds** entspricht 0, es sei denn, ein Operator befindet sich innerhalb eines Schleifenjoins.</span><span class="sxs-lookup"><span data-stu-id="74215-128">Unless an operator is on the inner side of a loop join, **ActualRebinds** equals one and **ActualRewinds** equals zero.</span></span> <span data-ttu-id="74215-129">Wenn sich ein Operator innerhalb eines Schleifenjoins befindet, muss die Summe der erneuten Bindungen und Zurückspulvorgänge der Anzahl der verarbeiteten Vorgänge außerhalb des Joins entsprechen.</span><span class="sxs-lookup"><span data-stu-id="74215-129">If an operator is on the inner side of a loop join, the sum of the number of rebinds and rewinds should equal the number of rows processed on the outer side of the join.</span></span> <span data-ttu-id="74215-130">Unter 'erneuter Bindung' wird verstanden, dass sich mindestens ein korrelierter Parameter des Joins geändert hat und daher das Innere des Joins neu ausgewertet werden muss.</span><span class="sxs-lookup"><span data-stu-id="74215-130">A rebind means that one or more of the correlated parameters of the join changed and the inner side must be reevaluated.</span></span> <span data-ttu-id="74215-131">Unter 'Zurückspulvorgang' wird verstanden, dass sich keiner der korrelierten Parameter geändert hat und das vorherige innere Resultset daher wiederverwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="74215-131">A rewind means that none of the correlated parameters changed and the prior inner result set may be reused.</span></span>  
  
 <span data-ttu-id="74215-132">**ActualRebinds** und **ActualRewinds** sind in der mithilfe von SET STATISTICS XML ON erstellten XML-Showplanausgabe vorhanden.</span><span class="sxs-lookup"><span data-stu-id="74215-132">**ActualRebinds** and **ActualRewinds** are present in XML Showplan output produced by using SET STATISTICS XML ON.</span></span> <span data-ttu-id="74215-133">Sie werden nur für die Operatoren **Nonclustered Index Spool**, `Remote Query` , **Row Count Spool**, `Sort` **Table Spool**und **Table-Wert Function** aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="74215-133">They are only populated for the **Nonclustered Index Spool**, `Remote Query`, **Row Count Spool**, `Sort`, **Table Spool**, and **Table-valued Function** operators.</span></span> <span data-ttu-id="74215-134">**Actualrebindungen** und **ActualRewinds** können auch für den `Assert` -Operator und den- **Filter** -Operator aufgefüllt werden, wenn das **StartupExpression** -Attribut auf true festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="74215-134">**ActualRebinds** and **ActualRewinds** may also be populated for the `Assert` and **Filter** operators when the **StartupExpression** attribute is set to TRUE.</span></span>  
  
 <span data-ttu-id="74215-135">Wenn **ActualRebinds** und **ActualRewinds** in einem XML-Showplan vorhanden sind, können sie mit **EstimateRebinds** und **EstimateRewinds**verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="74215-135">When **ActualRebinds** and **ActualRewinds** are present in an XML Showplan, they are comparable to **EstimateRebinds** and **EstimateRewinds**.</span></span> <span data-ttu-id="74215-136">Wenn sie nicht vorhanden sind, kann die geschätzte Zeilenanzahl (**EstimateRows**) mit der tatsächlichen Zeilenanzahl (**ActualRows**) verglichen werden.</span><span class="sxs-lookup"><span data-stu-id="74215-136">When they are absent, the estimated number of rows (**EstimateRows**) is comparable to the actual number of rows (**ActualRows**).</span></span> <span data-ttu-id="74215-137">Beachten Sie, dass die tatsächliche grafische Showplanausgabe für tatsächliche erneute Bindungen und Zurückspulvorgänge Nullen anzeigt, wenn letztere nicht vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="74215-137">Note that actual graphical Showplan output displays zeros for the actual rebinds and actual rewinds when they are absent.</span></span>  
  
 <span data-ttu-id="74215-138">Ein entsprechender Zähler, **ActualEndOfScans**, ist verfügbar, wenn die Showplanausgabe mithilfe von SET STATISTICS XML ON erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="74215-138">A related counter, **ActualEndOfScans**, is available only when Showplan output is produced by using SET STATISTICS XML ON.</span></span> <span data-ttu-id="74215-139">Wenn ein physischer Operator das Ende seines Datenstroms erreicht, wird dieser Zähler um 1 erhöht.</span><span class="sxs-lookup"><span data-stu-id="74215-139">Whenever a physical operator reaches the end of its data stream, this counter is incremented by one.</span></span> <span data-ttu-id="74215-140">Wenn ein physischer Operator das Ende seines Datenstroms erreicht, wird dieser Zähler um 1 erhöht.</span><span class="sxs-lookup"><span data-stu-id="74215-140">A physical operator can reach the end of its data stream zero, one, or multiple times.</span></span> <span data-ttu-id="74215-141">Wie bei erneuten Bindungen und Zurückspulvorgängen kann die Anzahl für das Scanende größer als 1 sein; aber nur, wenn sich der Operator innerhalb eines Schleifenjoins befindet.</span><span class="sxs-lookup"><span data-stu-id="74215-141">As with rebinds and rewinds, the number of end of scans can be more than one only if the operator is on the inner side of a loop join.</span></span> <span data-ttu-id="74215-142">Die Anzahl für Scanende muss kleiner oder gleich der Summe der erneuten Bindungen und Zurückspulvorgänge sein.</span><span class="sxs-lookup"><span data-stu-id="74215-142">The number of end of scans should be less than or equal to the sum of the number of rebinds and rewinds.</span></span>  
  
## <a name="mapping-physical-and-logical-operators"></a><span data-ttu-id="74215-143">Zuordnen von physischen und logischen Operatoren</span><span class="sxs-lookup"><span data-stu-id="74215-143">Mapping Physical and Logical Operators</span></span>  
 <span data-ttu-id="74215-144">Der Abfrageoptimierer erstellt einen Abfrageplan als Struktur, die aus logischen Operatoren besteht.</span><span class="sxs-lookup"><span data-stu-id="74215-144">The query optimizer creates a query plan as a tree consisting of logical operators.</span></span> <span data-ttu-id="74215-145">Nach dem Erstellen des Abfrageplans wählt der Abfrageoptimierer für jeden logischen Operator den effizientesten physischen Operator aus.</span><span class="sxs-lookup"><span data-stu-id="74215-145">After the query optimizer creates the plan, the query optimizer chooses the most efficient physical operator for each logical operator.</span></span> <span data-ttu-id="74215-146">Der Abfrageoptimierer entscheidet auf Basis der Kosten, welcher physischer Operator einen logischen Operator implementieren soll.</span><span class="sxs-lookup"><span data-stu-id="74215-146">The query optimizer uses a cost-based approach to determine which physical operator will implement a logical operator.</span></span>  
  
 <span data-ttu-id="74215-147">Normalerweise kann ein logischer Vorgang von mehreren physischen Operatoren implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="74215-147">Usually, a logical operation can be implemented by multiple physical operators.</span></span> <span data-ttu-id="74215-148">Ein physischer Operator kann jedoch in seltenen Fällen mehrere logische Vorgänge implementieren.</span><span class="sxs-lookup"><span data-stu-id="74215-148">However, in rare cases, a physical operator can implement multiple logical operations as well.</span></span>  
  
## <a name="operator-descriptions"></a><span data-ttu-id="74215-149">Beschreibung der Operatoren</span><span class="sxs-lookup"><span data-stu-id="74215-149">Operator Descriptions</span></span>  
 <span data-ttu-id="74215-150">In diesem Abschnitt finden Sie Beschreibungen der logischen und physischen Operatoren.</span><span class="sxs-lookup"><span data-stu-id="74215-150">This section contains descriptions of the logical and physical operators.</span></span>  
  
|<span data-ttu-id="74215-151">Symbol für grafischen Ausführungsplan</span><span class="sxs-lookup"><span data-stu-id="74215-151">Graphical Execution Plan Icon</span></span>|<span data-ttu-id="74215-152">Showplanoperator</span><span class="sxs-lookup"><span data-stu-id="74215-152">Showplan Operator</span></span>|<span data-ttu-id="74215-153">BESCHREIBUNG</span><span class="sxs-lookup"><span data-stu-id="74215-153">Description</span></span>|  
|-----------------------------------|-----------------------|-----------------|  
|<span data-ttu-id="74215-154">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-154">None</span></span>|`Aggregate`|<span data-ttu-id="74215-155">Mit dem `Aggregate`-Operator wird ein Ausdruck berechnet, der MIN, MAX, SUM, COUNT oder AVG enthält.</span><span class="sxs-lookup"><span data-stu-id="74215-155">The `Aggregate` operator calculates an expression containing MIN, MAX, SUM, COUNT or AVG.</span></span> <span data-ttu-id="74215-156">Der `Aggregate`-Operator kann ein logischer oder physischer Operator sein.</span><span class="sxs-lookup"><span data-stu-id="74215-156">The `Aggregate` operator can be a logical operator or a physical operator.</span></span>|  
|<span data-ttu-id="74215-157">![Operator für arithmetische Ausdrücke (Symbol)](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Operator für arithmetische Ausdrücke (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-157">![Arithmetic expression operator icon](../../2014/database-engine/media/arithmetic-expression-32x-2.gif "Arithmetic expression operator icon")</span></span>|`Arithmetic Expression`|<span data-ttu-id="74215-158">Der `Arithmetic Expression`-Operator berechnet einen neuen Wert anhand vorhandener Werte in einer Zeile.</span><span class="sxs-lookup"><span data-stu-id="74215-158">The `Arithmetic Expression` operator computes a new value from existing values in a row.</span></span> <span data-ttu-id="74215-159">`Arithmetic Expression` wird in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] nicht verwendet.</span><span class="sxs-lookup"><span data-stu-id="74215-159">`Arithmetic Expression` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
|<span data-ttu-id="74215-160">![Assert-Operator (Symbol)](../../2014/database-engine/media/assert-32x.gif "Assert-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-160">![Assert operator icon](../../2014/database-engine/media/assert-32x.gif "Assert operator icon")</span></span>|`Assert`|<span data-ttu-id="74215-161">Der `Assert`-Operator überprüft eine Bedingung.</span><span class="sxs-lookup"><span data-stu-id="74215-161">The `Assert` operator verifies a condition.</span></span> <span data-ttu-id="74215-162">Beispielsweise überprüft er die referenzielle Integrität, oder er stellt sicher, dass eine skalare Unterabfrage eine Zeile zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="74215-162">For example, it validates referential integrity or ensures that a scalar subquery returns one row.</span></span> <span data-ttu-id="74215-163">Für jede Eingabezeile wertet der- `Assert` Operator den Ausdruck in der- `Argument` Spalte des Ausführungs Plans aus.</span><span class="sxs-lookup"><span data-stu-id="74215-163">For each input row, the `Assert` operator evaluates the expression in the `Argument` column of the execution plan.</span></span> <span data-ttu-id="74215-164">Wird der Ausdruck mit NULL ausgewertet, so wird die Zeile an den `Assert`-Operator übergeben, und die Ausführung der Abfrage wird fortgesetzt.</span><span class="sxs-lookup"><span data-stu-id="74215-164">If this expression evaluates to NULL, the row is passed through the `Assert` operator and the query execution continues.</span></span> <span data-ttu-id="74215-165">Wird dieser Ausdruck zu einem Nicht-NULL-Wert ausgewertet, so wird der entsprechende Fehler ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="74215-165">If this expression evaluates to a nonnull value, the appropriate error will be raised.</span></span> <span data-ttu-id="74215-166">Der `Assert`-Operator ist ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-166">The `Assert` operator is a physical operator.</span></span>|  
|<span data-ttu-id="74215-167">![Assign-Sprachelement (Symbol)](../../2014/database-engine/media/assign-32.gif "Assign-Sprachelement (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-167">![Assign language element icon](../../2014/database-engine/media/assign-32.gif "Assign language element icon")</span></span>|`Assign`|<span data-ttu-id="74215-168">Der `Assign`-Operator weist einer Variablen den Wert eines Ausdrucks oder einer Konstanten zu.</span><span class="sxs-lookup"><span data-stu-id="74215-168">The `Assign` operator assigns the value of an expression or a constant to a variable.</span></span> <span data-ttu-id="74215-169">`Assign` ist ein Sprachelement.</span><span class="sxs-lookup"><span data-stu-id="74215-169">`Assign` is a language element.</span></span>|  
|<span data-ttu-id="74215-170">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-170">None</span></span>|`Asnyc Concat`|<span data-ttu-id="74215-171">Der `Asnyc Concat`-Operator wird nur in Remoteabfragen (verteilten Abfragen) verwendet.</span><span class="sxs-lookup"><span data-stu-id="74215-171">The `Asnyc Concat` operator is used only in remote queries (distributed queries).</span></span> <span data-ttu-id="74215-172">Diese Anweisung weist *n* untergeordnete Knoten und einen übergeordneten Knoten auf.</span><span class="sxs-lookup"><span data-stu-id="74215-172">It has *n* children and one parent node.</span></span> <span data-ttu-id="74215-173">Gewöhnlich sind manche untergeordnete Knoten Remotecomputer, die an einer verteilten Abfrage beteiligt sind.</span><span class="sxs-lookup"><span data-stu-id="74215-173">Usually, some of the children are remote computers that participate in a distributed query.</span></span> <span data-ttu-id="74215-174">`Asnyc Concat` gibt `open()`-Aufrufe für alle untergeordneten Knoten gleichzeitig aus und wendet dann auf jeden untergeordneten Knoten eine Bitmap an.</span><span class="sxs-lookup"><span data-stu-id="74215-174">`Asnyc Concat` issues `open()` calls to all of the children simultaneously and then applies a bitmap to each child.</span></span> <span data-ttu-id="74215-175">Für jedes Bit, das 1 ist, sendet `Async Concat` auf Anfrage die Ausgabezeilen an den übergeordneten Knoten.</span><span class="sxs-lookup"><span data-stu-id="74215-175">For each bit that is a 1, `Async Concat` sends the output rows to the parent node on demand.</span></span>|  
|<span data-ttu-id="74215-176">![Bitmap-Operator (Symbol)](../../2014/database-engine/media/bitmap-32x.gif "Bitmap-Operatorsymbol")</span><span class="sxs-lookup"><span data-stu-id="74215-176">![Bitmap operator icon](../../2014/database-engine/media/bitmap-32x.gif "Bitmap operator icon")</span></span>|`Bitmap`|[!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]<span data-ttu-id="74215-177">verwendet den- `Bitmap` Operator, um das Filtern von Bitmaps in parallelen Abfrage Plänen zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="74215-177">uses the `Bitmap` operator to implement bitmap filtering in parallel query plans.</span></span> <span data-ttu-id="74215-178">Durch das Filtern von Bitmaps wird die Ausführung der Abfrage beschleunigt, indem Zeilen mit Schlüsselwerten eliminiert werden, die keine joindatensätze ausgeben können, bevor Zeilen durch einen anderen Operator wie den Operator übergeben werden `Parallelism`</span><span class="sxs-lookup"><span data-stu-id="74215-178">Bitmap filtering speeds up query execution by eliminating rows with key values that cannot produce any join records before passing rows through another operator such as the `Parallelism` operator.</span></span> <span data-ttu-id="74215-179">Ein Bitmapfilter verwendet eine kompakte Darstellung einer Gruppe von Werten aus einer Tabelle in einem Bereich der Operatorstruktur, um Zeilen aus einer zweiten Tabelle in einem anderen Bereich der Struktur zu filtern.</span><span class="sxs-lookup"><span data-stu-id="74215-179">A bitmap filter uses a compact representation of a set of values from a table in one part of the operator tree to filter rows from a second table in another part of the tree.</span></span> <span data-ttu-id="74215-180">Durch das Entfernen unnötiger Zeilen zu einem frühen Zeitpunkt in der Abfrage müssen nachfolgende Operatoren weniger Zeilen verarbeiten, wodurch eine Steigerung der Gesamtleistung der Abfrage erzielt werden kann.</span><span class="sxs-lookup"><span data-stu-id="74215-180">By removing unnecessary rows early in the query, subsequent operators have fewer rows to work with, and the overall performance of the query improves.</span></span> <span data-ttu-id="74215-181">Der Optimierer bestimmt, wann eine Bitmap eine ausreichende Selektivität aufweist, damit sie verwendet werden kann, und in welchen Operatoren der Filter angewendet wird.</span><span class="sxs-lookup"><span data-stu-id="74215-181">The optimizer determines when a bitmap is selective enough to be useful and in which operators to apply the filter.</span></span> <span data-ttu-id="74215-182">`Bitmap` ist ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-182">`Bitmap` is a physical operator.</span></span>|  
|<span data-ttu-id="74215-183">![Bitmap-Operator (Symbol)](../../2014/database-engine/media/bitmap-32x.gif "Bitmap-Operatorsymbol")</span><span class="sxs-lookup"><span data-stu-id="74215-183">![Bitmap operator icon](../../2014/database-engine/media/bitmap-32x.gif "Bitmap operator icon")</span></span>|`Bitmap Create`|<span data-ttu-id="74215-184">Der `Bitmap Create`-Operator wird in der Showplanausgabe dort angezeigt, wo Bitmaps erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="74215-184">The `Bitmap Create` operator appears in the Showplan output where bitmaps are built.</span></span> <span data-ttu-id="74215-185">`Bitmap Create` ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-185">`Bitmap Create` is a logical operator.</span></span>|  
|<span data-ttu-id="74215-186">![Bookmark Lookup-Operator (Symbol)](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark Lookup-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-186">![Bookmark lookup operator icon](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark lookup operator icon")</span></span>|`Bookmark Lookup`|<span data-ttu-id="74215-187">Der `Bookmark Lookup`-Operator verwendet ein Lesezeichen (Zeilen-ID oder Gruppierungsschlüssel), um die zugehörige Zeile in der Tabelle oder im gruppierten Index nachzuschlagen.</span><span class="sxs-lookup"><span data-stu-id="74215-187">The `Bookmark Lookup` operator uses a bookmark (row ID or clustering key) to look up the corresponding row in the table or clustered index.</span></span> <span data-ttu-id="74215-188">Die `Argument` Spalte enthält die Lesezeichen Bezeichnung, mit der die Zeile in der Tabelle oder im gruppierten Index gesucht wird.</span><span class="sxs-lookup"><span data-stu-id="74215-188">The `Argument` column contains the bookmark label used to look up the row in the table or clustered index.</span></span> <span data-ttu-id="74215-189">Die `Argument` Spalte enthält auch den Namen der Tabelle oder des gruppierten Indexes, in der die Zeile gesucht wird.</span><span class="sxs-lookup"><span data-stu-id="74215-189">The `Argument` column also contains the name of the table or clustered index in which the row is looked up.</span></span> <span data-ttu-id="74215-190">Wenn die with Prefetch-Klausel in der- `Argument` Spalte angezeigt wird, hat der Abfrage Prozessor ermittelt, dass es optimal ist, beim Suchen von Lesezeichen in der Tabelle oder im gruppierten Index das asynchrone vorab abrufen (Read-Ahead) zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="74215-190">If the WITH PREFETCH clause appears in the `Argument` column, the query processor has determined that it is optimal to use asynchronous prefetching (read-ahead) when looking up bookmarks in the table or clustered index.</span></span><br /><br /> <span data-ttu-id="74215-191">`Bookmark Lookup` wird in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] nicht verwendet.</span><span class="sxs-lookup"><span data-stu-id="74215-191">`Bookmark Lookup` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span> <span data-ttu-id="74215-192">`Clustered Index Seek` und `RID Lookup` stellen hingegen Suchfunktionen für Lesezeichen bereit.</span><span class="sxs-lookup"><span data-stu-id="74215-192">Instead, `Clustered Index Seek` and `RID Lookup` provide bookmark lookup functionality.</span></span> <span data-ttu-id="74215-193">Auch der `Key Lookup`-Operator stellt diese Funktionalität bereit.</span><span class="sxs-lookup"><span data-stu-id="74215-193">The `Key Lookup` operator also provides this functionality.</span></span>|  
|<span data-ttu-id="74215-194">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-194">None</span></span>|`Branch Repartition`|<span data-ttu-id="74215-195">Ein paralleler Abfrageplan kann mitunter logische Bereiche von Iteratoren enthalten.</span><span class="sxs-lookup"><span data-stu-id="74215-195">In a parallel query plan, sometimes there are conceptual regions of iterators.</span></span> <span data-ttu-id="74215-196">Alle Iteratoren innerhalb eines solchen Bereichs können durch parallele Threads ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="74215-196">All of the iterators within such a region can be executed by parallel threads.</span></span> <span data-ttu-id="74215-197">Die Bereiche selbst müssen seriell ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="74215-197">The regions themselves must be executed serially.</span></span> <span data-ttu-id="74215-198">Einige der `Parallelism`-Iteratoren innerhalb eines einzelnen Bereichs werden `Branch Repartition` genannt.</span><span class="sxs-lookup"><span data-stu-id="74215-198">Some of the `Parallelism` iterators within an individual region are called `Branch Repartition`.</span></span> <span data-ttu-id="74215-199">Der `Parallelism`-Iterator an der Grenze zwischen zwei Bereichen wird `Segment Repartition` genannt.</span><span class="sxs-lookup"><span data-stu-id="74215-199">The `Parallelism` iterator at the boundary of two such regions is called `Segment Repartition`.</span></span> <span data-ttu-id="74215-200">`Branch Repartition` und `Segment Repartition` sind logische Operatoren.</span><span class="sxs-lookup"><span data-stu-id="74215-200">`Branch Repartition` and `Segment Repartition` are logical operators.</span></span>|  
|<span data-ttu-id="74215-201">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-201">None</span></span>|`Broadcast`|<span data-ttu-id="74215-202">`Broadcast`weist einen untergeordneten Knoten und *n* übergeordnete Knoten auf.</span><span class="sxs-lookup"><span data-stu-id="74215-202">`Broadcast` has one child node and *n* parent nodes.</span></span> <span data-ttu-id="74215-203">`Broadcast` sendet die Eingabezeilen bei Bedarf an mehrere Consumer.</span><span class="sxs-lookup"><span data-stu-id="74215-203">`Broadcast` sends its input rows to multiple consumers on demand.</span></span> <span data-ttu-id="74215-204">Jeder Consumer erhält alle Zeilen.</span><span class="sxs-lookup"><span data-stu-id="74215-204">Each consumer gets all of the rows.</span></span> <span data-ttu-id="74215-205">Wenn z.B. alle Consumer sich auf der Erstellungsseite eines Hashjoins befinden, werden *n* Kopien der Hashtabellen erstellt.</span><span class="sxs-lookup"><span data-stu-id="74215-205">For example, if all of the consumers are build sides of a hash join, then *n* copies of the hash tables will be built.</span></span>|  
|<span data-ttu-id="74215-206">![Build Hash-Operator (Symbol)](../../2014/database-engine/media/build-hash.gif "Build Hash-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-206">![Build hash operator icon](../../2014/database-engine/media/build-hash.gif "Build hash operator icon")</span></span>|`Build Hash`|<span data-ttu-id="74215-207">Gibt die Erstellung einer Batchhashtabelle für einen speicheroptimierten xVelocity-columnstore-Index an.</span><span class="sxs-lookup"><span data-stu-id="74215-207">Indicates the build of a batch hash table for an xVelocity memory optimized columnstore index.</span></span>|  
|<span data-ttu-id="74215-208">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-208">None</span></span>|`Cache`|<span data-ttu-id="74215-209">`Cache`ist eine spezialisierte Version des **Spool** -Operators.</span><span class="sxs-lookup"><span data-stu-id="74215-209">`Cache` is a specialized version of the **Spool** operator.</span></span> <span data-ttu-id="74215-210">Er speichert nur eine Datenzeile.</span><span class="sxs-lookup"><span data-stu-id="74215-210">It stores only one row of data.</span></span> <span data-ttu-id="74215-211">`Cache` ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-211">`Cache` is a logical operator.</span></span> <span data-ttu-id="74215-212">`Cache` wird in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)] nicht verwendet.</span><span class="sxs-lookup"><span data-stu-id="74215-212">`Cache` is not used in [!INCLUDE[ssCurrent](../includes/sscurrent-md.md)].</span></span>|  
|<span data-ttu-id="74215-213">![Clustered Index Delete-Operator (Symbol)](../../2014/database-engine/media/clustered-index-delete-32x.gif "Clustered Index Delete-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-213">![Clustered index delete operator icon](../../2014/database-engine/media/clustered-index-delete-32x.gif "Clustered index delete operator icon")</span></span>|`Clustered Index Delete`|<span data-ttu-id="74215-214">Der `Clustered Index Delete`-Operator löscht Zeilen aus dem gruppierten Index, der in der Argument-Spalte des Abfrageausführungsplans angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="74215-214">The `Clustered Index Delete` operator deletes rows from the clustered index specified in the Argument column of the query execution plan.</span></span> <span data-ttu-id="74215-215">Wenn ein WHERE:()-Prädikat in der Argument-Spalte vorhanden ist, werden nur die Zeilen gelöscht, die das Prädikat erfüllen.`Clustered Index Delete`</span><span class="sxs-lookup"><span data-stu-id="74215-215">If a WHERE:() predicate is present in the Argument column, then only those rows that satisfy the predicate are deleted.`Clustered Index Delete`</span></span> <span data-ttu-id="74215-216"> ist ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-216">is a physical operator.</span></span>|  
|<span data-ttu-id="74215-217">![Clustered Index Insert-Operator (Symbol)](../../2014/database-engine/media/clustered-index-insert-32x.gif "Clustered Index Insert-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-217">![Clustered index insert operator icon](../../2014/database-engine/media/clustered-index-insert-32x.gif "Clustered index insert operator icon")</span></span>|`Clustered Index Insert`|<span data-ttu-id="74215-218">Der `Clustered Index Insert`-Showplanoperator fügt die Eingabezeilen in den gruppierten Index ein, der in der Argument-Spalte angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="74215-218">The `Clustered Index Insert` Showplan operator inserts rows from its input into the clustered index specified in the Argument column.</span></span> <span data-ttu-id="74215-219">Die Argument-Spalte enthält auch ein SET:()-Prädikat, das den für die einzelnen Spalten festgelegten Wert anzeigt.</span><span class="sxs-lookup"><span data-stu-id="74215-219">The Argument column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="74215-220">Wenn `Clustered Index Insert` keine untergeordneten Elemente für Einfügewerte aufweist, wird die eingefügte Zeile aus dem `Insert` Operator selbst übernommen.`Clustered Index Insert`</span><span class="sxs-lookup"><span data-stu-id="74215-220">If `Clustered Index Insert` has no children for insert values, the row inserted is taken from the `Insert` operator itself.`Clustered Index Insert`</span></span> <span data-ttu-id="74215-221"> ist ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-221">is a physical operator.</span></span>|  
|<span data-ttu-id="74215-222">![Clustered Index Merge-Operator](../../2014/database-engine/media/clustered-index-merge-32x.gif "Clustered Index Merge-Operator")</span><span class="sxs-lookup"><span data-stu-id="74215-222">![Clustered index merge operator](../../2014/database-engine/media/clustered-index-merge-32x.gif "Clustered index merge operator")</span></span>|<span data-ttu-id="74215-223">**Clustered Index Merge**</span><span class="sxs-lookup"><span data-stu-id="74215-223">**Clustered Index Merge**</span></span>|<span data-ttu-id="74215-224">Der **Clustered Index Merge** -Operator übernimmt einen Mergedatenstrom für einen gruppierten Index.</span><span class="sxs-lookup"><span data-stu-id="74215-224">The **Clustered Index Merge** operator applies a merge data stream to a clustered index.</span></span> <span data-ttu-id="74215-225">Der-Operator löscht oder aktualisiert Zeilen aus dem gruppierten Index, der in der-Spalte des-Operators angegeben ist, oder fügt diese Zeilen ein `Argument` .</span><span class="sxs-lookup"><span data-stu-id="74215-225">The operator deletes, updates, or inserts rows from the clustered index specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="74215-226">Der tatsächlich ausgeführte Vorgang hängt vom Lauf Zeitwert der **Aktions** Spalte ab, die in der- `Argument` Spalte des-Operators angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="74215-226">The actual operation performed depends on the runtime value of the **ACTION** column specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="74215-227">**Clustered Index Merge** ist ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-227">**Clustered Index Merge** is a physical operator.</span></span>|  
|<span data-ttu-id="74215-228">![Clustered Index Scan-Operator (Symbol)](../../2014/database-engine/media/clustered-index-scan-32x.gif "Clustered Index Scan-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-228">![Clustered index scan operator icon](../../2014/database-engine/media/clustered-index-scan-32x.gif "Clustered index scan operator icon")</span></span>|`Clustered Index Scan`|<span data-ttu-id="74215-229">Der `Clustered Index Scan`-Operator scannt den gruppierten Index, der in der Argument-Spalte des Abfrageausführungsplans angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="74215-229">The `Clustered Index Scan` operator scans the clustered index specified in the Argument column of the query execution plan.</span></span> <span data-ttu-id="74215-230">Wenn ein optionales WHERE:()-Prädikat vorhanden ist, werden nur die Zeilen zurückgegeben, die das Prädikat erfüllen.</span><span class="sxs-lookup"><span data-stu-id="74215-230">When an optional WHERE:() predicate is present, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="74215-231">Wenn die Argument-Spalte die ORDERED-Klausel enthält, hat der Abfrageprozessor angefordert, dass die Ausgabe der Zeilen in der Reihenfolge zurückgegeben wird, in der sie vom gruppierten Index sortiert wurden.</span><span class="sxs-lookup"><span data-stu-id="74215-231">If the Argument column contains the ORDERED clause, the query processor has requested that the output of the rows be returned in the order in which the clustered index has sorted it.</span></span> <span data-ttu-id="74215-232">Wurde die ORDERED-Klausel nicht angegeben, scannt die Speicher-Engine den Index optimal (wobei die Ausgabe nicht unbedingt sortiert ist).</span><span class="sxs-lookup"><span data-stu-id="74215-232">If the ORDERED clause is not present, the storage engine scans the index in the optimal way, without necessarily sorting the output.</span></span> <span data-ttu-id="74215-233">`Clustered Index Scan` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-233">`Clustered Index Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-234">![Clustered Index Seek-Operator (Symbol)](../../2014/database-engine/media/clustered-index-seek-32x.gif "Clustered Index Seek-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-234">![Clustered index seek operator icon](../../2014/database-engine/media/clustered-index-seek-32x.gif "Clustered index seek operator icon")</span></span>|`Clustered Index Seek`|<span data-ttu-id="74215-235">Der `Clustered Index Seek`-Operator verwendet die Suchfunktionen der Indizes, um Zeilen aus einem gruppierten Index abzurufen.</span><span class="sxs-lookup"><span data-stu-id="74215-235">The `Clustered Index Seek` operator uses the seeking ability of indexes to retrieve rows from a clustered index.</span></span> <span data-ttu-id="74215-236">Die `Argument` Spalte enthält den Namen des verwendeten gruppierten Indexes und das Seek:()-Prädikat.</span><span class="sxs-lookup"><span data-stu-id="74215-236">The `Argument` column contains the name of the clustered index being used and the SEEK:() predicate.</span></span> <span data-ttu-id="74215-237">Die Speicher-Engine verarbeitet mit diesem Index nur die Zeilen, die das SEEK:()-Prädikat erfüllen.</span><span class="sxs-lookup"><span data-stu-id="74215-237">The storage engine uses the index to process only those rows that satisfy this SEEK:() predicate.</span></span> <span data-ttu-id="74215-238">Es kann auch ein WHERE:()-Prädikat einschließen, das die Speicher-Engine für alle Zeilen auswertet, die das SEEK:()-Prädikat erfüllen. Dies ist jedoch optional, und es werden keine Indizes für diesen Prozess verwendet.</span><span class="sxs-lookup"><span data-stu-id="74215-238">It can also include a WHERE:() predicate where the storage engine evaluates against all rows that satisfy the SEEK:() predicate, but this is optional and does not use indexes to complete this process.</span></span><br /><br /> <span data-ttu-id="74215-239">Wenn die `Argument` Spalte die sortierte Klausel enthält, hat der Abfrage Prozessor ermittelt, dass die Zeilen in der Reihenfolge zurückgegeben werden müssen, in der Sie vom gruppierten Index sortiert wurden.</span><span class="sxs-lookup"><span data-stu-id="74215-239">If the `Argument` column contains the ORDERED clause, the query processor has determined that the rows must be returned in the order in which the clustered index has sorted them.</span></span> <span data-ttu-id="74215-240">Wurde die ORDERED-Klausel nicht angegeben, durchsucht die Speicher-Engine den Index optimal (wobei die Ausgabe nicht unbedingt sortiert ist).</span><span class="sxs-lookup"><span data-stu-id="74215-240">If the ORDERED clause is not present, the storage engine searches the index in the optimal way, without necessarily sorting the output.</span></span> <span data-ttu-id="74215-241">Die Ausgabe in der ursprünglichen Reihenfolge kann weniger effizient sein als die unsortierte Ausgabe.</span><span class="sxs-lookup"><span data-stu-id="74215-241">Allowing the output to retain its ordering can be less efficient than producing nonsorted output.</span></span> <span data-ttu-id="74215-242">Bei der Anzeige des LOOKUP-Schlüsselworts, wird ein Bookmark Lookup ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="74215-242">When the keyword LOOKUP appears, then a bookmark lookup is being performed.</span></span> <span data-ttu-id="74215-243">In [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] und höheren Versionen stellt der- `Key Lookup` Operator die Bookmark Suche-Funktionalität bereit.</span><span class="sxs-lookup"><span data-stu-id="74215-243">In [!INCLUDE[ssKatmai](../includes/sskatmai-md.md)] and later versions, the `Key Lookup` operator provides bookmark lookup functionality.</span></span> <span data-ttu-id="74215-244">`Clustered Index Seek` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-244">`Clustered Index Seek` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-245">![Clustered Index Update-Operator (Symbol)](../../2014/database-engine/media/clustered-index-update-32x.gif "Clustered Index Update-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-245">![Clustered index update operator icon](../../2014/database-engine/media/clustered-index-update-32x.gif "Clustered index update operator icon")</span></span>|`Clustered Index Update`|<span data-ttu-id="74215-246">Der- `Clustered Index Update` Operator aktualisiert die Eingabezeilen in dem gruppierten Index, der in der-Spalte angegeben ist `Argument` . Wenn ein WHERE:()-Prädikat vorhanden ist, werden nur die Zeilen aktualisiert, die dieses Prädikat erfüllen.</span><span class="sxs-lookup"><span data-stu-id="74215-246">The `Clustered Index Update` operator updates input rows in the clustered index specified in the `Argument` column.If a WHERE:() predicate is present, only those rows that satisfy this predicate are updated.</span></span> <span data-ttu-id="74215-247">Wenn ein SET:()-Prädikat vorhanden ist, wird jede aktualisierte Spalte auf diesen Wert festgelegt.</span><span class="sxs-lookup"><span data-stu-id="74215-247">If a SET:() predicate is present, each updated column is set to this value.</span></span> <span data-ttu-id="74215-248">Wenn ein DEFINE:()-Prädikat vorhanden ist, werden die durch diesen Operator definierten Werte aufgelistet.</span><span class="sxs-lookup"><span data-stu-id="74215-248">If a DEFINE:() predicate is present, the values that this operator defines are listed.</span></span> <span data-ttu-id="74215-249">Auf diese Werte kann in der SET-Klausel oder an anderer Stelle in diesem Operator sowie in dieser Abfrage verwiesen werden.</span><span class="sxs-lookup"><span data-stu-id="74215-249">These values may be referenced in the SET clause or elsewhere within this operator and elsewhere within this query.</span></span> <span data-ttu-id="74215-250">`Clustered Index Update` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-250">`Clustered Index Update` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-251">![Collapse-Operator (Symbol)](../../2014/database-engine/media/collapse-32x.gif "Collapse-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-251">![Collapse operator icon](../../2014/database-engine/media/collapse-32x.gif "Collapse operator icon")</span></span>|`Collapse`|<span data-ttu-id="74215-252">Der `Collapse`-Operator optimiert die Verarbeitung von Aktualisierungen.</span><span class="sxs-lookup"><span data-stu-id="74215-252">The `Collapse` operator optimizes update processing.</span></span> <span data-ttu-id="74215-253">Eine Aktualisierung kann bei ihrer Ausführung mithilfe des `Split`-Operators in einen Lösch- und einen Einfügevorgang aufgeteilt werden.</span><span class="sxs-lookup"><span data-stu-id="74215-253">When an update is performed, it can be split (using the `Split` operator) into a delete and an insert.</span></span> <span data-ttu-id="74215-254">Die `Argument` Spalte enthält eine Group by:()-Klausel, die eine Liste von Schlüssel Spalten angibt.</span><span class="sxs-lookup"><span data-stu-id="74215-254">The `Argument` column contains a GROUP BY:() clause that specifies a list of key columns.</span></span> <span data-ttu-id="74215-255">Wenn der Abfrageprozessor benachbarte Zeilen erkennt, die dieselben Schlüsselwerte löschen und einfügen, werden diese separaten Vorgänge durch einen einzigen effektiveren Updatevorgang ersetzt.</span><span class="sxs-lookup"><span data-stu-id="74215-255">If the query processor encounters adjacent rows that delete and insert the same key values, it replaces these separate operations with a single more efficient update operation.</span></span> <span data-ttu-id="74215-256">`Collapse` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-256">`Collapse` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-257">![Columnstore-Indexscan](../../2014/database-engine/media/columnstoreindexscan.gif "Columnstore-Indexscan")</span><span class="sxs-lookup"><span data-stu-id="74215-257">![Columnstore Index Scan](../../2014/database-engine/media/columnstoreindexscan.gif "Columnstore Index Scan")</span></span>|`Columnstore Index Scan`|<span data-ttu-id="74215-258">Der- `Columnstore Index Scan` Operator scannt den columnstore--Index, der in der- `Argument` Spalte des Abfrage Ausführungs Plans angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="74215-258">The `Columnstore Index Scan` operator scans the columnstore index specified in the `Argument` column of the query execution plan.</span></span>|  
|<span data-ttu-id="74215-259">![Compute Scalar-Operator (Symbol)](../../2014/database-engine/media/compute-scalar-32x.gif "Compute Scalar-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-259">![Compute scalar operator icon](../../2014/database-engine/media/compute-scalar-32x.gif "Compute scalar operator icon")</span></span>|`Compute Scalar`|<span data-ttu-id="74215-260">Der- `Compute Scalar` Operator wertet einen Ausdruck aus, um einen berechneten skalaren Wert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="74215-260">The `Compute Scalar` operator evaluates an expression to produce a computed scalar value.</span></span> <span data-ttu-id="74215-261">Dieser kann an den Benutzer zurückgegeben und/oder an anderer Stelle in der Abfrage als Verweis verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="74215-261">This may then be returned to the user, referenced elsewhere in the query, or both.</span></span> <span data-ttu-id="74215-262">Ein Beispiel für beide Fälle ist ein Filterprädikat oder Joinprädikat.</span><span class="sxs-lookup"><span data-stu-id="74215-262">An example of both is in a filter predicate or join predicate.</span></span> <span data-ttu-id="74215-263">`Compute Scalar` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-263">`Compute Scalar` is a logical and physical operator.</span></span><br /><br /> <span data-ttu-id="74215-264">`Compute Scalar`Operatoren, die in von SET STATISTICS XML generierten Showplans angezeigt werden, enthalten möglicherweise das- `RunTimeInformation` Element nicht.</span><span class="sxs-lookup"><span data-stu-id="74215-264">`Compute Scalar` operators that appear in Showplans generated by SET STATISTICS XML might not contain the `RunTimeInformation` element.</span></span> <span data-ttu-id="74215-265">In grafischen Showplans können **Tatsächliche Zeilen**, **Tatsächlich erneuerte Bindungen**und **Tatsächliche Zurückspulvorgänge** im Fenster **Eigenschaften** fehlen, wenn die Option **Tatsächlichen Ausführungsplan einschließen** in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)]aktiviert wurde.</span><span class="sxs-lookup"><span data-stu-id="74215-265">In graphical Showplans, **Actual Rows**, **Actual Rebinds**, and **Actual Rewinds** might be absent from the **Properties** window when the **Include Actual Execution Plan** option is selected in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)].</span></span> <span data-ttu-id="74215-266">Wenn diese Situation eintritt, bedeutet das, dass diese Operatoren zwar im kompilierten Abfrageplan verwendet wurden, ihre Arbeit jedoch von anderen Operatoren im Laufzeitabfrageplan verrichtet wurde.</span><span class="sxs-lookup"><span data-stu-id="74215-266">When this occurs, it means that although these operators were used in the compiled query plan, their work was performed by other operators in the run-time query plan.</span></span> <span data-ttu-id="74215-267">Beachten Sie außerdem, dass die Anzahl der Ausführungen in der von SET STATISTICS PROFILE generierten Showplanausgabe gleich der Summe der erneuten Bindungen und Zurückspulvorgänge in den von SET STATISTICS XML generierten Showplans ist.</span><span class="sxs-lookup"><span data-stu-id="74215-267">Also note that the number of executes in Showplan output generated by SET STATISTICS PROFILE is equivalent to the sum of rebinds and rewinds in Showplans generated by SET STATISTICS XML.</span></span>|  
|<span data-ttu-id="74215-268">![Concatenation-Operator (Symbol)](../../2014/database-engine/media/concatenation-32x.gif "Concatenation-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-268">![Concatenation operator icon](../../2014/database-engine/media/concatenation-32x.gif "Concatenation operator icon")</span></span>|<span data-ttu-id="74215-269">**Concatenation**</span><span class="sxs-lookup"><span data-stu-id="74215-269">**Concatenation**</span></span>|<span data-ttu-id="74215-270">Der **Concatenation** -Operator scannt mehrere Eingaben und gibt die gescannten Zeilen zurück.</span><span class="sxs-lookup"><span data-stu-id="74215-270">The **Concatenation** operator scans multiple inputs, returning each row scanned.</span></span> <span data-ttu-id="74215-271">**Concatenation** wird im Allgemeinen verwendet, um das [!INCLUDE[tsql](../includes/tsql-md.md)] -Konstrukt UNION ALL zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="74215-271">**Concatenation** is typically used to implement the [!INCLUDE[tsql](../includes/tsql-md.md)] UNION ALL construct.</span></span> <span data-ttu-id="74215-272">Der physische Operator **Concatenation** verfügt über mindestens zwei Eingaben und eine Ausgabe.</span><span class="sxs-lookup"><span data-stu-id="74215-272">The **Concatenation** physical operator has two or more inputs and one output.</span></span> <span data-ttu-id="74215-273">Concatenation kopiert Zeilen aus dem ersten Eingabedatenstrom in den Ausgabedatenstrom und wiederholt diese Operation anschließend für jeden weiteren Eingabedatenstrom.</span><span class="sxs-lookup"><span data-stu-id="74215-273">Concatenation copies rows from the first input stream to the output stream, then repeats this operation for each additional input stream.</span></span> <span data-ttu-id="74215-274">**Concatenation** ist sowohl ein logischer als auch ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-274">**Concatenation** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-275">![Constant Scan-Operator (Symbol)](../../2014/database-engine/media/constant-scan-32x.gif "Constant Scan-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-275">![Constant scan operator icon](../../2014/database-engine/media/constant-scan-32x.gif "Constant scan operator icon")</span></span>|`Constant Scan`|<span data-ttu-id="74215-276">Der- `Constant Scan` Operator führt eine oder mehrere Konstante Zeilen in eine Abfrage ein.</span><span class="sxs-lookup"><span data-stu-id="74215-276">The `Constant Scan` operator introduces one or more constant rows into a query.</span></span> <span data-ttu-id="74215-277">Ein- `Compute Scalar` Operator wird häufig nach einem verwendet `Constant Scan` , um einer Zeile, die vom-Operator erzeugt wurde, Spalten hinzuzufügen `Constant Scan` .</span><span class="sxs-lookup"><span data-stu-id="74215-277">A `Compute Scalar` operator is often used after a `Constant Scan` to add columns to a row produced by the `Constant Scan` operator.</span></span>|  
|<span data-ttu-id="74215-278">![Symbol für Convert-Sprachelement (Datenbank-Engine)](../../2014/database-engine/media/convert-32x.gif "Symbol für Convert-Sprachelement (Datenbank-Engine)")</span><span class="sxs-lookup"><span data-stu-id="74215-278">![Convert (Database Engine) language element icon](../../2014/database-engine/media/convert-32x.gif "Convert (Database Engine) language element icon")</span></span>|`Convert`|<span data-ttu-id="74215-279">Der `Convert`-Operator wandelt einen skalaren Datentyp in einen anderen um.</span><span class="sxs-lookup"><span data-stu-id="74215-279">The `Convert` operator converts one scalar data type to another.</span></span> <span data-ttu-id="74215-280">`Convert` ist ein Sprachelement.</span><span class="sxs-lookup"><span data-stu-id="74215-280">`Convert` is a language element.</span></span>|  
|<span data-ttu-id="74215-281">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-281">None</span></span>|`Cross Join`|<span data-ttu-id="74215-282">Der `Cross Join`-Operator verknüpft jede Zeile der ersten (oberen) Eingabe mit jeder Zeile der zweiten (unteren) Eingabe.</span><span class="sxs-lookup"><span data-stu-id="74215-282">The `Cross Join` operator joins each row from the first (top) input with each row from the second (bottom) input.</span></span> <span data-ttu-id="74215-283">`Cross Join` ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-283">`Cross Join` is a logical operator.</span></span>|  
|<span data-ttu-id="74215-284">![Cursor Catchall-Cursoroperator (Symbol)](../../2014/database-engine/media/cursor-catch-all.gif "Cursor Catchall-Cursoroperator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-284">![Cursor catchall cursor operator icon](../../2014/database-engine/media/cursor-catch-all.gif "Cursor catchall cursor operator icon")</span></span>|`catchall`|<span data-ttu-id="74215-285">Das Sammelsymbol wird angezeigt, wenn von der Logik, die grafische Showplans erzeugt, kein geeignetes Symbol für den Iterator gefunden werden kann.</span><span class="sxs-lookup"><span data-stu-id="74215-285">The catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical showplans.</span></span> <span data-ttu-id="74215-286">Das Sammelsymbol zeigt nicht notwendigerweise eine Fehlerbedingung an.</span><span class="sxs-lookup"><span data-stu-id="74215-286">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="74215-287">Es stehen drei Sammelsymbole zur Verfügung: blau (für Iteratoren), orange (für Cursor) und grün (für [!INCLUDE[tsql](../includes/tsql-md.md)] -Sprachelemente).</span><span class="sxs-lookup"><span data-stu-id="74215-287">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language elements).</span></span>|  
|<span data-ttu-id="74215-288">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-288">None</span></span>|<span data-ttu-id="74215-289">**Cursor**</span><span class="sxs-lookup"><span data-stu-id="74215-289">**Cursor**</span></span>|<span data-ttu-id="74215-290">Die logischen und physischen **Cursor** -Operatoren beschreiben, wie eine Abfrage oder Aktualisierung mit Cursoroperationen ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="74215-290">The **Cursor** logical and physical operators are used to describe how a query or update involving cursor operations is executed.</span></span> <span data-ttu-id="74215-291">Die physischen Operatoren beschreiben den Algorithmus, der für die physische Implementierung der Cursorverarbeitung verwendet wird, wie z. B. Verwenden eines keysetgesteuerten Cursors.</span><span class="sxs-lookup"><span data-stu-id="74215-291">The physical operators describe the physical implementation algorithm used to process the cursor; for example, using a keyset-driven cursor.</span></span> <span data-ttu-id="74215-292">Jeder Schritt bei der Ausführung eines Cursors benötigt einen physischen Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-292">Each step in the execution of a cursor involves a physical operator.</span></span> <span data-ttu-id="74215-293">Die logischen Operatoren beschreiben eine Cursoreigenschaft, z. B. der Cursor ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="74215-293">The logical operators describe a property of the cursor, such as the cursor is read only.</span></span><br /><br /> <span data-ttu-id="74215-294">Zu den logischen Operatoren zählen Asynchronous, Optimistic, Primary, Read Only, Scroll Locks sowie Secondary und Synchronous.</span><span class="sxs-lookup"><span data-stu-id="74215-294">Logical operators include Asynchronous, Optimistic, Primary, Read Only, Scroll Locks, and Secondary and Synchronous.</span></span><br /><br /> <span data-ttu-id="74215-295">Zu den physischen Operatoren zählen Dynamic, Fetch Query, Keyset, Population Query, Refresh Query und Snapshot.</span><span class="sxs-lookup"><span data-stu-id="74215-295">Physical operators include Dynamic, Fetch Query, Keyset, Population Query, Refresh Query and Snapshot.</span></span>|  
|<span data-ttu-id="74215-296">![Declare-Sprachelement (Symbol)](../../2014/database-engine/media/declare-32x.gif "Declare-Sprachelement (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-296">![Declare language element icon](../../2014/database-engine/media/declare-32x.gif "Declare language element icon")</span></span>|`Declare`|<span data-ttu-id="74215-297">Der- `Declare` Operator weist eine lokale Variable im Abfrageplan zu.</span><span class="sxs-lookup"><span data-stu-id="74215-297">The `Declare`  operator allocates a local variable in the query plan.</span></span> <span data-ttu-id="74215-298">`Declare` ist ein Sprachelement.</span><span class="sxs-lookup"><span data-stu-id="74215-298">`Declare` is a language element.</span></span>|  
|<span data-ttu-id="74215-299">![Delete-Operatorsymbol (Datenbank-Engine)](../../2014/database-engine/media/delete-32x.gif "Delete-Operatorsymbol (Datenbank-Engine)")</span><span class="sxs-lookup"><span data-stu-id="74215-299">![Delete (Database Engine) operator icon](../../2014/database-engine/media/delete-32x.gif "Delete (Database Engine) operator icon")</span></span>|`Delete`|<span data-ttu-id="74215-300">Der- `Delete` Operator löscht aus den Objekt Zeilen, die das optionale Prädikat in der `Argument` Spalte erfüllen.</span><span class="sxs-lookup"><span data-stu-id="74215-300">The `Delete` operator deletes from an object rows that satisfy the optional predicate in the `Argument` column.</span></span>|  
|<span data-ttu-id="74215-301">![Delete Scan-Operator (Symbol)](../../2014/database-engine/media/delete-scan-32x.gif "Delete Scan-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-301">![Delete scan operator icon](../../2014/database-engine/media/delete-scan-32x.gif "Delete scan operator icon")</span></span>|`Deleted Scan`|<span data-ttu-id="74215-302">Der `Deleted Scan`-Operator scannt die deleted-Tabelle in einem Trigger.</span><span class="sxs-lookup"><span data-stu-id="74215-302">The `Deleted Scan` operator scans the deleted table within a trigger.</span></span>|  
|<span data-ttu-id="74215-303">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-303">None</span></span>|`Distinct`|<span data-ttu-id="74215-304">Mithilfe des `Distinct`-Operators werden Duplikate aus einem Rowset oder aus einer Sammlung von Werten entfernt.</span><span class="sxs-lookup"><span data-stu-id="74215-304">The `Distinct` operator removes duplicates from a rowset or from a collection of values.</span></span> <span data-ttu-id="74215-305">`Distinct` ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-305">`Distinct` is a logical operator.</span></span>|  
|<span data-ttu-id="74215-306">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-306">None</span></span>|`Distinct Sort`|<span data-ttu-id="74215-307">Der `Distinct Sort` logische Operator scannt die Eingabe, entfernt Duplikate und sortiert nach den Spalten, die im eindeutigen Order by:()-Prädikat der `Argument` Spalte angegeben sind.</span><span class="sxs-lookup"><span data-stu-id="74215-307">The `Distinct Sort` logical operator scans the input, removing duplicates and sorting by the columns specified in the DISTINCT ORDER BY:() predicate of the `Argument` column.</span></span> <span data-ttu-id="74215-308">`Distinct Sort` ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-308">`Distinct Sort` is a logical operator.</span></span>|  
|<span data-ttu-id="74215-309">![Distribute Streams Parallelism-Operator (Symbol)](../../2014/database-engine/media/parallelism-distribute-stream.gif "Distribute Streams Parallelism-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-309">![Distribute streams parallelism operator icon](../../2014/database-engine/media/parallelism-distribute-stream.gif "Distribute streams parallelism operator icon")</span></span>|<span data-ttu-id="74215-310">**Distribute Streams**</span><span class="sxs-lookup"><span data-stu-id="74215-310">**Distribute Streams**</span></span>|<span data-ttu-id="74215-311">Der **Distribute Streams** -Operator wird nur in parallelen Abfrageplänen verwendet.</span><span class="sxs-lookup"><span data-stu-id="74215-311">The **Distribute Streams** operator is used only in parallel query plans.</span></span> <span data-ttu-id="74215-312">Der **Distribute Streams** -Operator nimmt genau einen Eingabedatenstrom von Datensätzen an und erzeugt mehrere Ausgabedatenströme.</span><span class="sxs-lookup"><span data-stu-id="74215-312">The **Distribute Streams** operator takes a single input stream of records and produces multiple output streams.</span></span> <span data-ttu-id="74215-313">Inhalt und Format der Datensätze werden nicht geändert.</span><span class="sxs-lookup"><span data-stu-id="74215-313">The record contents and format are not changed.</span></span> <span data-ttu-id="74215-314">Jeder Datensatz aus dem Eingabedatenstrom wird in genau einem der Ausgabedatenströme angezeigt.</span><span class="sxs-lookup"><span data-stu-id="74215-314">Each record from the input stream appears in one of the output streams.</span></span> <span data-ttu-id="74215-315">Dieser Operator behält die relative Reihenfolge der Eingabedatensätze in den Ausgabedatenströmen bei.</span><span class="sxs-lookup"><span data-stu-id="74215-315">This operator automatically preserves the relative order of the input records in the output streams.</span></span> <span data-ttu-id="74215-316">In der Regel wird mit einem Hashingverfahren festgelegt, zu welchem Ausgabedatenstrom ein bestimmter Eingabedatensatz gehört.</span><span class="sxs-lookup"><span data-stu-id="74215-316">Usually, hashing is used to decide to which output stream a particular input record belongs.</span></span><br /><br /> <span data-ttu-id="74215-317">Wenn die Ausgabe partitioniert ist, enthält die `Argument` Spalte ein Partition columns:()-Prädikat und die Partitionierungs Spalten.</span><span class="sxs-lookup"><span data-stu-id="74215-317">If the output is partitioned, then the `Argument` column contains a PARTITION COLUMNS:() predicate and the partitioning columns.</span></span> <span data-ttu-id="74215-318">**Distribute Streams** ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-318">**Distribute Streams** is a logical operator</span></span>|  
|<span data-ttu-id="74215-319">![Dynamic-Cursoroperator (Symbol)](../../2014/database-engine/media/dynamic-32x.gif "Dynamic-Cursoroperator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-319">![Dynamic cursor operator icon](../../2014/database-engine/media/dynamic-32x.gif "Dynamic cursor operator icon")</span></span>|`Dynamic`|<span data-ttu-id="74215-320">Der `Dynamic`-Operator verwendet einen Cursor, der alle von anderen vorgenommenen Änderungen wahrnimmt.</span><span class="sxs-lookup"><span data-stu-id="74215-320">The `Dynamic` operator uses a cursor that can see all changes made by others.</span></span>|  
|<span data-ttu-id="74215-321">![Spool-Operator (Symbol)](../../2014/database-engine/media/spool-32x.gif "Spool-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-321">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="74215-322">**Eager Spool**</span><span class="sxs-lookup"><span data-stu-id="74215-322">**Eager Spool**</span></span>|<span data-ttu-id="74215-323">Der **eifrige Spool** -Operator übernimmt die gesamte Eingabe und speichert jede Zeile in einem verborgenen temporären Objekt, das in der Datenbank gespeichert ist `tempdb` .</span><span class="sxs-lookup"><span data-stu-id="74215-323">The **Eager Spool** operator takes the entire input, storing each row in a hidden temporary object stored in the `tempdb` database.</span></span> <span data-ttu-id="74215-324">Wenn der Operator zurückgesetzt wird (z. b. durch einen `Nested Loops` Operator), aber keine erneute Bindung erforderlich ist, werden die gespoolten Daten verwendet, anstatt die Eingabe erneut zu scannen.</span><span class="sxs-lookup"><span data-stu-id="74215-324">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="74215-325">Wenn eine erneute Zuordnung erforderlich ist, werden die gespoolten Daten gelöscht, und das Spoolobjekt wird durch erneutes Scannen der (neu zugeordneten) Eingabe neu erstellt.</span><span class="sxs-lookup"><span data-stu-id="74215-325">If rebinding is needed, the spooled data is discarded and the spool object is rebuilt by rescanning the (rebound) input.</span></span> <span data-ttu-id="74215-326">Der **Eager Spool** -Operator erstellt seine Spooldatei unverzüglich: Wenn der übergeordnete Operator des Spoolvorgangs die erste Zeile anfordert, verarbeitet der Spool-Operator alle Zeilen aus dem Eingabeoperator und speichert sie im Spool.</span><span class="sxs-lookup"><span data-stu-id="74215-326">The **Eager Spool** operator builds its spool file in an "eager" manner: when the spool's parent operator asks for the first row, the spool operator consumes all rows from its input operator and stores them in the spool.</span></span> <span data-ttu-id="74215-327">**Eager Spool** ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-327">**Eager Spool** is a logical operator.</span></span>|  
|<span data-ttu-id="74215-328">![Fetch Query-Cursoroperator (Symbol)](../../2014/database-engine/media/fetch-query-32x.gif "Fetch Query-Cursoroperator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-328">![Fetch query cursor operator icon](../../2014/database-engine/media/fetch-query-32x.gif "Fetch query cursor operator icon")</span></span>|`Fetch Query`|<span data-ttu-id="74215-329">Der `Fetch Query`-Operator ruft Zeilen ab, wenn eine Abrufoperation für einen Cursor ausgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="74215-329">The `Fetch Query` operator retrieves rows when a fetch is issued against a cursor.</span></span>|  
|<span data-ttu-id="74215-330">![Filter-Operatorsymbol (Datenbank-Engine)](../../2014/database-engine/media/filter-32x.gif "Filter-Operatorsymbol (Datenbank-Engine)")</span><span class="sxs-lookup"><span data-stu-id="74215-330">![Filter (Database Engine) operator icon](../../2014/database-engine/media/filter-32x.gif "Filter (Database Engine) operator icon")</span></span>|<span data-ttu-id="74215-331">**Filter**</span><span class="sxs-lookup"><span data-stu-id="74215-331">**Filter**</span></span>|<span data-ttu-id="74215-332">Der **Filter** -Operator scannt die Eingabe und gibt nur die Zeilen zurück, die den in der Spalte angezeigten Filter Ausdruck (Prädikat) erfüllen `Argument` .</span><span class="sxs-lookup"><span data-stu-id="74215-332">The **Filter** operator scans the input, returning only those rows that satisfy the filter expression (predicate) that appears in the `Argument` column.</span></span>|  
|<span data-ttu-id="74215-333">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-333">None</span></span>|`Flow Distinct`|<span data-ttu-id="74215-334">Der logische Operator `Flow Distinct` scannt die Eingabe und entfernt Duplikate.</span><span class="sxs-lookup"><span data-stu-id="74215-334">The `Flow Distinct` logical operator scans the input, removing duplicates.</span></span> <span data-ttu-id="74215-335">Während der- `Distinct` Operator alle Eingaben verarbeitet, bevor eine Ausgabe erzeugt wird, gibt der **flowverschieden** -Operator jede Zeile zurück, wie Sie aus der Eingabe abgerufen wird (es sei denn, diese Zeile ist ein Duplikat, in diesem Fall wird sie verworfen).</span><span class="sxs-lookup"><span data-stu-id="74215-335">Whereas the `Distinct` operator consumes all input before producing any output, the **FlowDistinct** operator returns each row as it is obtained from the input (unless that row is a duplicate, in which case it is discarded).</span></span>|  
|<span data-ttu-id="74215-336">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-336">None</span></span>|`Full Outer Join`|<span data-ttu-id="74215-337">Der logische `Full Outer Join`-Operator gibt alle Zeilen zurück, die das JOIN-Prädikat aus der ersten (oberen) Eingabe, verknüpft mit jeder Zeile aus der zweiten (unteren) Eingabe, erfüllen.</span><span class="sxs-lookup"><span data-stu-id="74215-337">The `Full Outer Join` logical operator returns each row satisfying the join predicate from the first (top) input joined with each row from the second (bottom) input.</span></span> <span data-ttu-id="74215-338">Er gibt außerdem die folgenden Zeilen zurück:</span><span class="sxs-lookup"><span data-stu-id="74215-338">It also returns rows from:</span></span><br /><br /> <span data-ttu-id="74215-339">– Zeilen aus der ersten Eingabe, für die in der zweiten Eingabe keine Übereinstimmung besteht.</span><span class="sxs-lookup"><span data-stu-id="74215-339">-The first input that had no matches in the second input.</span></span><br /><br /> <span data-ttu-id="74215-340">– Zeilen aus der zweiten Eingabe, für die in der ersten Eingabe keine Übereinstimmung besteht.</span><span class="sxs-lookup"><span data-stu-id="74215-340">-The second input that had no matches in the first input.</span></span><br /><br /> <br /><br /> <span data-ttu-id="74215-341">Eingaben, die keine übereinstimmenden Werte enthalten, werden als NULL-Wert zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="74215-341">The input that does not contain the matching values is returned as a null value.</span></span> <span data-ttu-id="74215-342">`Full Outer Join` ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-342">`Full Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="74215-343">![Gather Streams Parallelism-Operator (Symbol)](../../2014/database-engine/media/parallelism-32x.gif "Gather Streams Parallelism-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-343">![Gather streams parallelism operator icon](../../2014/database-engine/media/parallelism-32x.gif "Gather streams parallelism operator icon")</span></span>|<span data-ttu-id="74215-344">**Gather Streams**</span><span class="sxs-lookup"><span data-stu-id="74215-344">**Gather Streams**</span></span>|<span data-ttu-id="74215-345">Der **Gather Streams** -Operator wird nur in parallelen Abfrageplänen verwendet.</span><span class="sxs-lookup"><span data-stu-id="74215-345">The **Gather Streams** operator is only used in parallel query plans.</span></span> <span data-ttu-id="74215-346">Der **Gather Streams** -Operator verarbeitet mehrere Eingabedatenströme, fasst diese zusammen und erzeugt genau einen Ausgabedatenstrom von Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="74215-346">The **Gather Streams** operator consumes several input streams and produces a single output stream of records by combining the input streams.</span></span> <span data-ttu-id="74215-347">Inhalt und Format der Datensätze werden nicht geändert.</span><span class="sxs-lookup"><span data-stu-id="74215-347">The record contents and format are not changed.</span></span> <span data-ttu-id="74215-348">Wenn dieser Operator die Reihenfolge beibehalten soll, müssen alle Eingabedatenströme entsprechend geordnet vorliegen.</span><span class="sxs-lookup"><span data-stu-id="74215-348">If this operator is order preserving, all input streams must be ordered.</span></span> <span data-ttu-id="74215-349">Wenn die Ausgabe sortiert ist, `Argument` enthält die Spalte ein Order by:()-Prädikat und die Namen der Spalten, die sortiert werden.</span><span class="sxs-lookup"><span data-stu-id="74215-349">If the output is ordered, the `Argument` column contains an ORDER BY:() predicate and the names of columns being ordered.</span></span> <span data-ttu-id="74215-350">**Gather Streams** ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-350">**Gather Streams** is a logical operator.</span></span>|  
|<span data-ttu-id="74215-351">![Hash Match-Operator (Symbol)](../../2014/database-engine/media/hash-match-32x.gif "Hash Match-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-351">![Hash match operator icon](../../2014/database-engine/media/hash-match-32x.gif "Hash match operator icon")</span></span>|`Hash Match`|<span data-ttu-id="74215-352">Der `Hash Match`-Operator erzeugt eine Hashtabelle, indem er für jede Zeile der Erstellungseingabe einen Hashwert berechnet.</span><span class="sxs-lookup"><span data-stu-id="74215-352">The `Hash Match` operator builds a hash table by computing a hash value for each row from its build input.</span></span> <span data-ttu-id="74215-353">Ein Hash:()-Prädikat mit einer Liste von Spalten, die zum Erstellen eines Hashwerts verwendet wird, wird in der- `Argument` Spalte angezeigt.</span><span class="sxs-lookup"><span data-stu-id="74215-353">A HASH:() predicate with a list of columns used to create a hash value appears in the `Argument` column.</span></span> <span data-ttu-id="74215-354">Anschließend wird, soweit möglich, für jede Einfügezeile ein Hashwert (mithilfe derselben Hashfunktion) berechnet und in der Hashtabelle nach Übereinstimmungen gesucht.</span><span class="sxs-lookup"><span data-stu-id="74215-354">Then, for each probe row (as applicable), it computes a hash value (using the same hash function) and looks in the hash table for matches.</span></span> <span data-ttu-id="74215-355">Wenn ein Rest-Prädikat vorhanden ist (identifiziert durch "Rest:()" in der `Argument` Spalte), muss dieses Prädikat ebenfalls erfüllt sein, damit Zeilen als Übereinstimmung angesehen werden.</span><span class="sxs-lookup"><span data-stu-id="74215-355">If a residual predicate is present (identified by RESIDUAL:() in the `Argument` column), that predicate must also be satisfied for rows to be considered a match.</span></span> <span data-ttu-id="74215-356">Das Verhalten des Operators hängt von dem auszuführenden logischen Vorgang ab:</span><span class="sxs-lookup"><span data-stu-id="74215-356">Behavior depends on the logical operation being performed:</span></span><br /><br /> <span data-ttu-id="74215-357">Für jeden Join wird die erste (obere) Eingabe verwendet, um die Hashtabelle zu erstellen, und die zweite (untere) Eingabe zum Einfügen in die Hashtabelle.</span><span class="sxs-lookup"><span data-stu-id="74215-357">For any joins, use the first (top) input to build the hash table and the second (bottom) input to probe the hash table.</span></span> <span data-ttu-id="74215-358">Die Ausgabeübereinstimmungen (oder Nichtübereinstimmungen) werden vom Jointyp bestimmt.</span><span class="sxs-lookup"><span data-stu-id="74215-358">Output matches (or nonmatches) as dictated by the join type.</span></span> <span data-ttu-id="74215-359">Wenn mehrere Joins dieselbe Joinspalte verwenden, werden diese Vorgänge in einem Hashteam gruppiert.</span><span class="sxs-lookup"><span data-stu-id="74215-359">If multiple joins use the same join column, these operations are grouped into a hash team.</span></span><br /><br /> <span data-ttu-id="74215-360">Für die Operatoren Distinct oder Aggregate wird die Eingabe verwendet, um die Hashtabelle zu erstellen (wobei Duplikate entfernt und Aggregatausdrücke berechnet werden).</span><span class="sxs-lookup"><span data-stu-id="74215-360">For the distinct or aggregate operators, use the input to build the hash table (removing duplicates and computing any aggregate expressions).</span></span> <span data-ttu-id="74215-361">Wenn die Hashtabelle erstellt ist, wird die Tabelle gescannt, und alle Einträge werden ausgegeben.</span><span class="sxs-lookup"><span data-stu-id="74215-361">When the hash table is built, scan the table and output all entries.</span></span><br /><br /> <span data-ttu-id="74215-362">Für den Union-Operator wird die erste Eingabe verwendet, um die Hashtabelle zu erstellen (wobei Duplikate entfernt werden).</span><span class="sxs-lookup"><span data-stu-id="74215-362">For the union operator, use the first input to build the hash table (removing duplicates).</span></span> <span data-ttu-id="74215-363">Die zweite Eingabe (die keine Duplikate haben darf) wird zum Einfügen in die Hashtabelle verwendet, wobei alle nicht übereinstimmenden Zeilen zurückgegeben werden, anschließend wird die Hashtabelle gescannt, und alle Einträge werden zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="74215-363">Use the second input (which must have no duplicates) to probe the hash table, returning all rows that have no matches, then scan the hash table and return all entries.</span></span><br /><br /> <br /><br /> <span data-ttu-id="74215-364">`Hash Match` ist ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-364">`Hash Match` is a physical operator.</span></span>|  
|<span data-ttu-id="74215-365">![If-Sprachelement (Symbol)](../../2014/database-engine/media/if-32x.gif "If-Sprachelement (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-365">![If language element icon](../../2014/database-engine/media/if-32x.gif "If language element icon")</span></span>|`If`|<span data-ttu-id="74215-366">Der `If`-Operator führt eine bedingte Verarbeitung basierend auf einem Ausdruck aus.</span><span class="sxs-lookup"><span data-stu-id="74215-366">The `If` operator carries out conditional processing based on an expression.</span></span> <span data-ttu-id="74215-367">`If` ist ein Sprachelement.</span><span class="sxs-lookup"><span data-stu-id="74215-367">`If` is a language element.</span></span>|  
|<span data-ttu-id="74215-368">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-368">None</span></span>|`Inner Join`|<span data-ttu-id="74215-369">Der logische `Inner Join`-Operator gibt alle Zeilen zurück, die die Verknüpfung der ersten (oberen) Eingabe mit der zweiten (unteren) Eingabe erfüllen.</span><span class="sxs-lookup"><span data-stu-id="74215-369">The `Inner Join` logical operator returns each row that satisfies the join of the first (top) input with the second (bottom) input.</span></span>|  
|<span data-ttu-id="74215-370">![Insert-Operatorsymbol (Datenbank-Engine)](../../2014/database-engine/media/insert-32x.gif "Insert-Operatorsymbol (Datenbank-Engine)")</span><span class="sxs-lookup"><span data-stu-id="74215-370">![Insert (Database Engine) operator icon](../../2014/database-engine/media/insert-32x.gif "Insert (Database Engine) operator icon")</span></span>|`Insert`|<span data-ttu-id="74215-371">Der `Insert` logische Operator fügt jede Zeile aus der Eingabe in das-Objekt ein, das in der-Spalte angegeben ist `Argument` .</span><span class="sxs-lookup"><span data-stu-id="74215-371">The `Insert` logical operator inserts each row from its input into the object specified in the `Argument` column.</span></span> <span data-ttu-id="74215-372">Der physische Operator ist entweder der Operator `Table Insert`, `Index Insert` oder `Clustered Index Insert`.</span><span class="sxs-lookup"><span data-stu-id="74215-372">The physical operator is either the `Table Insert`, `Index Insert`, or `Clustered Index Insert` operator.</span></span>|  
|<span data-ttu-id="74215-373">![Inserted Scan-Operator (Symbol)](../../2014/database-engine/media/inserted-scan-32x.gif "Inserted Scan-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-373">![Inserted scan operator icon](../../2014/database-engine/media/inserted-scan-32x.gif "Inserted scan operator icon")</span></span>|<span data-ttu-id="74215-374">**Inserted Scan**</span><span class="sxs-lookup"><span data-stu-id="74215-374">**Inserted Scan**</span></span>|<span data-ttu-id="74215-375">Der **Inserted Scan** -Operator scannt die **inserted** -Tabelle.</span><span class="sxs-lookup"><span data-stu-id="74215-375">The **Inserted Scan** operator scans the **inserted** table.</span></span> <span data-ttu-id="74215-376">**Inserted Scan** ist sowohl ein logischer als auch ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-376">**Inserted Scan** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-377">![Intrinsic-Sprachelement (Symbol)](../../2014/database-engine/media/intrinsic-32x.gif "Intrinsic-Sprachelement (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-377">![Intrinsic language element icon](../../2014/database-engine/media/intrinsic-32x.gif "Intrinsic language element icon")</span></span>|`Intrinsic`|<span data-ttu-id="74215-378">Der `Intrinsic`-Operator ruft eine interne [!INCLUDE[tsql](../includes/tsql-md.md)]-Funktion auf.</span><span class="sxs-lookup"><span data-stu-id="74215-378">The `Intrinsic` operator invokes an internal [!INCLUDE[tsql](../includes/tsql-md.md)] function.</span></span> <span data-ttu-id="74215-379">`Intrinsic` ist ein Sprachelement.</span><span class="sxs-lookup"><span data-stu-id="74215-379">`Intrinsic` is a language element.</span></span>|  
|<span data-ttu-id="74215-380">![Iterator Catchall-Operator (Symbol)](../../2014/database-engine/media/iterator-catch-all.gif "Iterator Catchall-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-380">![Iterator catchall operator icon](../../2014/database-engine/media/iterator-catch-all.gif "Iterator catchall operator icon")</span></span>|`Iterator`|<span data-ttu-id="74215-381">Das `Iterator`-Sammelsymbol wird angezeigt, wenn von der Logik, die grafische Showplans erzeugt, kein geeignetes Symbol für den Iterator gefunden werden kann.</span><span class="sxs-lookup"><span data-stu-id="74215-381">The `Iterator` catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical Showplans.</span></span> <span data-ttu-id="74215-382">Das Sammelsymbol zeigt nicht notwendigerweise eine Fehlerbedingung an.</span><span class="sxs-lookup"><span data-stu-id="74215-382">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="74215-383">Es stehen drei Sammelsymbole zur Verfügung: blau (für Iteratoren), orange (für Cursor) und grün (für [!INCLUDE[tsql](../includes/tsql-md.md)] -Sprachkonstrukte).</span><span class="sxs-lookup"><span data-stu-id="74215-383">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language constructs).</span></span>|  
|<span data-ttu-id="74215-384">![Bookmark Lookup-Operator (Symbol)](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark Lookup-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-384">![Bookmark lookup operator icon](../../2014/database-engine/media/bookmark-lookup-32x.gif "Bookmark lookup operator icon")</span></span>|`Key Lookup`|<span data-ttu-id="74215-385">Der- `Key Lookup` Operator ist eine Lesezeichen Suche für eine Tabelle mit einem gruppierten Index.</span><span class="sxs-lookup"><span data-stu-id="74215-385">The `Key Lookup` operator is a bookmark lookup on a table with a clustered index.</span></span> <span data-ttu-id="74215-386">Die `Argument` Spalte enthält den Namen des gruppierten Indexes und den gruppierten Schlüssel, der zum Nachschlagen der Zeile im gruppierten Index verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="74215-386">The `Argument` column contains the name of the clustered index and the clustering key used to look up the row in the clustered index.</span></span> <span data-ttu-id="74215-387">`Key Lookup`wird immer von einem- `Nested Loops` Operator begleitet.</span><span class="sxs-lookup"><span data-stu-id="74215-387">`Key Lookup` is always accompanied by a `Nested Loops` operator.</span></span> <span data-ttu-id="74215-388">Wenn die with Prefetch-Klausel in der- `Argument` Spalte angezeigt wird, hat der Abfrage Prozessor ermittelt, dass das asynchrone vorab abrufen (Read-Ahead) beim Suchen von Lesezeichen im gruppierten Index optimal verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="74215-388">If the WITH PREFETCH clause appears in the `Argument` column, the query processor has determined that it is optimal to use asynchronous prefetching (read-ahead) when looking up bookmarks in the clustered index.</span></span><br /><br /> <span data-ttu-id="74215-389">Die Verwendung eines- `Key Lookup` Operators in einem Abfrageplan gibt an, dass die Abfrage möglicherweise von der Leistungsoptimierung profitiert.</span><span class="sxs-lookup"><span data-stu-id="74215-389">The use of a `Key Lookup` operator in a query plan indicates that the query might benefit from performance tuning.</span></span> <span data-ttu-id="74215-390">Beispielsweise kann die Leistung durch Hinzufügen eines abdeckenden Indexes optimiert werden.</span><span class="sxs-lookup"><span data-stu-id="74215-390">For example, query performance might be improved by adding a covering index.</span></span>|  
|<span data-ttu-id="74215-391">![Keyset-Cursoroperator (Symbol)](../../2014/database-engine/media/keyset-32x.gif "Keyset-Cursoroperator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-391">![Keyset cursor operator icon](../../2014/database-engine/media/keyset-32x.gif "Keyset cursor operator icon")</span></span>|`Keyset`|<span data-ttu-id="74215-392">Der `Keyset`-Operator verwendet einen Cursor, für den Aktualisierungen, jedoch keine von anderen vorgenommenen Einfügungen, sichtbar sind.</span><span class="sxs-lookup"><span data-stu-id="74215-392">The `Keyset` operator uses a cursor that can see updates, but not inserts made by others.</span></span>|  
|<span data-ttu-id="74215-393">![Language Element Catchall-Operator (Symbol)](../../2014/database-engine/media/language-construct-catch-all.gif "Language Element Catchall-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-393">![Language element catchall icon](../../2014/database-engine/media/language-construct-catch-all.gif "Language element catchall icon")</span></span>|`Language Element`|<span data-ttu-id="74215-394">Das `Language Element`-Sammelsymbol wird angezeigt, wenn von der Logik, die grafische Showplans erzeugt, kein geeignetes Symbol für den Iterator gefunden werden kann.</span><span class="sxs-lookup"><span data-stu-id="74215-394">The `Language Element` catchall icon is displayed when a suitable icon for the iterator cannot be found by the logic that produces graphical Showplans.</span></span> <span data-ttu-id="74215-395">Das Sammelsymbol zeigt nicht notwendigerweise eine Fehlerbedingung an.</span><span class="sxs-lookup"><span data-stu-id="74215-395">The catchall icon does not necessarily indicate an error condition.</span></span> <span data-ttu-id="74215-396">Es stehen drei Sammelsymbole zur Verfügung: blau (für Iteratoren), orange (für Cursor) und grün (für [!INCLUDE[tsql](../includes/tsql-md.md)] -Sprachkonstrukte).</span><span class="sxs-lookup"><span data-stu-id="74215-396">There are three catchall icons: blue (for iterators), orange (for cursors), and green (for [!INCLUDE[tsql](../includes/tsql-md.md)] language constructs).</span></span>|  
|<span data-ttu-id="74215-397">![Spool-Operator (Symbol)](../../2014/database-engine/media/spool-32x.gif "Spool-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-397">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="74215-398">**Lazy Spool**</span><span class="sxs-lookup"><span data-stu-id="74215-398">**Lazy Spool**</span></span>|<span data-ttu-id="74215-399">Der logische Operator **Lazy Spool** speichert jede Zeile aus der Eingabe in einem verborgenen temporären Objekt, das in der Datenbank gespeichert ist `tempdb` .</span><span class="sxs-lookup"><span data-stu-id="74215-399">The **Lazy Spool** logical operator stores each row from its input in a hidden temporary object stored in the `tempdb` database.</span></span> <span data-ttu-id="74215-400">Wenn der Operator zurückgesetzt wird (z. b. durch einen `Nested Loops` Operator), aber keine erneute Bindung erforderlich ist, werden die gespoolten Daten verwendet, anstatt die Eingabe erneut zu scannen.</span><span class="sxs-lookup"><span data-stu-id="74215-400">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="74215-401">Wenn eine erneute Zuordnung erforderlich ist, werden die gespoolten Daten gelöscht, und das Spoolobjekt wird durch erneutes Scannen der (neu zugeordneten) Eingabe neu erstellt.</span><span class="sxs-lookup"><span data-stu-id="74215-401">If rebinding is needed, the spooled data is discarded and the spool object is rebuilt by rescanning the (rebound) input.</span></span> <span data-ttu-id="74215-402">Der **Lazy Spool** -Operator erstellt seine Spooldatei mit Verzögerung. Das bedeutet, dass der Spooloperator jedes Mal, wenn der übergeordnete Operator des Spoolvorgangs eine Zeile anfordert, eine Zeile aus seinem Eingabeoperator erhält und sie im Spool speichert, anstatt alle Zeilen gleichzeitig zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="74215-402">The **Lazy Spool** operator builds its spool file in a "lazy" manner, that is, each time the spool's parent operator asks for a row, the spool operator gets a row from its input operator and stores it in the spool, rather than consuming all rows at once.</span></span> <span data-ttu-id="74215-403">Lazy Spool ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-403">Lazy Spool is a logical operator.</span></span>|  
|<span data-ttu-id="74215-404">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-404">None</span></span>|`Left Anti Semi Join`|<span data-ttu-id="74215-405">Der `Left Anti Semi Join`-Operator gibt jede Zeile aus der ersten (oberen) Eingabe zurück, für die keine übereinstimmende Zeile in der zweiten (unteren) Eingabe vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="74215-405">The `Left Anti Semi Join` operator returns each row from the first (top) input when there is no matching row in the second (bottom) input.</span></span> <span data-ttu-id="74215-406">Wenn kein Joinprädikat in der Spalte vorhanden ist `Argument` , ist jede Zeile eine übereinstimmende Zeile.</span><span class="sxs-lookup"><span data-stu-id="74215-406">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="74215-407">`Left Anti Semi Join` ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-407">`Left Anti Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="74215-408">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-408">None</span></span>|`Left Outer Join`|<span data-ttu-id="74215-409">Der `Left Outer Join`-Operator gibt alle Zeilen zurück, die die Verknüpfung der ersten (oberen) Eingabe mit der zweiten (unteren) Eingabe erfüllen.</span><span class="sxs-lookup"><span data-stu-id="74215-409">The `Left Outer Join` operator returns each row that satisfies the join of the first (top) input with the second (bottom) input.</span></span> <span data-ttu-id="74215-410">Er gibt auch alle Zeilen aus der ersten Eingabe zurück, für die keine übereinstimmende Zeile in der zweiten Eingabe vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="74215-410">It also returns any rows from the first input that had no matching rows in the second input.</span></span> <span data-ttu-id="74215-411">Die nicht übereinstimmenden Zeilen in der zweiten Eingabe werden als NULL-Werte zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="74215-411">The nonmatching rows in the second input are returned as null values.</span></span> <span data-ttu-id="74215-412">Wenn kein Joinprädikat in der Spalte vorhanden ist `Argument` , ist jede Zeile eine übereinstimmende Zeile.</span><span class="sxs-lookup"><span data-stu-id="74215-412">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="74215-413">`Left Outer Join` ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-413">`Left Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="74215-414">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-414">None</span></span>|`Left Semi Join`|<span data-ttu-id="74215-415">Der Operator `Left Semi Join` gibt jede Zeile aus der ersten (oberen) Eingabe zurück, für die eine übereinstimmende Zeile in der zweiten (unteren) Eingabe vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="74215-415">The `Left Semi Join` operator returns each row from the first (top) input when there is a matching row in the second (bottom) input.</span></span> <span data-ttu-id="74215-416">Wenn kein Joinprädikat in der Spalte vorhanden ist `Argument` , ist jede Zeile eine übereinstimmende Zeile.</span><span class="sxs-lookup"><span data-stu-id="74215-416">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="74215-417">`Left Semi Join` ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-417">`Left Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="74215-418">![Log Row Scan-Operator (Symbol)](../../2014/database-engine/media/log-row-scan-32x.gif "Log Row Scan-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-418">![Log row scan operator icon](../../2014/database-engine/media/log-row-scan-32x.gif "Log row scan operator icon")</span></span>|`Log Row Scan`|<span data-ttu-id="74215-419">Der `Log Row Scan`-Operator scannt das Transaktionsprotokoll.</span><span class="sxs-lookup"><span data-stu-id="74215-419">The `Log Row Scan` operator scans the transaction log.</span></span> <span data-ttu-id="74215-420">`Log Row Scan` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-420">`Log Row Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-421">![Merge Interval-Operator (Symbol)](../../2014/database-engine/media/merge-interval-32x.gif "Merge Interval-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-421">![Merge interval operator icon](../../2014/database-engine/media/merge-interval-32x.gif "Merge interval operator icon")</span></span>|`Merge Interval`|<span data-ttu-id="74215-422">Der Operator `Merge Interval` führt mehrere (möglicherweise überlappende) Intervalle zusammen, um minimale, nicht überlappende Intervalle zu erzeugen, die anschließend zum Suchen von Indexeinträgen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="74215-422">The `Merge Interval` operator merges multiple (potentially overlapping) intervals to produce minimal, nonoverlapping intervals that are then used to seek index entries.</span></span> <span data-ttu-id="74215-423">Dieser Operator erscheint in der Regel über einem oder mehreren `Compute Scalar` Operatoren über `Constant Scan` Operatoren, die die Intervalle (dargestellt als Spalten in einer Zeile) erstellen, die dieser Operator zusammenführt.</span><span class="sxs-lookup"><span data-stu-id="74215-423">This operator typically appears above one or more `Compute Scalar` operators over `Constant Scan` operators, which construct the intervals (represented as columns in a row) that this operator merges.</span></span> <span data-ttu-id="74215-424">`Merge Interval` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-424">`Merge Interval` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-425">![Merge Join-Operator (Symbol)](../../2014/database-engine/media/merge-join-32x.gif "Merge Join-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-425">![Merge join operator icon](../../2014/database-engine/media/merge-join-32x.gif "Merge join operator icon")</span></span>|<span data-ttu-id="74215-426">**Merge Join**</span><span class="sxs-lookup"><span data-stu-id="74215-426">**Merge Join**</span></span>|<span data-ttu-id="74215-427">Der **Merge Join** -Operator führt die logischen Vorgänge „innere Verknüpfung“, „linke äußere Verknüpfung“, „linke Semiverknüpfung“, „linke Antisemiverknüpfung“, „rechte äußere Verknüpfung“, „rechte Semiverknüpfung“, „rechte Antisemiverknüpfung“ und „Vereinigung“ aus.</span><span class="sxs-lookup"><span data-stu-id="74215-427">The **Merge Join** operator performs the inner join, left outer join, left semi join, left anti semi join, right outer join, right semi join, right anti semi join, and union logical operations.</span></span><br /><br /> <span data-ttu-id="74215-428">In der- `Argument` Spalte enthält der **Merge Join** -Operator ein Merge:()-Prädikat, wenn der Vorgang einen 1: n-Join ausführt, oder ein many-to-many Merge:()-Prädikat, wenn der Vorgang einen m:n-Join ausführt.</span><span class="sxs-lookup"><span data-stu-id="74215-428">In the `Argument` column, the **Merge Join** operator contains a MERGE:() predicate if the operation is performing a one-to-many join, or a MANY-TO-MANY MERGE:() predicate if the operation is performing a many-to-many join.</span></span> <span data-ttu-id="74215-429">Die `Argument` Spalte enthält auch eine durch Trennzeichen getrennte Liste von Spalten, die zum Ausführen des Vorgangs verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="74215-429">The `Argument` column also includes a comma-separated list of columns used to perform the operation.</span></span> <span data-ttu-id="74215-430">Der **Merge Join** -Operator benötigt zwei Eingaben, die nach den jeweiligen Spalten sortiert sind, möglicherweise durch Einfügen von expliziten Sortiervorgängen in den Abfrageplan.</span><span class="sxs-lookup"><span data-stu-id="74215-430">The **Merge Join** operator requires two inputs sorted on their respective columns, possibly by inserting explicit sort operations into the query plan.</span></span> <span data-ttu-id="74215-431">Ein Zusammenführungsjoin ist vor allem effizient, wenn kein expliziter Sortiervorgang erforderlich ist, beispielsweise wenn ein geeigneter B-Struktur-Index in der Datenbank vorhanden ist oder die Datenbank für mehrere Vorgänge, z. B. ein Zusammenführungsjoin und Gruppierung mit Rollup, verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="74215-431">Merge join is particularly effective if explicit sorting is not required, for example, if there is a suitable B-tree index in the database or if the sort order can be exploited for multiple operations, such as a merge join and grouping with roll up.</span></span> <span data-ttu-id="74215-432">Bei**Merge Join** handelt es sich um einen physischen Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-432">**Merge Join** is a physical operator.</span></span>|  
|<span data-ttu-id="74215-433">![Nested Loops-Operator (Symbol)](../../2014/database-engine/media/nested-loops-32x.gif "Nested Loops-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-433">![Nested loops operator icon](../../2014/database-engine/media/nested-loops-32x.gif "Nested loops operator icon")</span></span>|`Nested Loops`|<span data-ttu-id="74215-434">Der `Nested Loops`-Operator führt die logischen Operationen Inner Join, Left Outer Join, Left Semi Join und Left Anti Semi Join aus.</span><span class="sxs-lookup"><span data-stu-id="74215-434">The `Nested Loops` operator performs the inner join, left outer join, left semi join, and left anti semi join logical operations.</span></span> <span data-ttu-id="74215-435">Nested Loops-Joins führen für jede Zeile der äußeren Tabelle eine Suche in der inneren Tabelle aus, in der Regel mithilfe eines Indexes.</span><span class="sxs-lookup"><span data-stu-id="74215-435">Nested loops joins perform a search on the inner table for each row of the outer table, typically using an index.</span></span> <span data-ttu-id="74215-436">Der Abfrageprozessor legt auf der Grundlage der geschätzten Kosten fest, ob die äußere Eingabe sortiert werden soll, um die Treffsicherheit der Suchvorgänge auf dem Index über die innere Eingabe zu verbessern.</span><span class="sxs-lookup"><span data-stu-id="74215-436">The query processor decides, based on anticipated costs, whether to sort the outer input in order to improve locality of the searches on the index over the inner input.</span></span> <span data-ttu-id="74215-437">Alle Zeilen, die das (optionale) Prädikat in der `Argument` Spalte erfüllen, werden auf der Grundlage der ausgeführten logischen Operation als anwendbar zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="74215-437">Any rows that satisfy the (optional) predicate in the `Argument` column are returned as applicable, based on the logical operation being performed.</span></span> <span data-ttu-id="74215-438">`Nested Loops` ist ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-438">`Nested Loops` is a physical operator.</span></span>|  
|<span data-ttu-id="74215-439">![Nonclustered Index Delete-Operator (Symbol)](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Nonclustered Index Delete-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-439">![Nonclustered index delete operator icon](../../2014/database-engine/media/nonclust-index-delete-32x.gif "Nonclustered index delete operator icon")</span></span>|`Nonclustered Index Delete`|<span data-ttu-id="74215-440">Der- `Nonclustered Index Delete` Operator löscht Eingabezeilen aus dem nicht gruppierten Index, der in der-Spalte angegeben ist `Argument` .</span><span class="sxs-lookup"><span data-stu-id="74215-440">The `Nonclustered Index Delete` operator deletes input rows from the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="74215-441">`Nonclustered Index Delete` ist ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-441">`Nonclustered Index Delete` is a physical operator.</span></span>|  
|<span data-ttu-id="74215-442">![Nonclustered Index Insert-Operator (Symbol)](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Nonclustered Index Insert-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-442">![Nonclustered index insert operator icon](../../2014/database-engine/media/nonclust-index-insert-32x.gif "Nonclustered index insert operator icon")</span></span>|`Index Insert`|<span data-ttu-id="74215-443">Der- `Index Insert` Operator Fügt Zeilen aus der Eingabe in den nicht gruppierten Index ein, der in der-Spalte angegeben ist `Argument` .</span><span class="sxs-lookup"><span data-stu-id="74215-443">The `Index Insert` operator inserts rows from its input into the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="74215-444">Die `Argument`-Spalte enthält auch ein SET:()-Prädikat, das den für die einzelnen Spalten festgelegten Wert anzeigt.</span><span class="sxs-lookup"><span data-stu-id="74215-444">The `Argument` column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="74215-445">`Index Insert` ist ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-445">`Index Insert` is a physical operator.</span></span>|  
|<span data-ttu-id="74215-446">![Nonclustered Index Scan-Operator (Symbol)](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Nonclustered Index Scan-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-446">![Nonclustered index scan operator icon](../../2014/database-engine/media/nonclustered-index-scan-32x.gif "Nonclustered index scan operator icon")</span></span>|`Index Scan`|<span data-ttu-id="74215-447">Der- `Index Scan` Operator Ruft alle Zeilen aus dem nicht gruppierten Index ab, der in der-Spalte angegeben ist `Argument` .</span><span class="sxs-lookup"><span data-stu-id="74215-447">The `Index Scan` operator retrieves all rows from the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="74215-448">Wenn ein optionales WHERE:()-Prädikat in der `Argument` Spalte angezeigt wird, werden nur die Zeilen zurückgegeben, die das Prädikat erfüllen.</span><span class="sxs-lookup"><span data-stu-id="74215-448">If an optional WHERE:() predicate appears in the `Argument` column, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="74215-449">`Index Scan` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-449">`Index Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-450">![Nonclustered Index Seek-Operator (Symbol)](../../2014/database-engine/media/index-seek-32x.gif "Nonclustered Index Seek-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-450">![Nonclustered index seek operator icon](../../2014/database-engine/media/index-seek-32x.gif "Nonclustered index seek operator icon")</span></span>|`Index Seek`|<span data-ttu-id="74215-451">Der `Index Seek`-Operator verwendet die Suchfunktionen der Indizes, um Zeilen aus einem nicht gruppierten Index abzurufen.</span><span class="sxs-lookup"><span data-stu-id="74215-451">The `Index Seek` operator uses the seeking ability of indexes to retrieve rows from a nonclustered index.</span></span> <span data-ttu-id="74215-452">Die `Argument` Spalte enthält den Namen des verwendeten nicht gruppierten Indexes.</span><span class="sxs-lookup"><span data-stu-id="74215-452">The `Argument` column contains the name of the nonclustered index being used.</span></span> <span data-ttu-id="74215-453">Außerdem enthält sie auch das SEEK:()-Prädikat.</span><span class="sxs-lookup"><span data-stu-id="74215-453">It also contains the SEEK:() predicate.</span></span> <span data-ttu-id="74215-454">Mit diesem Index werden von der Speicher-Engine nur die Zeilen verarbeitet, die das SEEK:()-Prädikat erfüllen.</span><span class="sxs-lookup"><span data-stu-id="74215-454">The storage engine uses the index to process only those rows that satisfy the SEEK:() predicate.</span></span> <span data-ttu-id="74215-455">Optional kann ein WHERE:()-Prädikat enthalten sein, das von der Speicher-Engine für alle Zeilen ausgewertet wird, bei denen das SEEK:()-Prädikat erfüllt wird (es werden hierfür keine Indizes verwendet).</span><span class="sxs-lookup"><span data-stu-id="74215-455">It optionally may include a WHERE:() predicate, which the storage engine will evaluate against all rows that satisfy the SEEK:() predicate (it does not use the indexes to do this).</span></span> <span data-ttu-id="74215-456">Wenn die `Argument` Spalte die sortierte Klausel enthält, hat der Abfrage Prozessor ermittelt, dass die Zeilen in der Reihenfolge zurückgegeben werden müssen, in der Sie vom nicht gruppierten Index sortiert wurden.</span><span class="sxs-lookup"><span data-stu-id="74215-456">If the `Argument` column contains the ORDERED clause, the query processor has determined that the rows must be returned in the order in which the nonclustered index has sorted them.</span></span> <span data-ttu-id="74215-457">Wurde die ORDERED-Klausel nicht angegeben, so durchsucht die Speicher-Engine den Index auf die optimale Art (wobei die Ausgabe nicht unbedingt sortiert ist).</span><span class="sxs-lookup"><span data-stu-id="74215-457">If the ORDERED clause is not present, the storage engine searches the index in the optimal way (which does not guarantee that the output will be sorted).</span></span> <span data-ttu-id="74215-458">Die Ausgabe in der ursprünglichen Reihenfolge kann weniger effizient sein als die unsortierte Ausgabe.</span><span class="sxs-lookup"><span data-stu-id="74215-458">Allowing the output to retain its ordering may be less efficient than producing nonsorted output.</span></span> <span data-ttu-id="74215-459">`Index Seek` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-459">`Index Seek` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-460">![Nonclustered Index Spool-Operator (Symbol)](../../2014/database-engine/media/index-spool-32x.gif "Nonclustered Index Spool-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-460">![Nonclustered index spool operator icon](../../2014/database-engine/media/index-spool-32x.gif "Nonclustered index spool operator icon")</span></span>|<span data-ttu-id="74215-461">**Index Spool**</span><span class="sxs-lookup"><span data-stu-id="74215-461">**Index Spool**</span></span>|<span data-ttu-id="74215-462">Der physische Operator **Index Spool** enthält ein Seek:()-Prädikat in der `Argument` Spalte.</span><span class="sxs-lookup"><span data-stu-id="74215-462">The **Index Spool** physical operator contains a SEEK:() predicate in the `Argument` column.</span></span> <span data-ttu-id="74215-463">Der **Index Spool** -Operator scannt seine Eingabezeilen und platziert eine Kopie jeder Zeile in einer verborgenen Spooldatei (die in der `tempdb` Datenbank gespeichert ist und nur für die Lebensdauer der Abfrage vorhanden ist) und erstellt einen nicht gruppierten Index für die Zeilen.</span><span class="sxs-lookup"><span data-stu-id="74215-463">The **Index Spool** operator scans its input rows, placing a copy of each row in a hidden spool file (stored in the `tempdb` database and existing only for the lifetime of the query), and builds a nonclustered index on the rows.</span></span> <span data-ttu-id="74215-464">Dies ermöglicht es Ihnen, mithilfe der Indexsuchfunktionen nur die Zeilen auszugeben, die das SEEK:()-Prädikat erfüllen.</span><span class="sxs-lookup"><span data-stu-id="74215-464">This allows you to use the seeking capability of indexes to output only those rows that satisfy the SEEK:() predicate.</span></span> <span data-ttu-id="74215-465">Wenn der Operator zurückgesetzt wird (z. b. durch einen `Nested Loops` Operator), aber keine erneute Bindung erforderlich ist, werden die gespoolten Daten verwendet, anstatt die Eingabe erneut zu scannen.</span><span class="sxs-lookup"><span data-stu-id="74215-465">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span>|  
|<span data-ttu-id="74215-466">![Nonclustered Index Update-Operator (Symbol)](../../2014/database-engine/media/nonclust-index-update-32x.gif "Nonclustered Index Update-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-466">![Nonclustered index update operator icon](../../2014/database-engine/media/nonclust-index-update-32x.gif "Nonclustered index update operator icon")</span></span>|`Nonclustered Index Update`|<span data-ttu-id="74215-467">Der `Nonclustered Index Update` physische Operator Aktualisiert Zeilen aus der Eingabe in dem nicht gruppierten Index, der in der Spalte angegeben ist `Argument` .</span><span class="sxs-lookup"><span data-stu-id="74215-467">The `Nonclustered Index Update` physical operator updates rows from its input in the nonclustered index specified in the `Argument` column.</span></span> <span data-ttu-id="74215-468">Wenn ein SET:()-Prädikat vorhanden ist, wird jede aktualisierte Spalte auf diesen Wert festgelegt.</span><span class="sxs-lookup"><span data-stu-id="74215-468">If a SET:() predicate is present, each updated column is set to this value.</span></span> <span data-ttu-id="74215-469">`Nonclustered Index Update` ist ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-469">`Nonclustered Index Update` is a physical operator.</span></span>|  
|<span data-ttu-id="74215-470">![Online Index Insert-Operator (Symbol)](../../2014/database-engine/media/online-index-32x.gif "Online Index Insert-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-470">![Online index insert operator icon](../../2014/database-engine/media/online-index-32x.gif "Online index insert operator icon")</span></span>|<span data-ttu-id="74215-471">**Online Index Insert**</span><span class="sxs-lookup"><span data-stu-id="74215-471">**Online Index Insert**</span></span>|<span data-ttu-id="74215-472">Der physische Operator **Online Index Insert** gibt an, dass ein Index online erstellt, geändert oder gelöscht wird.</span><span class="sxs-lookup"><span data-stu-id="74215-472">The **Online Index Insert** physical operator indicates that an index create, alter, or drop operation is performed online.</span></span> <span data-ttu-id="74215-473">Die zugrunde liegenden Tabellendaten bleiben daher während des Indexvorgangs für Benutzer verfügbar.</span><span class="sxs-lookup"><span data-stu-id="74215-473">That is, the underlying table data remains available to users during the index operation.</span></span>|  
|<span data-ttu-id="74215-474">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-474">None</span></span>|`Parallelism`|<span data-ttu-id="74215-475">Der- `Parallelism` Operator führt die logischen Vorgänge verteilungsstreams, Gather Streams und Repartition Streams durch.</span><span class="sxs-lookup"><span data-stu-id="74215-475">The `Parallelism` operator performs the distribute streams, gather streams, and repartition streams logical operations.</span></span> <span data-ttu-id="74215-476">Die `Argument` Spalten können ein Partition columns:()-Prädikat mit einer durch Trennzeichen getrennten Liste der Spalten enthalten, die partitioniert werden.</span><span class="sxs-lookup"><span data-stu-id="74215-476">The `Argument` columns can contain a PARTITION COLUMNS:() predicate with a comma-separated list of the columns being partitioned.</span></span> <span data-ttu-id="74215-477">Die `Argument` Spalten können auch ein Order by:()-Prädikat enthalten, das die Spalten auflistet, für die die Sortierreihenfolge während der Partitionierung beibehalten wird.</span><span class="sxs-lookup"><span data-stu-id="74215-477">The `Argument` columns can also contain an ORDER BY:() predicate, listing the columns to preserve the sort order for during partitioning.</span></span> <span data-ttu-id="74215-478">`Parallelism` ist ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-478">`Parallelism` is a physical operator.</span></span><br /><br /> <span data-ttu-id="74215-479">Hinweis: Wenn eine Abfrage als parallele Abfrage kompiliert wurde, aber zur Laufzeit als serielle Abfrage ausgeführt wird, enthält die durch SET STATISTICS XML oder mit der Option **tatsächlichen Ausführungs Plan einschließen** von generierte Show Plan Ausgabe [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] kein- `RunTimeInformation` Element für den- `Parallelism` Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-479">Note: If a query has been compiled as a parallel query, but at run time it is run as a serial query, the Showplan output generated by SET STATISTICS XML or by using the **Include Actual Execution Plan** option in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] will not contain the `RunTimeInformation` element for the `Parallelism` operator.</span></span> <span data-ttu-id="74215-480">In der Ausgabe des Statistik Profils festlegen werden bei der tatsächlichen Zeilen Anzahl und der tatsächlichen Anzahl von Ausführungen Nullen für den `Parallelism` Operator angezeigt.</span><span class="sxs-lookup"><span data-stu-id="74215-480">In SET STATISTICS PROFILE output, the actual row counts and actual number of executes will display zeroes for the `Parallelism` operator.</span></span> <span data-ttu-id="74215-481">Wenn eine Bedingung auftritt, bedeutet dies, dass der `Parallelism` Operator nur während der Kompilierung der Abfrage und nicht im Lauf Zeit Abfrageplan verwendet wurde.</span><span class="sxs-lookup"><span data-stu-id="74215-481">When either condition occurs, it means that the `Parallelism` operator was only used during query compilation and not in the run-time query plan.</span></span> <span data-ttu-id="74215-482">Beachten Sie, dass parallele Abfragepläne mitunter seriell ausgeführt werden, wenn der Server stark ausgelastet ist.</span><span class="sxs-lookup"><span data-stu-id="74215-482">Note that sometimes parallel query plans are run in serial if there is a high concurrent load on the server.</span></span>|  
|<span data-ttu-id="74215-483">![Parameter Table Scan-Operator (Symbol)](../../2014/database-engine/media/parameter-table-scan-32x.gif "Parameter Table Scan-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-483">![Parameter table scan operator icon](../../2014/database-engine/media/parameter-table-scan-32x.gif "Parameter table scan operator icon")</span></span>|`Parameter Table Scan`|<span data-ttu-id="74215-484">Der `Parameter Table Scan`-Operator scannt eine Tabelle, die als Parameter in der aktuellen Abfrage dient.</span><span class="sxs-lookup"><span data-stu-id="74215-484">The `Parameter Table Scan` operator scans a table that is acting as a parameter in the current query.</span></span> <span data-ttu-id="74215-485">In der Regel wird dieser Operator für INSERT-Abfragen in einer gespeicherten Prozedur verwendet.</span><span class="sxs-lookup"><span data-stu-id="74215-485">Typically, this is used for INSERT queries within a stored procedure.</span></span> <span data-ttu-id="74215-486">`Parameter Table Scan` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-486">`Parameter Table Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-487">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-487">None</span></span>|<span data-ttu-id="74215-488">**Partial Aggregate**</span><span class="sxs-lookup"><span data-stu-id="74215-488">**Partial Aggregate**</span></span>|<span data-ttu-id="74215-489">**Partial Aggregate** wird in parallelen Plänen verwendet.</span><span class="sxs-lookup"><span data-stu-id="74215-489">**Partial Aggregate** is used in parallel plans.</span></span> <span data-ttu-id="74215-490">Hiermit wird eine Aggregatfunktion auf möglichst viele Eingabezeilen angewandt, damit das Schreiben auf den Datenträger (der so genannte "Überlauf") nicht erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="74215-490">It applies an aggregation function to as many input rows as possible so that writing to disk (known as a "spill") is not necessary.</span></span> <span data-ttu-id="74215-491">`Hash Match`ist der einzige physische Operator (Iterator), der die Partitions Aggregation implementiert.</span><span class="sxs-lookup"><span data-stu-id="74215-491">`Hash Match` is the only physical operator (iterator) that implements partition aggregation.</span></span> <span data-ttu-id="74215-492">**Partial Aggregate** ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-492">**Partial Aggregate** is a logical operator.</span></span>|  
|<span data-ttu-id="74215-493">![Population Query-Cursoroperator (Symbol)](../../2014/database-engine/media/poulation-query-32x.gif "Population Query-Cursoroperator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-493">![Population query cursor operator icon](../../2014/database-engine/media/poulation-query-32x.gif "Population query cursor operator icon")</span></span>|`Population Query`|<span data-ttu-id="74215-494">Der `Population Query`-Operator füllt die Arbeitstabelle eines Cursors auf, wenn der Cursor geöffnet wird.</span><span class="sxs-lookup"><span data-stu-id="74215-494">The `Population Query` operator populates the work table of a cursor when the cursor is opened.</span></span>|  
|<span data-ttu-id="74215-495">![Refresh Query-Cursoroperator (Symbol)](../../2014/database-engine/media/refresh-query-32x.gif "Refresh Query-Cursoroperator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-495">![Refresh query cursor operator icon](../../2014/database-engine/media/refresh-query-32x.gif "Refresh query cursor operator icon")</span></span>|`Refresh Query`|<span data-ttu-id="74215-496">Der `Refresh Query`-Operator ruft aktuelle Daten für die Zeilen im Fetchpuffer ab.</span><span class="sxs-lookup"><span data-stu-id="74215-496">The `Refresh Query` operator fetches current data for rows in the fetch buffer.</span></span>|  
|<span data-ttu-id="74215-497">![Remote Delete-Operator (Symbol)](../../2014/database-engine/media/remote-delete-32x.gif "Remote Delete-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-497">![Remote delete operator icon](../../2014/database-engine/media/remote-delete-32x.gif "Remote delete operator icon")</span></span>|`Remote Delete`|<span data-ttu-id="74215-498">Der `Remote Delete`-Operator löscht die Eingabezeilen in einem Remoteobjekt.</span><span class="sxs-lookup"><span data-stu-id="74215-498">The `Remote Delete` operator deletes the input rows from a remote object.</span></span> <span data-ttu-id="74215-499">`Remote Delete` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-499">`Remote Delete` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-500">![Remote Index Seek (Show Plan Operator)](../../2014/database-engine/media/remote-index-scan-32x.gif "Remote Index Seek-Showplanoperator")</span><span class="sxs-lookup"><span data-stu-id="74215-500">![remote index seek showplan operator](../../2014/database-engine/media/remote-index-scan-32x.gif "remote index seek showplan operator")</span></span>|<span data-ttu-id="74215-501">**Remote Index Scan**</span><span class="sxs-lookup"><span data-stu-id="74215-501">**Remote Index Scan**</span></span>|<span data-ttu-id="74215-502">Der **Remote Index Scan** -Operator durchsucht den in der Argumentspalte angegebenen Remoteindex.</span><span class="sxs-lookup"><span data-stu-id="74215-502">The **Remote Index Scan** operator scans the remote index specified in the Argument column.</span></span> <span data-ttu-id="74215-503">**Remote Index Scan** ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-503">**Remote Index Scan** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-504">![Remote Index Seek (Show Plan Operator)](../../2014/database-engine/media/remote-index-seek-32x.gif "Remote Index Seek-Showplanoperator")</span><span class="sxs-lookup"><span data-stu-id="74215-504">![remote index seek showplan operator](../../2014/database-engine/media/remote-index-seek-32x.gif "remote index seek showplan operator")</span></span>|<span data-ttu-id="74215-505">**Remote Index Seek**</span><span class="sxs-lookup"><span data-stu-id="74215-505">**Remote Index Seek**</span></span>|<span data-ttu-id="74215-506">Der **Remote Index Seek** -Operator verwendet die Suchmöglichkeiten eines Remoteindexobjekts, um Zeilen abzurufen.</span><span class="sxs-lookup"><span data-stu-id="74215-506">The **Remote Index Seek** operator uses the seeking ability of a remote index object to retrieve rows.</span></span> <span data-ttu-id="74215-507">Die `Argument` Spalte enthält den Namen des verwendeten Remote Indexes und das Seek:()-Prädikat.</span><span class="sxs-lookup"><span data-stu-id="74215-507">The `Argument` column contains the name of the remote index being used and the SEEK:() predicate.</span></span> <span data-ttu-id="74215-508">**Remote Index Seek** ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-508">**Remote Index Seek** is a logical physical operator.</span></span>|  
|<span data-ttu-id="74215-509">![Remote Insert-Operator (Symbol)](../../2014/database-engine/media/remote-insert-32x.gif "Remote Insert-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-509">![Remote insert operator icon](../../2014/database-engine/media/remote-insert-32x.gif "Remote insert operator icon")</span></span>|<span data-ttu-id="74215-510">**Remote Insert**</span><span class="sxs-lookup"><span data-stu-id="74215-510">**Remote Insert**</span></span>|<span data-ttu-id="74215-511">Der **Remote Insert** -Operator fügt die Eingabezeilen in ein Remoteobjekt ein.</span><span class="sxs-lookup"><span data-stu-id="74215-511">The **Remote Insert** operator inserts the input rows into a remote object.</span></span> <span data-ttu-id="74215-512">**Remote Insert** ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-512">**Remote Insert** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-513">![Remote Query-Operator (Symbol)](../../2014/database-engine/media/remote-query-32x.gif "Remote Query-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-513">![Remote query operator icon](../../2014/database-engine/media/remote-query-32x.gif "Remote query operator icon")</span></span>|`Remote Query`|<span data-ttu-id="74215-514">Durch den Operator `Remote Query` wird eine Abfrage an eine Remotequelle übermittelt.</span><span class="sxs-lookup"><span data-stu-id="74215-514">The `Remote Query` operator submits a query to a remote source.</span></span> <span data-ttu-id="74215-515">Der Text der an den Remote Server gesendeten Abfrage wird in der- `Argument` Spalte angezeigt.</span><span class="sxs-lookup"><span data-stu-id="74215-515">The text of the query sent to the remote server appears in the `Argument` column.</span></span> <span data-ttu-id="74215-516">`Remote Query` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-516">`Remote Query` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-517">![Remote Scan-Operator (Symbol)](../../2014/database-engine/media/remote-scan-32x.gif "Remote Scan-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-517">![Remote scan operator icon](../../2014/database-engine/media/remote-scan-32x.gif "Remote scan operator icon")</span></span>|`Remote Scan`|<span data-ttu-id="74215-518">Der Operator `Remote Scan` überprüft ein Remoteobjekt.</span><span class="sxs-lookup"><span data-stu-id="74215-518">The `Remote Scan` operator scans a remote object.</span></span> <span data-ttu-id="74215-519">Der Name des Remote Objekts wird in der `Argument` Spalte angezeigt.</span><span class="sxs-lookup"><span data-stu-id="74215-519">The name of the remote object appears in the `Argument` column.</span></span> <span data-ttu-id="74215-520">`Remote Scan` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-520">`Remote Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-521">![Remote Update-Operator (Symbol)](../../2014/database-engine/media/remote-update-32x.gif "Remote Update-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-521">![Remote update operator icon](../../2014/database-engine/media/remote-update-32x.gif "Remote update operator icon")</span></span>|`Remote Update`|<span data-ttu-id="74215-522">Der `Remote Update`-Operator aktualisiert die Eingabezeilen in einem Remoteobjekt.</span><span class="sxs-lookup"><span data-stu-id="74215-522">The `Remote Update` operator updates the input rows in a remote object.</span></span> <span data-ttu-id="74215-523">`Remote Update` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-523">`Remote Update` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-524">![Repartition Streams Parallelism-Operator (Symbol)](../../2014/database-engine/media/parallelism-repartition-stream.gif "Repartition Streams Parallelism-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-524">![Repartition streams parallelism operator icon](../../2014/database-engine/media/parallelism-repartition-stream.gif "Repartition streams parallelism operator icon")</span></span>|<span data-ttu-id="74215-525">**Repartition Streams**</span><span class="sxs-lookup"><span data-stu-id="74215-525">**Repartition Streams**</span></span>|<span data-ttu-id="74215-526">Der **Repartition Streams** -Operator verarbeitet und generiert mehrere Datenströme von Datensätzen.</span><span class="sxs-lookup"><span data-stu-id="74215-526">The **Repartition Streams** operator consumes multiple streams and produces multiple streams of records.</span></span> <span data-ttu-id="74215-527">Inhalt und Format der Datensätze werden nicht geändert.</span><span class="sxs-lookup"><span data-stu-id="74215-527">The record contents and format are not changed.</span></span> <span data-ttu-id="74215-528">Wenn der Abfrageoptimierer einen Bitmapfilter verwendet, wird die Anzahl der Zeilen im Ausgabedatenstrom reduziert.</span><span class="sxs-lookup"><span data-stu-id="74215-528">If the query optimizer uses a bitmap filter, the number of rows in the output stream is reduced.</span></span> <span data-ttu-id="74215-529">Jeder Datensatz aus einem Eingabedatenstrom wird in einem Ausgabedatenstrom platziert.</span><span class="sxs-lookup"><span data-stu-id="74215-529">Each record from an input stream is placed into one output stream.</span></span> <span data-ttu-id="74215-530">Wenn dieser Operator die Reihenfolge beibehalten soll, müssen alle Eingabedatenströme entsprechend geordnet vorliegen und in mehrere geordnete Ausgabedatenströme zusammengeführt werden.</span><span class="sxs-lookup"><span data-stu-id="74215-530">If this operator is order preserving, all input streams must be ordered and merged into several ordered output streams.</span></span> <span data-ttu-id="74215-531">Wenn die Ausgabe partitioniert ist, `Argument` enthält die Spalte ein Partition columns:()-Prädikat und die Partitionierungs Spalten. Wenn die Ausgabe sortiert ist, `Argument` enthält die Spalte ein Order by:()-Prädikat und die Spalten, die sortiert werden.</span><span class="sxs-lookup"><span data-stu-id="74215-531">If the output is partitioned, the `Argument` column contains a PARTITION COLUMNS:() predicate and the partitioning columns.If the output is ordered, the `Argument` column contains an ORDER BY:() predicate and the columns being ordered.</span></span> <span data-ttu-id="74215-532">**Repartition Streams** ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-532">**Repartition Streams** is a logical operator.</span></span> <span data-ttu-id="74215-533">Der Operator wird nur in parallelen Abfrageplänen verwendet.</span><span class="sxs-lookup"><span data-stu-id="74215-533">The operator is used only in parallel query plans.</span></span>|  
|<span data-ttu-id="74215-534">![Result-Sprachelement (Symbol)](../../2014/database-engine/media/result-32x.gif "Result-Sprachelement (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-534">![Result language element icon](../../2014/database-engine/media/result-32x.gif "Result language element icon")</span></span>|`Result`|<span data-ttu-id="74215-535">Der `Result`-Operator stellt die Daten dar, die am Ende eines Abfrageplans zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="74215-535">The `Result` operator is the data returned at the end of a query plan.</span></span> <span data-ttu-id="74215-536">Dies ist normalerweise das Stammelement eines Showplans.</span><span class="sxs-lookup"><span data-stu-id="74215-536">This is usually the root element of a Showplan.</span></span> <span data-ttu-id="74215-537">`Result` ist ein Sprachelement.</span><span class="sxs-lookup"><span data-stu-id="74215-537">`Result` is a language element.</span></span>|  
|<span data-ttu-id="74215-538">![RID Lookup-Operator (Symbol)](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "RID Lookup-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-538">![RID lookup operator icon](../../2014/database-engine/media/rid-nonclust-locate-32x.gif "RID lookup operator icon")</span></span>|`RID Lookup`|<span data-ttu-id="74215-539">`RID Lookup` ist ein Bookmark Lookup für einen Heap, der eine bereitgestellte Zeilen-ID (RID) verwendet.</span><span class="sxs-lookup"><span data-stu-id="74215-539">`RID Lookup` is a bookmark lookup on a heap using a supplied row identifier (RID).</span></span> <span data-ttu-id="74215-540">Die `Argument` Spalte enthält die Lesezeichen Bezeichnung, mit der die Zeile in der Tabelle und der Name der Tabelle, in der die Zeile gesucht wird, nachschlagen.</span><span class="sxs-lookup"><span data-stu-id="74215-540">The `Argument` column contains the bookmark label used to look up the row in the table and the name of the table in which the row is looked up.</span></span> <span data-ttu-id="74215-541">`RID Lookup` wird stets durch eine NESTED LOOP JOIN-Anweisung begleitet.</span><span class="sxs-lookup"><span data-stu-id="74215-541">`RID Lookup` is always accompanied by a NESTED LOOP JOIN.</span></span> <span data-ttu-id="74215-542">`RID Lookup` ist ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-542">`RID Lookup` is a physical operator.</span></span> <span data-ttu-id="74215-543">Weitere Informationen zu Bookmark Lookups finden Sie unter „[Bookmark Lookup](https://go.microsoft.com/fwlink/?LinkId=132568)“ im SQL Server-Blog von MSDN.</span><span class="sxs-lookup"><span data-stu-id="74215-543">For more information about bookmark lookups, see "[Bookmark Lookup](https://go.microsoft.com/fwlink/?LinkId=132568)" on the MSDN SQL Server blog.</span></span>|  
|<span data-ttu-id="74215-544">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-544">None</span></span>|`Right Anti Semi Join`|<span data-ttu-id="74215-545">Der logische Operator `Right Anti Semi Join` gibt alle Zeilen aus der zweiten (unteren) Eingabe aus, für die keine übereinstimmende Zeile in der ersten (oberen) Eingabe vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="74215-545">The `Right Anti Semi Join` operator outputs each row from the second (bottom) input when a matching row in the first (top) input does not exist.</span></span> <span data-ttu-id="74215-546">Eine übereinstimmende Zeile wird als Zeile definiert, die das Prädikat in der `Argument` Spalte erfüllt (wenn kein Prädikat vorhanden ist, ist jede Zeile eine übereinstimmende Zeile).</span><span class="sxs-lookup"><span data-stu-id="74215-546">A matching row is defined as a row that satisfies the predicate in the `Argument` column (if no predicate exists, each row is a matching row).</span></span> <span data-ttu-id="74215-547">`Right Anti Semi Join` ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-547">`Right Anti Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="74215-548">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-548">None</span></span>|`Right Outer Join`|<span data-ttu-id="74215-549">Der `Right Outer Join`-Operator gibt alle Zeilen zurück, die den Join der zweiten (unteren) Eingabe mit der ersten (oberen) Eingabe erfüllen.</span><span class="sxs-lookup"><span data-stu-id="74215-549">The `Right Outer Join` operator returns each row that satisfies the join of the second (bottom) input with each matching row from the first (top) input.</span></span> <span data-ttu-id="74215-550">Er gibt auch alle Zeilen aus der zweiten Eingabe mit NULL-Werten zurück, für die keine übereinstimmende Zeile in der ersten Eingabe vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="74215-550">It also returns any rows from the second input that had no matching rows in the first input, joined with NULL.</span></span> <span data-ttu-id="74215-551">Wenn kein Joinprädikat in der Spalte vorhanden ist `Argument` , ist jede Zeile eine übereinstimmende Zeile.</span><span class="sxs-lookup"><span data-stu-id="74215-551">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="74215-552">`Right Outer Join` ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-552">`Right Outer Join` is a logical operator.</span></span>|  
|<span data-ttu-id="74215-553">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-553">None</span></span>|`Right Semi Join`|<span data-ttu-id="74215-554">Der `Right Semi Join`-Operator gibt alle Zeilen aus der zweiten (unteren) Eingabe zurück, für die eine übereinstimmende Zeile in der ersten (oberen) Eingabe vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="74215-554">The `Right Semi Join` operator returns each row from the second (bottom) input when there is a matching row in the first (top) input.</span></span> <span data-ttu-id="74215-555">Wenn kein Joinprädikat in der Spalte vorhanden ist `Argument` , ist jede Zeile eine übereinstimmende Zeile.</span><span class="sxs-lookup"><span data-stu-id="74215-555">If no join predicate exists in the `Argument` column, each row is a matching row.</span></span> <span data-ttu-id="74215-556">`Right Semi Join` ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-556">`Right Semi Join` is a logical operator.</span></span>|  
|<span data-ttu-id="74215-557">![Row Count Spool-Operator (Symbol)](../../2014/database-engine/media/remote-count-spool-32x.gif "Row Count Spool-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-557">![Row count spool operator icon](../../2014/database-engine/media/remote-count-spool-32x.gif "Row count spool operator icon")</span></span>|<span data-ttu-id="74215-558">**Row Count Spool**</span><span class="sxs-lookup"><span data-stu-id="74215-558">**Row Count Spool**</span></span>|<span data-ttu-id="74215-559">Der **Row Count Spool** -Operator scannt die Eingabe, zählt, wie viele Zeilen vorhanden sind, und gibt dieselbe Anzahl an leeren Zeilen zurück.</span><span class="sxs-lookup"><span data-stu-id="74215-559">The **Row Count Spool** operator scans the input, counting how many rows are present and returning the same number of rows without any data in them.</span></span> <span data-ttu-id="74215-560">Dieser Operator wird verwendet, wenn es darauf ankommt, die Existenz von Zeilen und nicht ihren Inhalt zu überprüfen.</span><span class="sxs-lookup"><span data-stu-id="74215-560">This operator is used when it is important to check for the existence of rows, rather than the data contained in the rows.</span></span> <span data-ttu-id="74215-561">Wenn z. b. ein `Nested Loops` Operator einen Left Semi Join-Vorgang ausführt und das Joinprädikat auf die innere Eingabe angewendet wird, kann ein Row Count Spool-Vorgang am Anfang der inneren Eingabe des Operators platziert werden `Nested Loops` .</span><span class="sxs-lookup"><span data-stu-id="74215-561">For example, if a `Nested Loops` operator performs a left semi join operation and the join predicate applies to inner input, a row count spool may be placed at the top of the inner input of the `Nested Loops` operator.</span></span> <span data-ttu-id="74215-562">Anschließend `Nested Loops` kann der Operator bestimmen, wie viele Zeilen vom spoolzeilen Zähler ausgegeben werden (da die eigentlichen Daten der inneren Seite nicht benötigt werden), um zu bestimmen, ob die äußere Zeile zurückgegeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="74215-562">Then the `Nested Loops` operator can determine how many rows are output by the row count spool (because the actual data from the inner side is not needed) to determine whether to return the outer row.</span></span> <span data-ttu-id="74215-563">Beim**Row Count Spool** -Operator handelt es sich um einen physischen Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-563">**Row Count Spool** is a physical operator.</span></span>|  
|<span data-ttu-id="74215-564">![Segment-Operator (Symbol)](../../2014/database-engine/media/segment-32x.gif "Segment-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-564">![Segment operator icon](../../2014/database-engine/media/segment-32x.gif "Segment operator icon")</span></span>|<span data-ttu-id="74215-565">**Segment**</span><span class="sxs-lookup"><span data-stu-id="74215-565">**Segment**</span></span>|<span data-ttu-id="74215-566">**Segment** ist ein physischer und logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-566">**Segment** is a physical and a logical operator.</span></span> <span data-ttu-id="74215-567">Dieser Operator teilt die Eingabeset basierend auf dem Wert von mindestens einer Spalte in Segmente auf.</span><span class="sxs-lookup"><span data-stu-id="74215-567">It divides the input set into segments based on the value of one or more columns.</span></span> <span data-ttu-id="74215-568">Diese Spalten werden als Argumente im Operator **Segment** angezeigt.</span><span class="sxs-lookup"><span data-stu-id="74215-568">These columns are shown as arguments in the **Segment** operator.</span></span> <span data-ttu-id="74215-569">Anschließend gibt der Operator ein Segment nach dem anderen aus.</span><span class="sxs-lookup"><span data-stu-id="74215-569">The operator then outputs one segment at a time.</span></span>|  
|<span data-ttu-id="74215-570">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-570">None</span></span>|`Segment Repartition`|<span data-ttu-id="74215-571">Ein paralleler Abfrageplan kann mitunter logische Bereiche von Iteratoren enthalten.</span><span class="sxs-lookup"><span data-stu-id="74215-571">In a parallel query plan, sometimes there are conceptual regions of iterators.</span></span> <span data-ttu-id="74215-572">Alle Iteratoren innerhalb eines solchen Bereichs können durch parallele Threads ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="74215-572">All of the iterators within such a region can be executed by parallel threads.</span></span> <span data-ttu-id="74215-573">Die Bereiche selbst müssen seriell ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="74215-573">The regions themselves must be executed serially.</span></span> <span data-ttu-id="74215-574">Einige der `Parallelism`-Iteratoren innerhalb eines einzelnen Bereichs werden `Branch Repartition` genannt.</span><span class="sxs-lookup"><span data-stu-id="74215-574">Some of the `Parallelism` iterators within an individual region are called `Branch Repartition`.</span></span> <span data-ttu-id="74215-575">Der `Parallelism`-Iterator an der Grenze zwischen zwei Bereichen wird `Segment Repartition` genannt.</span><span class="sxs-lookup"><span data-stu-id="74215-575">The `Parallelism` iterator at the boundary of two such regions is called `Segment Repartition`.</span></span> <span data-ttu-id="74215-576">`Branch Repartition` und `Segment Repartition` sind logische Operatoren.</span><span class="sxs-lookup"><span data-stu-id="74215-576">`Branch Repartition` and `Segment Repartition` are logical operators.</span></span>|  
|<span data-ttu-id="74215-577">![Sequence-Operator (Symbol)](../../2014/database-engine/media/sequence-32x.gif "Sequence-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-577">![Sequence operator icon](../../2014/database-engine/media/sequence-32x.gif "Sequence operator icon")</span></span>|`Sequence`|<span data-ttu-id="74215-578">Der `Sequence`-Operator steuert umfangreiche Aktualisierungspläne.</span><span class="sxs-lookup"><span data-stu-id="74215-578">The `Sequence` operator drives wide update plans.</span></span> <span data-ttu-id="74215-579">Er führt die Eingaben sequenziell aus (von oben nach unten).</span><span class="sxs-lookup"><span data-stu-id="74215-579">Functionally, it executes each input in sequence (top to bottom).</span></span> <span data-ttu-id="74215-580">Jede Eingabe stellt in der Regel ein Update eines anderen Objekts dar.</span><span class="sxs-lookup"><span data-stu-id="74215-580">Each input is usually an update of a different object.</span></span> <span data-ttu-id="74215-581">Der Operator gibt nur die Zeilen zurück, die aus der letzten (unteren) Eingabe stammen.</span><span class="sxs-lookup"><span data-stu-id="74215-581">It returns only those rows that come from its last (bottom) input.</span></span> <span data-ttu-id="74215-582">`Sequence` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-582">`Sequence` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-583">![Sequence Project-Operator (Symbol)](../../2014/database-engine/media/sequence-project-32x.gif "Sequence Project-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-583">![Sequence project operator icon](../../2014/database-engine/media/sequence-project-32x.gif "Sequence project operator icon")</span></span>|`Sequence Project`|<span data-ttu-id="74215-584">Der `Sequence Project`-Operator fügt Spalten hinzu, um für eine geordnete Menge Berechnungen auszuführen.</span><span class="sxs-lookup"><span data-stu-id="74215-584">The `Sequence Project` operator adds columns to perform computations over an ordered set.</span></span> <span data-ttu-id="74215-585">Dieser Operator teilt die Eingabeset basierend auf dem Wert von mindestens einer Spalte in Segmente auf.</span><span class="sxs-lookup"><span data-stu-id="74215-585">It divides the input set into segments based on the value of one or more columns.</span></span> <span data-ttu-id="74215-586">Anschließend gibt der Operator ein Segment nach dem anderen aus.</span><span class="sxs-lookup"><span data-stu-id="74215-586">The operator then outputs one segment at a time.</span></span> <span data-ttu-id="74215-587">Diese Spalten werden im `Sequence Project`-Operator als Argumente angezeigt.</span><span class="sxs-lookup"><span data-stu-id="74215-587">These columns are shown as arguments in the `Sequence Project` operator.</span></span> <span data-ttu-id="74215-588">`Sequence Project` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-588">`Sequence Project` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-589">![Snapshot-Cursoroperator (Symbol)](../../2014/database-engine/media/snapshot-32x.gif "Snapshot-Cursoroperator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-589">![Snapshot cursor operator icon](../../2014/database-engine/media/snapshot-32x.gif "Snapshot cursor operator icon")</span></span>|<span data-ttu-id="74215-590">**Momentaufnahme**</span><span class="sxs-lookup"><span data-stu-id="74215-590">**Snapshot**</span></span>|<span data-ttu-id="74215-591">Mit dem **Snapshot** -Operator wird ein Cursor erstellt, der von anderen vorgenommene Änderungen nicht wahrnimmt.</span><span class="sxs-lookup"><span data-stu-id="74215-591">The **Snapshot** operator creates a cursor that does not see changes made by others.</span></span>|  
|<span data-ttu-id="74215-592">![Sort-Operator (Symbol)](../../2014/database-engine/media/sort-32x.gif "Sort-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-592">![Sort operator icon](../../2014/database-engine/media/sort-32x.gif "Sort operator icon")</span></span>|`Sort`|<span data-ttu-id="74215-593">Der- `Sort` Operator sortiert alle eingehenden Zeilen.</span><span class="sxs-lookup"><span data-stu-id="74215-593">The `Sort` operator sorts all incoming rows.</span></span> <span data-ttu-id="74215-594">Die `Argument` Spalte enthält entweder ein eindeutiges Order by:()-Prädikat, wenn Duplikate von diesem Vorgang entfernt werden, oder ein Order by:()-Prädikat mit einer durch Trennzeichen getrennten Liste der sortierten Spalten.</span><span class="sxs-lookup"><span data-stu-id="74215-594">The `Argument` column contains either a DISTINCT ORDER BY:() predicate if duplicates are removed by this operation, or an ORDER BY:() predicate with a comma-separated list of the columns being sorted.</span></span> <span data-ttu-id="74215-595">Die Spalten werden mit dem Präfix ASC versehen, wenn sie in aufsteigender Reihenfolge sortiert werden, oder mit der Zeichenfolge DESC, wenn sie in absteigender Reihenfolge sortiert werden.</span><span class="sxs-lookup"><span data-stu-id="74215-595">The columns are prefixed with the value ASC if the columns are sorted in ascending order, or the value DESC if the columns are sorted in descending order.</span></span> <span data-ttu-id="74215-596">`Sort` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-596">`Sort` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-597">![Split-Operator (Symbol)](../../2014/database-engine/media/split-32x.gif "Split-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-597">![Split operator icon](../../2014/database-engine/media/split-32x.gif "Split operator icon")</span></span>|`Split`|<span data-ttu-id="74215-598">Der- `Split` Operator wird verwendet, um die Update Verarbeitung zu optimieren.</span><span class="sxs-lookup"><span data-stu-id="74215-598">The `Split` operator is used to optimize update processing.</span></span> <span data-ttu-id="74215-599">Er teilt jeden Aktualisierungsvorgang in einen Lösch- und einen Einfügevorgang auf.</span><span class="sxs-lookup"><span data-stu-id="74215-599">It splits each update operation into a delete and an insert operation.</span></span> <span data-ttu-id="74215-600">`Split` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-600">`Split` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-601">![Spool-Operator (Symbol)](../../2014/database-engine/media/spool-32x.gif "Spool-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-601">![Spool operator icon](../../2014/database-engine/media/spool-32x.gif "Spool operator icon")</span></span>|<span data-ttu-id="74215-602">**Spool**</span><span class="sxs-lookup"><span data-stu-id="74215-602">**Spool**</span></span>|<span data-ttu-id="74215-603">Der **Spool** -Operator speichert ein zwischen Abfrageergebnis in der `tempdb` Datenbank.</span><span class="sxs-lookup"><span data-stu-id="74215-603">The **Spool** operator saves an intermediate query result to the `tempdb` database.</span></span>|  
|<span data-ttu-id="74215-604">![Stream Aggregate-Operator (Symbol)](../../2014/database-engine/media/stream-aggregate-32x.gif "Stream Aggregate-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-604">![Stream aggregate operator icon](../../2014/database-engine/media/stream-aggregate-32x.gif "Stream aggregate operator icon")</span></span>|`Stream Aggregate`|<span data-ttu-id="74215-605">Der `Stream Aggregate`-Operator gruppiert Zeilen nach einer oder mehreren Spalten und berechnet einen oder mehrere Aggregatausdrücke, die von der Abfrage zurückgegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="74215-605">The `Stream Aggregate` operator groups rows by one or more columns and then calculates one or more aggregate expressions returned by the query.</span></span> <span data-ttu-id="74215-606">Auf die Ausgabe dieses Operators kann durch spätere Operatoren in der Abfrage verwiesen werden, die Ausgabe kann an den Client zurückgegeben werden oder beides.</span><span class="sxs-lookup"><span data-stu-id="74215-606">The output of this operator can be referenced by later operators in the query, returned to the client, or both.</span></span> <span data-ttu-id="74215-607">Für den `Stream Aggregate`-Operator ist es erforderlich, dass die Eingabe innerhalb der Gruppen nach den Spalten sortiert ist.</span><span class="sxs-lookup"><span data-stu-id="74215-607">The `Stream Aggregate` operator requires input ordered by the columns within its groups.</span></span> <span data-ttu-id="74215-608">Der Optimierer verwendet vor diesem Operator einen `Sort`-Operator, wenn die Daten nicht bereits durch einen vorherigen `Sort`-Operator oder durch einen geordneten Indexsuch- oder Scanvorgang sortiert wurden.</span><span class="sxs-lookup"><span data-stu-id="74215-608">The optimizer will use a `Sort` operator prior to this operator if the data is not already sorted due to a prior `Sort` operator or due to an ordered index seek or scan.</span></span> <span data-ttu-id="74215-609">In der SHOWPLAN_ALL-Anweisung oder im grafischen Ausführungsplan in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)] werden die Spalten im Group by-Prädikat in der `Argument` -Spalte aufgelistet, und die Aggregat Ausdrücke sind in der Spalte **definierte Werte** aufgelistet.</span><span class="sxs-lookup"><span data-stu-id="74215-609">In the SHOWPLAN_ALL statement or the graphical execution plan in [!INCLUDE[ssManStudioFull](../includes/ssmanstudiofull-md.md)], the columns in the GROUP BY predicate are listed in the `Argument` column, and the aggregate expressions are listed in the **Defined Values** column.</span></span> <span data-ttu-id="74215-610">`Stream Aggregate` ist ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-610">`Stream Aggregate` is a physical operator.</span></span>|  
|<span data-ttu-id="74215-611">![Switch-Operator (Symbol)](../../2014/database-engine/media/switch-32x.gif "Switch-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-611">![Switch operator icon](../../2014/database-engine/media/switch-32x.gif "Switch operator icon")</span></span>|<span data-ttu-id="74215-612">**Switch**</span><span class="sxs-lookup"><span data-stu-id="74215-612">**Switch**</span></span>|<span data-ttu-id="74215-613">**Switch** ist ein spezieller Verkettungsiterator, der über *n* Eingaben verfügt.</span><span class="sxs-lookup"><span data-stu-id="74215-613">**Switch** is a special type of concatenation iterator that has *n* inputs.</span></span> <span data-ttu-id="74215-614">Mit jedem **Switch** -Operator ist ein Ausdruck verbunden.</span><span class="sxs-lookup"><span data-stu-id="74215-614">An expression is associated with each **Switch** operator.</span></span> <span data-ttu-id="74215-615">Abhängig vom Rückgabewert des Ausdrucks (zwischen 0 und *n*-1) kopiert **Switch** den entsprechenden Eingabedatenstrom in den Ausgabedatenstrom.</span><span class="sxs-lookup"><span data-stu-id="74215-615">Depending on the return value of the expression (between 0 and *n*-1), **Switch** copies the appropriate input stream to the output stream.</span></span> <span data-ttu-id="74215-616">Eine Verwendungsmöglichkeit von **Switch** besteht in der Implementierung von Abfrageplänen, die schnelle Vorwärtscursor mit bestimmten Operatoren, z.B. dem **TOP** -Operator, enthalten.</span><span class="sxs-lookup"><span data-stu-id="74215-616">One use of **Switch** is to implement query plans involving fast forward cursors with certain operators such as the **TOP** operator.</span></span> <span data-ttu-id="74215-617">**Switch** ist sowohl ein logischer als auch ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-617">**Switch** is both a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-618">![Table Delete-Operator (Symbol)](../../2014/database-engine/media/table-delete-32x.gif "Table Delete-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-618">![Table delete operator icon](../../2014/database-engine/media/table-delete-32x.gif "Table delete operator icon")</span></span>|`Table Delete`|<span data-ttu-id="74215-619">Der `Table Delete` physische Operator löscht Zeilen aus der Tabelle, die in der- `Argument` Spalte des Abfrage Ausführungs Plans angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="74215-619">The `Table Delete` physical operator deletes rows from the table specified in the `Argument` column of the query execution plan.</span></span>|  
|<span data-ttu-id="74215-620">![Table Insert-Operator (Symbol)](../../2014/database-engine/media/table-insert-32x.gif "Table Insert-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-620">![Table insert operator icon](../../2014/database-engine/media/table-insert-32x.gif "Table insert operator icon")</span></span>|`Table Insert`|<span data-ttu-id="74215-621">Der- `Table Insert` Operator Fügt Zeilen aus der Eingabe in die Tabelle ein, die in der- `Argument` Spalte des Abfrage Ausführungs Plans angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="74215-621">The `Table Insert` operator inserts rows from its input into the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="74215-622">Die `Argument`-Spalte enthält auch ein SET:()-Prädikat, das den für die einzelnen Spalten festgelegten Wert anzeigt.</span><span class="sxs-lookup"><span data-stu-id="74215-622">The `Argument` column also contains a SET:() predicate, which indicates the value to which each column is set.</span></span> <span data-ttu-id="74215-623">Wenn `Table Insert` keine untergeordneten Elemente für Eingabewerte enthält, wird die eingefügte Zeile aus dem Insert-Operator selbst übernommen.</span><span class="sxs-lookup"><span data-stu-id="74215-623">If `Table Insert` has no children for insert values, then the row inserted is taken from the Insert operator itself.</span></span> <span data-ttu-id="74215-624">`Table Insert` ist ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-624">`Table Insert` is a physical operator.</span></span>|  
|<span data-ttu-id="74215-625">![Table Merge-Operator](../../2014/database-engine/media/table-merge-32x.gif "Table Merge-Operator")</span><span class="sxs-lookup"><span data-stu-id="74215-625">![Table merge operator](../../2014/database-engine/media/table-merge-32x.gif "Table merge operator")</span></span>|<span data-ttu-id="74215-626">**Table Merge**</span><span class="sxs-lookup"><span data-stu-id="74215-626">**Table Merge**</span></span>|<span data-ttu-id="74215-627">Der **Table Merge** -Operator wendet einen Mergedatenstrom auf einen Heap an.</span><span class="sxs-lookup"><span data-stu-id="74215-627">The **Table Merge** operator applies a merge data stream to a heap.</span></span> <span data-ttu-id="74215-628">Der-Operator löscht, aktualisiert oder fügt Zeilen in der Tabelle ein, die in der- `Argument` Spalte des-Operators angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="74215-628">The operator deletes, updates, or inserts rows in the table specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="74215-629">Der tatsächlich ausgeführte Vorgang hängt vom Lauf Zeitwert der **Aktions** Spalte ab, die in der- `Argument` Spalte des-Operators angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="74215-629">The actual operation performed depends on the run-time value of the **ACTION** column specified in the `Argument` column of the operator.</span></span> <span data-ttu-id="74215-630">**Table Merge** ist ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-630">**Table Merge** is a physical operator.</span></span>|  
|<span data-ttu-id="74215-631">![Table Scan-Operator (Symbol)](../../2014/database-engine/media/table-scan-32x.gif "Table Scan-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-631">![Table scan operator icon](../../2014/database-engine/media/table-scan-32x.gif "Table scan operator icon")</span></span>|`Table Scan`|<span data-ttu-id="74215-632">Der- `Table Scan` Operator Ruft alle Zeilen aus der Tabelle ab, die in der- `Argument` Spalte des Abfrage Ausführungs Plans angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="74215-632">The `Table Scan` operator retrieves all rows from the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="74215-633">Wenn ein WHERE:()-Prädikat in der `Argument` Spalte angezeigt wird, werden nur die Zeilen zurückgegeben, die das Prädikat erfüllen.</span><span class="sxs-lookup"><span data-stu-id="74215-633">If a WHERE:() predicate appears in the `Argument` column, only those rows that satisfy the predicate are returned.</span></span> <span data-ttu-id="74215-634">`Table Scan` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-634">`Table Scan` is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-635">![Table Spool-Operator (Symbol)](../../2014/database-engine/media/table-spool-32x.gif "Table Spool-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-635">![Table spool operator icon](../../2014/database-engine/media/table-spool-32x.gif "Table spool operator icon")</span></span>|<span data-ttu-id="74215-636">**Table Spool**</span><span class="sxs-lookup"><span data-stu-id="74215-636">**Table Spool**</span></span>|<span data-ttu-id="74215-637">Der **Table Spool** -Operator scannt die Eingabe und platziert eine Kopie jeder Zeile in einer verborgenen Spooltabelle, die in der [tempdb](../relational-databases/databases/tempdb-database.md) -Datenbank gespeichert und nur für die Dauer der Abfrage vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="74215-637">The **Table Spool** operator scans the input and places a copy of each row in a hidden spool table that is stored in the [tempdb](../relational-databases/databases/tempdb-database.md) database and existing only for the lifetime of the query.</span></span> <span data-ttu-id="74215-638">Wenn der Operator zurückgesetzt wird (z. b. durch einen `Nested Loops` Operator), aber keine erneute Bindung erforderlich ist, werden die gespoolten Daten verwendet, anstatt die Eingabe erneut zu scannen.</span><span class="sxs-lookup"><span data-stu-id="74215-638">If the operator is rewound (for example, by a `Nested Loops` operator) but no rebinding is needed, the spooled data is used instead of rescanning the input.</span></span> <span data-ttu-id="74215-639">**Table Spool** ist ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-639">**Table Spool** is a physical operator.</span></span>|  
|<span data-ttu-id="74215-640">![Table Update-Operator (Symbol)](../../2014/database-engine/media/table-update-32x.gif "Table Update-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-640">![Table update operator icon](../../2014/database-engine/media/table-update-32x.gif "Table update operator icon")</span></span>|`Table Update`|<span data-ttu-id="74215-641">Der `Table Update` physische-Operator aktualisiert die Eingabezeilen in der Tabelle, die in der- `Argument` Spalte des Abfrage Ausführungs Plans angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="74215-641">The `Table Update` physical operator updates input rows in the table specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="74215-642">Das SET:()-Prädikat bestimmt den Wert jeder aktualisierten Spalte.</span><span class="sxs-lookup"><span data-stu-id="74215-642">The SET:() predicate determines the value of each updated column.</span></span> <span data-ttu-id="74215-643">Auf diese Werte kann in der SET-Klausel oder an anderer Stelle in diesem Operator sowie an anderer Stelle dieser Abfrage verwiesen werden.</span><span class="sxs-lookup"><span data-stu-id="74215-643">These values may be referenced in the SET clause or elsewhere within this operator as well as elsewhere within this query.</span></span>|  
|<span data-ttu-id="74215-644">![Tabellenwertfunktion-Operator (Symbol)](../../2014/database-engine/media/table-valued-function-32x.gif "Tabellenwertfunktion-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-644">![Table-valued function operator icon](../../2014/database-engine/media/table-valued-function-32x.gif "Table-valued function operator icon")</span></span>|<span data-ttu-id="74215-645">**Table-valued Function**</span><span class="sxs-lookup"><span data-stu-id="74215-645">**Table-valued Function**</span></span>|<span data-ttu-id="74215-646">Mit dem Operator **Tabellenwertfunktion** wird eine Tabellenwertfunktion ausgewertet ( [!INCLUDE[tsql](../includes/tsql-md.md)] oder CLR), und die Ergebniszeilen werden in der [tempdb](../relational-databases/databases/tempdb-database.md) -Datenbank gespeichert.</span><span class="sxs-lookup"><span data-stu-id="74215-646">The **Table-valued Function** operator evaluates a table-valued function (either [!INCLUDE[tsql](../includes/tsql-md.md)] or CLR), and stores the resulting rows in the [tempdb](../relational-databases/databases/tempdb-database.md) database.</span></span> <span data-ttu-id="74215-647">Wenn die übergeordneten Iteratoren die Zeilen anfordern, gibt die **Tabellenwert Funktion** die Zeilen aus zurück `tempdb` .</span><span class="sxs-lookup"><span data-stu-id="74215-647">When the parent iterators request the rows, **Table-valued Function** returns the rows from `tempdb`.</span></span><br /><br /> <span data-ttu-id="74215-648">Abfragen mit Aufrufen von Tabellenwertfunktionen generieren Abfragepläne mit dem **Tabellenwertfunktion** -Iterator.</span><span class="sxs-lookup"><span data-stu-id="74215-648">Queries with calls to table-valued functions generate query plans with the **Table-valued Function** iterator.</span></span> <span data-ttu-id="74215-649">Die**Tabellenwertfunktion** kann mit verschiedenen Parameterwerten analysiert werden:</span><span class="sxs-lookup"><span data-stu-id="74215-649">**Table-valued Function** can be evaluated with different parameter values:</span></span><br /><br /> <span data-ttu-id="74215-650">Der**Tabellenwertfunktion-XML-Leser** gibt einen XML-BLOB als Parameter ein und erstellt ein Rowset, das XML-Knoten in der XML-Dokumentreihenfolge darstellt.</span><span class="sxs-lookup"><span data-stu-id="74215-650">**Table-valued Function XML Reader** inputs an XML BLOB as a parameter and produces a rowset representing XML nodes in XML document order.</span></span> <span data-ttu-id="74215-651">Andere Eingabeparameter können die zurückgegebenen XML-Knoten auf eine Teilmenge von XML-Dokumenten einschränken.</span><span class="sxs-lookup"><span data-stu-id="74215-651">Other input parameters may restrict XML nodes returned to a subset of XML document.</span></span><br /><br /> <span data-ttu-id="74215-652">**Tabellenwertfunktion-XML-Leser mit XPath-Filter** ist ein spezieller Typ von **Tabellenwertfunktion-XML-Leser** , der die Ausgabe auf XML-Knoten einschränkt, die einen XPath-Ausdruck erfüllen.</span><span class="sxs-lookup"><span data-stu-id="74215-652">**Table Valued Function XML Reader with XPath filter** is a special type of **XML Reader Table-valued Function** that restricts output to XML nodes satisfying an XPath expression.</span></span><br /><br /> <br /><br /> <span data-ttu-id="74215-653">Die**Tabellenwertfunktion** ist sowohl ein logischer als auch ein physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-653">**Table-valued Function** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-654">![Top-Operator (Symbol)](../../2014/database-engine/media/top-32x.gif "Top-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-654">![Top operator icon](../../2014/database-engine/media/top-32x.gif "Top operator icon")</span></span>|<span data-ttu-id="74215-655">**Top**</span><span class="sxs-lookup"><span data-stu-id="74215-655">**Top**</span></span>|<span data-ttu-id="74215-656">Der **Top** -Operator scannt die Eingabe und gibt nur die angegebene Anzahl bzw. den angegebenen Prozentsatz von Zeilen zurück, meist basierend auf einer Sortierreihenfolge.</span><span class="sxs-lookup"><span data-stu-id="74215-656">The **Top** operator scans the input, returning only the first specified number or percent of rows, possibly based on a sort order.</span></span> <span data-ttu-id="74215-657">Die `Argument` Spalte kann eine Liste der Spalten enthalten, die auf Verknüpfungen geprüft werden.</span><span class="sxs-lookup"><span data-stu-id="74215-657">The `Argument` column can contain a list of the columns that are being checked for ties.</span></span> <span data-ttu-id="74215-658">In Updateplänen wird der **Top** -Operator verwendet, um die Einschränkung der Zeilenanzahl zu erzwingen.</span><span class="sxs-lookup"><span data-stu-id="74215-658">In update plans, the **Top** operator is used to enforce row count limits.</span></span> <span data-ttu-id="74215-659">**Top** ist sowohl ein logischer als auch physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-659">**Top** is a logical and physical operator.</span></span> <span data-ttu-id="74215-660">**Top** ist sowohl ein logischer als auch physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-660">**Top** is a logical and physical operator.</span></span>|  
|<span data-ttu-id="74215-661">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-661">None</span></span>|<span data-ttu-id="74215-662">**Top N Sort**</span><span class="sxs-lookup"><span data-stu-id="74215-662">**Top N Sort**</span></span>|<span data-ttu-id="74215-663">**Top N Sort** ähnelt dem `Sort` Iterator, mit dem Unterschied, dass nur die ersten *n* Zeilen benötigt werden und nicht das gesamte Resultset.</span><span class="sxs-lookup"><span data-stu-id="74215-663">**Top N Sort** is similar to the `Sort` iterator, except that only the first *N* rows are needed, and not the entire result set.</span></span> <span data-ttu-id="74215-664">Bei kleinen Werten für *N* versucht die [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)]-Abfrageausführungs-Engine, den gesamten Sortiervorgang im Arbeitsspeicher auszuführen.</span><span class="sxs-lookup"><span data-stu-id="74215-664">For small values of *N*, the [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)] query execution engine attempts to perform the entire sort operation in memory.</span></span> <span data-ttu-id="74215-665">Bei großen Werten für *N* greift die Abfrageausführungs-Engine auf die mehr generische Methode der Sortierung zurück, für die *N* kein Parameter ist.</span><span class="sxs-lookup"><span data-stu-id="74215-665">For large values of *N*, the query execution engine resorts to the more generic method of sorting to which *N* is not a parameter.</span></span>|  
|<span data-ttu-id="74215-666">![Erweiterter Operator (UDX – Symbol)](../../2014/database-engine/media/udx-32x.gif "Erweiterter Operator (UDX – Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-666">![Extended operator (UDX) icon](../../2014/database-engine/media/udx-32x.gif "Extended operator (UDX) icon")</span></span>|`UDX`|<span data-ttu-id="74215-667">Erweiterte Operatoren (UDX) implementieren einen von vielen XQuery- und XPath-Vorgängen in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="74215-667">Extended Operators (UDX) implement one of many XQuery and XPath operations in [!INCLUDE[ssNoVersion](../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="74215-668">Alle UDX-Operatoren sind sowohl logische als auch physische Operatoren.</span><span class="sxs-lookup"><span data-stu-id="74215-668">All UDX operators are both logical and physical operators.</span></span><br /><br /> <span data-ttu-id="74215-669">Mit dem erweiterten Operator (UDX) `FOR XML` wird das relationale Rowset serialisiert, das in die XML-Darstellung einer einzelnen BLOB-Spalte in einer einzigen Ausgabezeile eingegeben wird.</span><span class="sxs-lookup"><span data-stu-id="74215-669">Extended operator (UDX) `FOR XML` is used to serialize the relational row set it inputs into XML representation in a single BLOB column in a single output row.</span></span> <span data-ttu-id="74215-670">Bei diesem XML-Aggregationsoperator wird die Reihenfolge berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="74215-670">It is an order sensitive XML aggregation operator.</span></span><br /><br /> <span data-ttu-id="74215-671">Der erweiterte Operator (UDX) `XML SERIALIZER` ist ein XML-Aggregationsoperator, bei dem die Reihenfolge berücksichtigt wird.</span><span class="sxs-lookup"><span data-stu-id="74215-671">Extended operator (UDX) `XML SERIALIZER` is an order sensitive XML aggregation operator.</span></span> <span data-ttu-id="74215-672">Er gibt Zeilen ein, die XML-Knoten oder XQuery-Skalarwerte in der XML-Dokumentreihenfolge darstellen, und erstellt eine serialisierte XML-BLOB-Spalte in einer einzelnen XML-Spalte in einer einzigen Ausgabezeile.</span><span class="sxs-lookup"><span data-stu-id="74215-672">It inputs rows representing XML nodes or XQuery scalars in XML document order and produces a serialized XML BLOB in a single XML column in a single output row.</span></span><br /><br /> <span data-ttu-id="74215-673">Der erweiterte Operator (UDX) `XML FRAGMENT SERIALIZER` ist eine Sonderform von `XML SERIALIZER`, womit Eingabezeilen verarbeitet werden, die XML-Fragmente darstellen, die in der XQuery-Erweiterung zum Ändern von Einfügungsdaten eingefügt werden.</span><span class="sxs-lookup"><span data-stu-id="74215-673">Extended operator (UDX) `XML FRAGMENT SERIALIZER` is a special type of `XML SERIALIZER` that is used for processing input rows representing XML fragments being inserted in XQuery insert data modification extension.</span></span><br /><br /> <span data-ttu-id="74215-674">Der erweiterte Operator (UDX) `XQUERY STRING` wertet den XQuery-Zeichenfolgenwert von Eingabezeilen aus, die XML-Knoten darstellen.</span><span class="sxs-lookup"><span data-stu-id="74215-674">Extended operator (UDX) `XQUERY STRING` evaluates the XQuery string value of input rows representing XML nodes.</span></span> <span data-ttu-id="74215-675">Bei diesem Zeichenfolgen-Aggregationsoperator wird die Reihenfolge berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="74215-675">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="74215-676">Er gibt eine Zeile mit Spalten zurück, die den XQuery-Skalarwert darstellt, der den Zeichenfolgenwert der Eingabe enthält.</span><span class="sxs-lookup"><span data-stu-id="74215-676">It outputs one row with columns representing the XQuery scalar that contains string value of the input.</span></span><br /><br /> <span data-ttu-id="74215-677">Der erweiterte Operator (UDX) `XQUERY LIST DECOMPOSER` ist ein XQuery-Listendekompositionsoperator.</span><span class="sxs-lookup"><span data-stu-id="74215-677">Extended operator (UDX) `XQUERY LIST DECOMPOSER` is an XQuery list decomposition operator.</span></span> <span data-ttu-id="74215-678">Für jede Eingabezeile, die einen XML-Knoten darstellt, erstellt dieser Operator mindestens eine Zeile, die einen XQuery-Skalarwert mit einem Listenelementwert darstellt, falls die Eingabe vom XSD-Listentyp ist.</span><span class="sxs-lookup"><span data-stu-id="74215-678">For each input row representing an XML node it produces one or more rows each representing XQuery scalar containing a list element value if the input is of XSD list type.</span></span><br /><br /> <span data-ttu-id="74215-679">Der erweiterte Operator (UDX) `XQUERY DATA` wertet die XQuery-Funktion fn:data() in Eingabezeilen aus, die XML-Knoten darstellen.</span><span class="sxs-lookup"><span data-stu-id="74215-679">Extended operator (UDX) `XQUERY DATA` evaluates the XQuery fn:data() function on input representing XML nodes.</span></span> <span data-ttu-id="74215-680">Bei diesem Zeichenfolgen-Aggregationsoperator wird die Reihenfolge berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="74215-680">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="74215-681">Er gibt eine Zeile mit Spalten zurück, die den XQuery-Skalarwert darstellt, der das Ergebnis von **fn:data()** enthält.</span><span class="sxs-lookup"><span data-stu-id="74215-681">It outputs one row with columns representing XQuery scalar that contains the result of **fn:data()**.</span></span><br /><br /> <span data-ttu-id="74215-682">Der erweiterte Operator `XQUERY CONTAINS` wertet die XQuery-Funktion fn:contains() in Eingabezeilen aus, die XML-Knoten darstellen.</span><span class="sxs-lookup"><span data-stu-id="74215-682">Extended operator `XQUERY CONTAINS` evaluates the XQuery fn:contains() function on input representing XML nodes.</span></span> <span data-ttu-id="74215-683">Bei diesem Zeichenfolgen-Aggregationsoperator wird die Reihenfolge berücksichtigt.</span><span class="sxs-lookup"><span data-stu-id="74215-683">It is an order sensitive string aggregation operator.</span></span> <span data-ttu-id="74215-684">Er gibt eine Zeile mit Spalten zurück, die den XQuery-Skalarwert darstellt, der das Ergebnis von **fn:contains()** enthält.</span><span class="sxs-lookup"><span data-stu-id="74215-684">It outputs one row with columns representing XQuery scalar that contains the result of **fn:contains()**.</span></span><br /><br /> <span data-ttu-id="74215-685">Der erweiterte Operator `UPDATE XML NODE` aktualisiert den XML-Knoten in der XQuery-Erweiterung zum Ersetzen von Daten in der **Modify ()** -Methode für den XML-Typ.</span><span class="sxs-lookup"><span data-stu-id="74215-685">Extended operator `UPDATE XML NODE` updates XML node in the XQuery replace data modification extension in the **modify()** method on XML type.</span></span>|  
|<span data-ttu-id="74215-686">Keine</span><span class="sxs-lookup"><span data-stu-id="74215-686">None</span></span>|<span data-ttu-id="74215-687">**Union**</span><span class="sxs-lookup"><span data-stu-id="74215-687">**Union**</span></span>|<span data-ttu-id="74215-688">Der **Union** -Operator scannt mehrere Eingaben und gibt alle gescannten Zeilen aus, wobei Duplikate entfernt werden.</span><span class="sxs-lookup"><span data-stu-id="74215-688">The **Union** operator scans multiple inputs, outputting each row scanned and removing duplicates.</span></span> <span data-ttu-id="74215-689">**Union** ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-689">**Union** is a logical operator.</span></span>|  
|<span data-ttu-id="74215-690">![Update-Operatorsymbol (Datenbank-Engine)](../../2014/database-engine/media/update-32x.gif "Update-Operatorsymbol (Datenbank-Engine)")</span><span class="sxs-lookup"><span data-stu-id="74215-690">![Update (Database Engine) operator icon](../../2014/database-engine/media/update-32x.gif "Update (Database Engine) operator icon")</span></span>|`Update`|<span data-ttu-id="74215-691">Der- `Update` Operator aktualisiert jede Zeile aus der Eingabe in dem-Objekt, das in der- `Argument` Spalte des Abfrage Ausführungs Plans angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="74215-691">The `Update` operator updates each row from its input in the object specified in the `Argument` column of the query execution plan.</span></span> <span data-ttu-id="74215-692">`Update` ist ein logischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-692">`Update` is a logical operator.</span></span> <span data-ttu-id="74215-693">Der physische Operator ist `Table Update`, `Index Update` oder `Clustered Index Update`.</span><span class="sxs-lookup"><span data-stu-id="74215-693">The physical operator is `Table Update`, `Index Update`, or `Clustered Index Update`.</span></span>|  
|<span data-ttu-id="74215-694">![While-Sprachelement (Symbol)](../../2014/database-engine/media/while-32x.gif "While-Sprachelement (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-694">![While language element icon](../../2014/database-engine/media/while-32x.gif "While language element icon")</span></span>|`While`|<span data-ttu-id="74215-695">Der `While`-Operator implementiert die WHILE-Schleife von [!INCLUDE[tsql](../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="74215-695">The `While` operator implements the [!INCLUDE[tsql](../includes/tsql-md.md)] while loop.</span></span> <span data-ttu-id="74215-696">`While`ist ein sprach Element</span><span class="sxs-lookup"><span data-stu-id="74215-696">`While` is a language element</span></span>|  
|<span data-ttu-id="74215-697">![Table Spool-Operator (Symbol)](../../2014/database-engine/media/table-spool-32x.gif "Table Spool-Operator (Symbol)")</span><span class="sxs-lookup"><span data-stu-id="74215-697">![Table spool operator icon](../../2014/database-engine/media/table-spool-32x.gif "Table spool operator icon")</span></span>|`Window Spool`|<span data-ttu-id="74215-698">Der `Window Spool`-Operator erweitert jede Zeile in den Satz von Zeilen, die das ihm zugeordnete Fenster darstellen.</span><span class="sxs-lookup"><span data-stu-id="74215-698">The `Window Spool` operator expands each row into the set of rows that represents the window associated with it.</span></span> <span data-ttu-id="74215-699">In einer Abfrage definiert die OVER-Klausel das Fenster innerhalb eines Abfrageresultsets, und eine Fensterfunktion berechnet dann einen Wert für jede Zeile im Fenster.</span><span class="sxs-lookup"><span data-stu-id="74215-699">In a query, the OVER clause defines the window within a query result set and a window function then computes a value for each row in the window.</span></span> <span data-ttu-id="74215-700">`Window Spool` ist ein logischer und physischer Operator.</span><span class="sxs-lookup"><span data-stu-id="74215-700">`Window Spool` is a logical and physical operator.</span></span>|  
  
  
