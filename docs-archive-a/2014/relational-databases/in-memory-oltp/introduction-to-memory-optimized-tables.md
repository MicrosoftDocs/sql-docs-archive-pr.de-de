---
title: Einführung in speicheroptimierte Tabellen | Microsoft-Dokumentation
ms.custom: ''
ms.date: 07/14/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: ef1cc7de-63be-4fa3-a622-6d93b440e3ac
author: rothja
ms.author: jroth
ms.openlocfilehash: edcdea9d266cf0ef231b1e16be4da7009372dcd6
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/04/2020
ms.locfileid: "87725782"
---
# <a name="introduction-to-memory-optimized-tables"></a><span data-ttu-id="0155f-102">Einführung in speicheroptimierte Tabellen</span><span class="sxs-lookup"><span data-stu-id="0155f-102">Introduction to Memory-Optimized Tables</span></span>
  <span data-ttu-id="0155f-103">Speicheroptimierte Tabellen sind Tabellen, die mit [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql) erstellt wurden.</span><span class="sxs-lookup"><span data-stu-id="0155f-103">Memory-optimized tables are tables, created using [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql).</span></span>  
  
 <span data-ttu-id="0155f-104">Die speicheroptimierten Tabellen befinden sich im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="0155f-104">Memory-optimized tables reside in memory.</span></span> <span data-ttu-id="0155f-105">Zeilen in der Tabelle werden aus dem Arbeitsspeicher gelesen und in diesen geschrieben.</span><span class="sxs-lookup"><span data-stu-id="0155f-105">Rows in the table are read from and written to memory.</span></span> <span data-ttu-id="0155f-106">Die gesamte Tabelle befindet sich im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="0155f-106">The entire table resides in memory.</span></span> <span data-ttu-id="0155f-107">Eine zweite Kopie der Tabellendaten wird auf Festplatte gespeichert, aber nur zu Dauerhaftigkeitszwecken.</span><span class="sxs-lookup"><span data-stu-id="0155f-107">A second copy of the table data is maintained on disk, but only for durability purposes.</span></span>  
  
 <span data-ttu-id="0155f-108">In-Memory OLTP ist in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] integriert, um in allen Bereichen wie Entwicklung, Bereitstellung, Verwaltbarkeit und Unterstützbarkeit eine reibungslose Benutzererfahrung zu ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="0155f-108">In-Memory OLTP is integrated with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to provide a seamless experience in all areas such as development, deployment, manageability, and supportability.</span></span> <span data-ttu-id="0155f-109">Eine Datenbank kann speicherinterne wie auch datenträgerbasierte Objekte enthalten.</span><span class="sxs-lookup"><span data-stu-id="0155f-109">A database can contain in-memory as well as disk-based objects.</span></span>  
  
 <span data-ttu-id="0155f-110">Für Zeilen in speicheroptimierten Tabellen wird die Versionsverwaltung verwendet.</span><span class="sxs-lookup"><span data-stu-id="0155f-110">Rows in memory-optimized tables are versioned.</span></span> <span data-ttu-id="0155f-111">Dies bedeutet, dass für jede Zeile in der Tabelle möglicherweise mehrere Versionen vorliegen.</span><span class="sxs-lookup"><span data-stu-id="0155f-111">This means that each row in the table potentially has multiple versions.</span></span> <span data-ttu-id="0155f-112">Alle Zeilenversionen werden in derselben Tabellendatenstruktur verwaltet.</span><span class="sxs-lookup"><span data-stu-id="0155f-112">All row versions are maintained in the same table data structure.</span></span> <span data-ttu-id="0155f-113">Die Zeilenversionsverwaltung wird verwendet, um gleichzeitige Lese- und Schreibvorgänge für dieselbe Zeile zuzulassen.</span><span class="sxs-lookup"><span data-stu-id="0155f-113">Row versioning is used to allow concurrent reads and writes on the same row.</span></span> <span data-ttu-id="0155f-114">Weitere Informationen zu gleichzeitigen Lese-und Schreibvorgängen in derselben Zeile finden Sie unter [Transaktionen in Speicher optimierten Tabellen](memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="0155f-114">For more information about concurrent reads and writes on the same row, see [Transactions in Memory-Optimized Tables](memory-optimized-tables.md).</span></span>  
  
 <span data-ttu-id="0155f-115">Die folgende Abbildung veranschaulicht die Multiversionsverwaltung.</span><span class="sxs-lookup"><span data-stu-id="0155f-115">The following figure illustrates multi-versioning.</span></span> <span data-ttu-id="0155f-116">Die Abbildung zeigt eine Tabelle mit drei Zeilen, und jede Zeile weist unterschiedliche Versionen auf.</span><span class="sxs-lookup"><span data-stu-id="0155f-116">The figure shows a table with three rows and each row has different versions.</span></span>  
  
 <span data-ttu-id="0155f-117">![Multiversionsverwaltung](../../database-engine/media/hekaton-tables-1.gif "Multiversionsverwaltung")</span><span class="sxs-lookup"><span data-stu-id="0155f-117">![Multi-versioning.](../../database-engine/media/hekaton-tables-1.gif "Multi-versioning.")</span></span>  
  
 <span data-ttu-id="0155f-118">Die Tabelle enthält drei Zeilen: r1, r2 und r3.</span><span class="sxs-lookup"><span data-stu-id="0155f-118">The table has three rows: r1, r2, and r3.</span></span> <span data-ttu-id="0155f-119">r1 verfügt über drei Versionen, r2 über zwei Versionen und r3 über vier Versionen.</span><span class="sxs-lookup"><span data-stu-id="0155f-119">r1 has three versions, r2 has two versions, and r3 has four versions.</span></span> <span data-ttu-id="0155f-120">Beachten Sie, dass unterschiedliche Versionen derselben Zeile nicht unbedingt aufeinander folgende Speicheradressen belegen.</span><span class="sxs-lookup"><span data-stu-id="0155f-120">Note that different versions of the same row do not necessarily occupy consecutive memory locations.</span></span> <span data-ttu-id="0155f-121">Die unterschiedlichen Zielversionen können über die Tabellendatenstruktur verteilt sein.</span><span class="sxs-lookup"><span data-stu-id="0155f-121">The different row versions can be dispersed throughout the table data structure.</span></span>  
  
 <span data-ttu-id="0155f-122">Die speicheroptimierte Tabellendatenstruktur kann als Auflistung von Zeilenversionen gesehen werden.</span><span class="sxs-lookup"><span data-stu-id="0155f-122">The memory-optimized table data structure can be seen as a collection of row versions.</span></span> <span data-ttu-id="0155f-123">Während Zeilen in datenträgerbasierten Tabellen in Seiten und Blöcken angeordnet sind und einzelne Zeilen mithilfe der Seitenzahl und des Seitenoffsets adressiert werden, werden Zeilenversionen in speicheroptimierten Tabellen mithilfe von 8-Byte-Speicherzeigern adressiert.</span><span class="sxs-lookup"><span data-stu-id="0155f-123">Rows in disk-based tables are organized in pages and extents, and individual rows addressed using page number and page offset, row versions in memory-optimized tables are addressed using 8-byte memory pointers.</span></span>  
  
## <a name="durability"></a><span data-ttu-id="0155f-124">Beständigkeit</span><span class="sxs-lookup"><span data-stu-id="0155f-124">Durability</span></span>  
 <span data-ttu-id="0155f-125">Speicheroptimierte Tabellen sind standardmäßig vollständig dauerhaft und bieten, wie Transaktionen in (herkömmlichen) datenträgerbasierten Tabellen, vollständige ACID-Eigenschaften (atomar, konsistent, isoliert und beständig).</span><span class="sxs-lookup"><span data-stu-id="0155f-125">Memory-optimized tables are fully durable by default, and, like transactions on (traditional) disk-based tables, fully durable transactions on memory-optimized tables are fully atomic, consistent, isolated, and durable (ACID).</span></span> <span data-ttu-id="0155f-126">Speicheroptimierte Tabellen und systemintern kompilierte gespeicherte Prozeduren unterstützen eine Teilmenge von [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="0155f-126">Memory-optimized tables and natively compiled stored procedures support a subset of [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span>  
  
 <span data-ttu-id="0155f-127">In-Memory OLTP unterstützt dauerhafte Tabellen mit verzögerter Transaktionsdauerhaftigkeit.</span><span class="sxs-lookup"><span data-stu-id="0155f-127">In-Memory OLTP supports durable tables with transaction durability delayed.</span></span> <span data-ttu-id="0155f-128">Verzögerte dauerhafte Transaktionen werden auf einem Datenträger gespeichert, sobald ein Commit für eine entsprechende Transaktion ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="0155f-128">Delayed durable transactions are saved to disk soon after the transaction has committed.</span></span> <span data-ttu-id="0155f-129">Im Austausch für die höhere Leistung besteht die Gefahr, dass Transaktionen, die noch nicht auf dem Datenträger gespeichert wurden, bei einem Absturz oder Failover des Servers verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="0155f-129">In exchange for the increased performance, committed transactions that have not saved to disk are lost in a server crash or failover.</span></span>  
  
 <span data-ttu-id="0155f-130">Neben den standardmäßig dauerhaften speicheroptimierten Tabellen unterstützt [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] auch nicht dauerhafte speicheroptimierte Tabellen, die nicht protokolliert und deren Daten nicht auf dem Datenträger beibehalten werden.</span><span class="sxs-lookup"><span data-stu-id="0155f-130">Besides the default durable memory-optimized tables, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] also supports non-durable memory-optimized tables, which are not logged and their data is not persisted on disk.</span></span> <span data-ttu-id="0155f-131">Das bedeutet, dass Transaktionen in diesen Tabellen keine Datenträger-E/A-Vorgänge erfordern, die Daten aber bei einem Serverabsturz oder einem Failover nicht wiederhergestellt werden können.</span><span class="sxs-lookup"><span data-stu-id="0155f-131">This means that transactions on these tables do not require any disk IO, but the data will not be recovered if there is a server crash or failover.</span></span>  
  
## <a name="accessing-data-in-memory-optimized-tables"></a><span data-ttu-id="0155f-132">Zugriff auf Daten in speicheroptimierten Tabellen</span><span class="sxs-lookup"><span data-stu-id="0155f-132">Accessing Data in Memory-Optimized Tables</span></span>  
 <span data-ttu-id="0155f-133">Der Datenzugriff in speicheroptimierten Tabellen erfolgt auf zwei Arten:</span><span class="sxs-lookup"><span data-stu-id="0155f-133">Data in memory-optimized tables is accessed in two ways:</span></span>  
  
-   <span data-ttu-id="0155f-134">Durch interpretiertes [!INCLUDE[tsql](../../../includes/tsql-md.md)] (außerhalb einer systemintern kompilierten gespeicherten Prozedur).</span><span class="sxs-lookup"><span data-stu-id="0155f-134">Through interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] (outside of a natively-compiled stored procedure).</span></span> <span data-ttu-id="0155f-135">Diese [!INCLUDE[tsql](../../../includes/tsql-md.md)] -Anweisungen können sich entweder in interpretierten gespeicherten Prozeduren befinden oder als Ad-hoc- [!INCLUDE[tsql](../../../includes/tsql-md.md)] -Anweisungen vorliegen.</span><span class="sxs-lookup"><span data-stu-id="0155f-135">These [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements may be either inside interpreted stored procedures or they may be ad-hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] statements.</span></span>  
  
-   <span data-ttu-id="0155f-136">Durch systemintern kompilierte gespeicherte Prozeduren</span><span class="sxs-lookup"><span data-stu-id="0155f-136">Through natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="0155f-137">Auf speicheroptimierte Tabellen kann am effizientesten mit systemintern kompilierten gespeicherten Prozeduren ([Systemintern kompilierte gespeicherte Prozeduren](natively-compiled-stored-procedures.md)) zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="0155f-137">Memory-optimized tables can be accessed most efficiently from natively compiled stored procedures ([Natively Compiled Stored Procedures](natively-compiled-stored-procedures.md)).</span></span> <span data-ttu-id="0155f-138">Auf speicheroptimierte Tabellen kann außerdem mit (herkömmlichem) interpretiertem [!INCLUDE[tsql](../../../includes/tsql-md.md)]zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="0155f-138">Memory-optimized tables can also be accessed with (traditional) interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="0155f-139">"Interpretiertes [!INCLUDE[tsql](../../../includes/tsql-md.md)] " bezieht sich auf den Zugriff auf speicheroptimierte Tabellen ohne eine systemintern kompilierte gespeicherte Prozedur.</span><span class="sxs-lookup"><span data-stu-id="0155f-139">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] refers to accessing memory-optimized tables without a natively compiled stored procedure.</span></span> <span data-ttu-id="0155f-140">Beispiele für den Zugriff auf interpretiertes [!INCLUDE[tsql](../../../includes/tsql-md.md)] sind der Zugriff auf eine speicheroptimierte Tabelle über einen DML-Trigger, einen Ad-Hoc- [!INCLUDE[tsql](../../../includes/tsql-md.md)] -Batch, eine Sicht und eine Tabellenwertfunktion.</span><span class="sxs-lookup"><span data-stu-id="0155f-140">Some examples of interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access include accessing a memory-optimized table from a DML trigger, ad hoc [!INCLUDE[tsql](../../../includes/tsql-md.md)] batch, view, and table-valued function.</span></span>  
  
 <span data-ttu-id="0155f-141">In der folgenden Tabelle wird der systemeigene und interpretierte [!INCLUDE[tsql](../../../includes/tsql-md.md)] -Zugriff für verschiedene Objekte zusammengefasst.</span><span class="sxs-lookup"><span data-stu-id="0155f-141">The following table summarizes native and interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access for various objects.</span></span>  
  
|<span data-ttu-id="0155f-142">Funktion</span><span class="sxs-lookup"><span data-stu-id="0155f-142">Feature</span></span>|<span data-ttu-id="0155f-143">Zugriff mithilfe einer systemintern kompilierten gespeicherten Prozedur</span><span class="sxs-lookup"><span data-stu-id="0155f-143">Access Using a Natively Compiled Stored Procedure</span></span>|<span data-ttu-id="0155f-144">Interpretierter [!INCLUDE[tsql](../../../includes/tsql-md.md)] -Zugriff</span><span class="sxs-lookup"><span data-stu-id="0155f-144">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] Access</span></span>|<span data-ttu-id="0155f-145">CLR-Zugriff</span><span class="sxs-lookup"><span data-stu-id="0155f-145">CLR Access</span></span>|  
|-------------|-------------------------------------------------------|-------------------------------------------|----------------|  
|<span data-ttu-id="0155f-146">Speicheroptimierte Tabellen</span><span class="sxs-lookup"><span data-stu-id="0155f-146">Memory-optimized tables</span></span>|<span data-ttu-id="0155f-147">Ja</span><span class="sxs-lookup"><span data-stu-id="0155f-147">Yes</span></span>|<span data-ttu-id="0155f-148">Ja</span><span class="sxs-lookup"><span data-stu-id="0155f-148">Yes</span></span>|<span data-ttu-id="0155f-149">Nein <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="0155f-149">No <sup>1</sup></span></span>|  
|[<span data-ttu-id="0155f-150">Speicheroptimierte Tabellenvariablen</span><span class="sxs-lookup"><span data-stu-id="0155f-150">Memory-Optimized Table Variables</span></span>](../../database-engine/memory-optimized-table-variables.md)|<span data-ttu-id="0155f-151">Ja</span><span class="sxs-lookup"><span data-stu-id="0155f-151">Yes</span></span>|<span data-ttu-id="0155f-152">Ja</span><span class="sxs-lookup"><span data-stu-id="0155f-152">Yes</span></span>|<span data-ttu-id="0155f-153">Nein</span><span class="sxs-lookup"><span data-stu-id="0155f-153">No</span></span>|  
|[<span data-ttu-id="0155f-154">Nativ kompilierte gespeicherte Prozeduren</span><span class="sxs-lookup"><span data-stu-id="0155f-154">Natively Compiled Stored Procedures</span></span>](https://msdn.microsoft.com/library/dn133184.aspx)|<span data-ttu-id="0155f-155">Sie können die EXECUTE-Anweisung nicht verwenden, um eine gespeicherte Prozedur über eine systemintern kompilierte gespeicherte Prozedur auszuführen.</span><span class="sxs-lookup"><span data-stu-id="0155f-155">You cannot use the EXECUTE statement to execute any stored procedure from a natively compiled stored procedure.</span></span>|<span data-ttu-id="0155f-156">Ja</span><span class="sxs-lookup"><span data-stu-id="0155f-156">Yes</span></span>|<span data-ttu-id="0155f-157">Nein <sup>1</sup></span><span class="sxs-lookup"><span data-stu-id="0155f-157">No <sup>1</sup></span></span>|  
  
 <span data-ttu-id="0155f-158"><sup>1</sup> Sie können nicht über die Kontext Verbindung (die Verbindung von, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Wenn ein CLR-Modul ausgeführt wird) auf eine Speicher optimierte Tabelle oder eine System intern kompilierte gespeicherte Prozedur zugreifen.</span><span class="sxs-lookup"><span data-stu-id="0155f-158"><sup>1</sup> You cannot access a memory-optimized table or natively compiled stored procedure from the context connection (the connection from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] when executing a CLR module).</span></span> <span data-ttu-id="0155f-159">Sie können jedoch eine andere Verbindung erstellen und öffnen, über die Sie auf speicheroptimierte Tabellen und systemintern kompilierte gespeicherte Prozeduren zugreifen können.</span><span class="sxs-lookup"><span data-stu-id="0155f-159">You can, however, create and open another connection from which you can access memory-optimized tables and natively compiled stored procedures.</span></span> <span data-ttu-id="0155f-160">Weitere Informationen finden Sie unter [reguläre und Kontext Verbindungen](../clr-integration/data-access/context-connections-vs-regular-connections.md).</span><span class="sxs-lookup"><span data-stu-id="0155f-160">For more information, see [Regular vs. Context Connections](../clr-integration/data-access/context-connections-vs-regular-connections.md).</span></span>  
  
## <a name="performance-and-scalability"></a><span data-ttu-id="0155f-161">Leistung und Skalierbarkeit</span><span class="sxs-lookup"><span data-stu-id="0155f-161">Performance and Scalability</span></span>  
 <span data-ttu-id="0155f-162">Die folgenden Faktoren beeinflussen die Leistungsvorteile, die mit In-Memory OLTP erreicht werden können:</span><span class="sxs-lookup"><span data-stu-id="0155f-162">The following factors will affect the performance gains that can be achieved with In-Memory OLTP:</span></span>  
  
 <span data-ttu-id="0155f-163">Kommunikation</span><span class="sxs-lookup"><span data-stu-id="0155f-163">Communication</span></span>  
 <span data-ttu-id="0155f-164">Eine Anwendung mit vielen Aufrufen kurzer gespeicherter Prozeduren erzielt möglicherweise einen kleineren Leistungszuwachs als eine Anwendung, bei der weniger Aufrufe und zusätzliche Funktionen in jede gespeicherte Prozedur implementiert sind.</span><span class="sxs-lookup"><span data-stu-id="0155f-164">An application with many calls to short stored procedures may see a smaller performance gain compared to an application with fewer calls and more functionality implemented in each stored procedure.</span></span>  
  
 [!INCLUDE[tsql](../../../includes/tsql-md.md)] <span data-ttu-id="0155f-165">Ausführung</span><span class="sxs-lookup"><span data-stu-id="0155f-165">Execution</span></span>  
 <span data-ttu-id="0155f-166">In-Memory OLTP gewährleistet die beste Leistung bei systemintern kompilierten gespeicherten Prozeduren im Gegensatz zu interpretierten gespeicherten Prozeduren oder Abfrageausführungen.</span><span class="sxs-lookup"><span data-stu-id="0155f-166">In-Memory OLTP achieves the best performance when using natively compiled stored procedures rather than interpreted stored procedures or query execution.</span></span> <span data-ttu-id="0155f-167">Gespeicherte Prozeduren, durch die andere gespeicherte Prozeduren ausgeführt werden, können nicht systemintern kompiliert werden. Allerdings kann der Zugriff auf speicheroptimierte Tabellen aus solchen gespeicherten Prozeduren von Nutzen sein.</span><span class="sxs-lookup"><span data-stu-id="0155f-167">Stored procedures that execute other stored procedures cannot be natively compiled, but there can be a benefit to accessing memory-optimized tables from such stored procedures.</span></span>  
  
 <span data-ttu-id="0155f-168">Bereichsscan vs. Punktsuche</span><span class="sxs-lookup"><span data-stu-id="0155f-168">Range Scan vs Point Lookup</span></span>  
 <span data-ttu-id="0155f-169">Speicheroptimierte, nicht gruppierte Indizes unterstützen Bereichsscans und sortierte Scans.</span><span class="sxs-lookup"><span data-stu-id="0155f-169">Memory-optimized nonclustered indexes support range scans and ordered scans.</span></span> <span data-ttu-id="0155f-170">Bei Punktsuchen erzielen Sie mit speicheroptimierten Hashindizes eine bessere Leistung als mit speicheroptimierten, nicht gruppierten Indizes.</span><span class="sxs-lookup"><span data-stu-id="0155f-170">For point lookups, memory-optimized hash indexes have better performance than memory-optimized nonclustered indexes.</span></span> <span data-ttu-id="0155f-171">Speicheroptimierte, nicht gruppierte Indizes weisen eine bessere Leistung auf als datenträgerbasierte Indizes.</span><span class="sxs-lookup"><span data-stu-id="0155f-171">Memory-optimized nonclustered indexes have better performance than disk-based indexes.</span></span>  
  
 <span data-ttu-id="0155f-172">Indexvorgänge werden nicht protokolliert und sie sind nur im Arbeitsspeicher vorhanden.</span><span class="sxs-lookup"><span data-stu-id="0155f-172">Index operations are not logged and they exist only in memory.</span></span>  
  
 <span data-ttu-id="0155f-173">Parallelität</span><span class="sxs-lookup"><span data-stu-id="0155f-173">Concurrency</span></span>  
 <span data-ttu-id="0155f-174">Anwendungen, deren Leistung durch Parallelität auf Engine-Ebene wie Latchkonflikte oder Blockierungen beeinträchtigt wird, verzeichnen eine erhebliche Leistungssteigerung, wenn die Anwendung auf In-Memory OLTP umgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="0155f-174">Applications whose performance is affected by engine-level concurrency, such as latch contention or blocking, improves significantly when the application moves to In-Memory OLTP.</span></span>  
  
 <span data-ttu-id="0155f-175">In der folgenden Tabelle werden die Leistungs- und Skalierbarkeitsprobleme, die häufig in relationalen Datenbanken auftreten, zusammen mit einer möglichen Leistungssteigerung durch In-Memory OLTP aufgeführt.</span><span class="sxs-lookup"><span data-stu-id="0155f-175">The following table lists the performance and scalability issues that are commonly found in relational databases and how In-Memory OLTP can improve performance.</span></span>  
  
|<span data-ttu-id="0155f-176">Problem</span><span class="sxs-lookup"><span data-stu-id="0155f-176">Issue</span></span>|<span data-ttu-id="0155f-177">Einfluss durch In-Memory OLTP</span><span class="sxs-lookup"><span data-stu-id="0155f-177">In-Memory OLTP Impact</span></span>|  
|-----------|----------------------------|  
|<span data-ttu-id="0155f-178">Leistung</span><span class="sxs-lookup"><span data-stu-id="0155f-178">Performance</span></span><br /><br /> <span data-ttu-id="0155f-179">Intensive Ressourcennutzung (CPU, E/A, Netzwerk oder Arbeitsspeicher)</span><span class="sxs-lookup"><span data-stu-id="0155f-179">High resource (CPU, I/O, network or memory) usage.</span></span>|<span data-ttu-id="0155f-180">CPU</span><span class="sxs-lookup"><span data-stu-id="0155f-180">CPU</span></span><br /> <span data-ttu-id="0155f-181">Durch systemintern kompilierte gespeicherte Prozeduren kann die CPU-Nutzung erheblich gesenkt werden, da sie deutlich weniger Anweisungen als interpretierte gespeicherte Prozeduren benötigen, um eine [!INCLUDE[tsql](../../../includes/tsql-md.md)] -Anweisung auszuführen.</span><span class="sxs-lookup"><span data-stu-id="0155f-181">Natively compiled stored procedures can lower CPU usage significantly because they require significantly fewer instructions to execute a [!INCLUDE[tsql](../../../includes/tsql-md.md)] statement compared to interpreted stored procedures.</span></span><br /><br /> <span data-ttu-id="0155f-182">In-Memory OLTP kann die erforderlichen Hardwareinvestitionen bei horizontal skalierten Arbeitsauslastungen reduzieren, da ein Server so potenziell den Durchsatz von fünf bis 10 Servern erzielen kann.</span><span class="sxs-lookup"><span data-stu-id="0155f-182">In-Memory OLTP can help reduce the hardware investment in scaled-out workloads because one server can potentially deliver the throughput of five to ten servers.</span></span><br /><br /> <span data-ttu-id="0155f-183">E/A</span><span class="sxs-lookup"><span data-stu-id="0155f-183">I/O</span></span><br /> <span data-ttu-id="0155f-184">Wenn bei der Verarbeitung ein E/A-Engpass aufgrund der Verarbeitung von Daten oder Indexseiten auftritt, lässt sich dieser durch In-Memory OLTP u. U. reduzieren.</span><span class="sxs-lookup"><span data-stu-id="0155f-184">If you encounter an I/O bottleneck from processing to data or index pages, In-Memory OLTP may reduce the bottleneck.</span></span> <span data-ttu-id="0155f-185">Zudem wird der Prüfpunktalgorithmus von In-Memory OLTP-Objekten kontinuierlich durchgeführt und führt nicht zu einem plötzlichen Anstieg von E/A-Vorgängen.</span><span class="sxs-lookup"><span data-stu-id="0155f-185">Additionally, the checkpointing of In-Memory OLTP objects is continuous and does not lead to sudden increases in I/O operations.</span></span> <span data-ttu-id="0155f-186">Wenn jedoch das Workingset der leistungskritischen Tabellen zu groß für den Arbeitsspeicher ist, steigert In-Memory OLTP nicht die Leistung, da dieser Datenbanktyp speicherresidente Daten benötigt.</span><span class="sxs-lookup"><span data-stu-id="0155f-186">However, if the working set of the performance critical tables does not fit in memory, In-Memory OLTP will not improve performance because it requires data to be memory resident.</span></span> <span data-ttu-id="0155f-187">Wenn bei der Protokollierung ein E/A-Engpass auftritt, kann In-Memory OLTP diesen Engpass verringern, da weniger Protokollierungsaktivität durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="0155f-187">If you encounter an I/O bottleneck in logging, In-Memory OLTP can reduce the bottleneck because it does less logging.</span></span> <span data-ttu-id="0155f-188">Wenn eine oder mehrere speicheroptimierte Tabellen als nicht dauerhafte Tabellen konfiguriert sind, können Sie dadurch die Protokollierung für Daten eliminieren.</span><span class="sxs-lookup"><span data-stu-id="0155f-188">If one or more memory-optimized tables are configured as non-durable tables, you can eliminate logging for data.</span></span><br /><br /> <span data-ttu-id="0155f-189">Arbeitsspeicher</span><span class="sxs-lookup"><span data-stu-id="0155f-189">Memory</span></span><br /> <span data-ttu-id="0155f-190">In-Memory OLTP bietet keine Leistungssteigerung.</span><span class="sxs-lookup"><span data-stu-id="0155f-190">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="0155f-191">In-Memory OLTP kann den Arbeitsspeicher zusätzlich belasten, da die Objekte speicherresident sein müssen.</span><span class="sxs-lookup"><span data-stu-id="0155f-191">In-Memory OLTP can put extra pressure on memory as the objects need to be memory resident.</span></span><br /><br /> <span data-ttu-id="0155f-192">Netzwerk</span><span class="sxs-lookup"><span data-stu-id="0155f-192">Network</span></span><br /> <span data-ttu-id="0155f-193">In-Memory OLTP bietet keine Leistungssteigerung.</span><span class="sxs-lookup"><span data-stu-id="0155f-193">In-Memory OLTP does not offer any performance benefit.</span></span> <span data-ttu-id="0155f-194">Die Daten müssen von der Datenebene an die Anwendungsebene übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="0155f-194">The data needs to be communicated from data tier to application tier.</span></span>|  
|<span data-ttu-id="0155f-195">Skalierbarkeit</span><span class="sxs-lookup"><span data-stu-id="0155f-195">Scalability</span></span><br /><br /> <span data-ttu-id="0155f-196">Die meisten Skalierungsprobleme bei [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] -Anwendungen werden durch Parallelitätsprobleme wie Konflikten bei Sperren, Latches und Spinlocks verursacht.</span><span class="sxs-lookup"><span data-stu-id="0155f-196">Most scaling issues in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] applications are caused by concurrency issues such as contention in locks, latches, and spinlocks.</span></span>|<span data-ttu-id="0155f-197">Latchkonflikte</span><span class="sxs-lookup"><span data-stu-id="0155f-197">Latch Contention</span></span><br /> <span data-ttu-id="0155f-198">Ein typisches Szenario ist ein Konflikt auf der letzten Seite eines Indexes, wenn Zeilen gleichzeitig in Schlüsselreihenfolge einfügt werden.</span><span class="sxs-lookup"><span data-stu-id="0155f-198">A typical scenario is contention on the last page of an index when inserting rows concurrently in key order.</span></span> <span data-ttu-id="0155f-199">Da In-Memory OLTP beim Datenzugriff keine Latches verwendet, werden Skalierbarkeitsprobleme aufgrund von Latchkonflikten vollständig eliminiert.</span><span class="sxs-lookup"><span data-stu-id="0155f-199">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to latch contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="0155f-200">Spinlock-Konflikt</span><span class="sxs-lookup"><span data-stu-id="0155f-200">Spinlock Contention</span></span><br /> <span data-ttu-id="0155f-201">Da In-Memory OLTP beim Datenzugriff keine Latches verwendet, werden Skalierbarkeitsprobleme aufgrund von Spinlock-Konflikten vollständig eliminiert.</span><span class="sxs-lookup"><span data-stu-id="0155f-201">Because In-Memory OLTP does not take latches when accessing data, the scalability issues related to spinlock contentions are fully removed.</span></span><br /><br /> <span data-ttu-id="0155f-202">Konflikte aufgrund von Sperren</span><span class="sxs-lookup"><span data-stu-id="0155f-202">Locking Related Contention</span></span><br /> <span data-ttu-id="0155f-203">Wenn in der Datenbankanwendung Blockierungen zwischen Lese- und Schreibvorgängen auftreten, werden diese Blockierungsprobleme durch In-Memory OLTP beseitigt, da es eine neue Art der optimistischen Nebenläufigkeitssteuerung für die Implementierung der Transaktionsisolationsstufen verwendet.</span><span class="sxs-lookup"><span data-stu-id="0155f-203">If your database application encounters blocking issues between read and write operations, In-Memory OLTP removes the blocking issues because it uses a new form of optimistic concurrency control to implement all transaction isolation levels.</span></span> <span data-ttu-id="0155f-204">In-Memory OLTP verwendet nicht TempDB, um Zeilenversionen zu speichern.</span><span class="sxs-lookup"><span data-stu-id="0155f-204">In-Memory OLTP does not use TempDB to store row versions.</span></span><br /><br /> <span data-ttu-id="0155f-205">Wenn das Skalierungsproblem durch einen Konflikt zwischen zwei Schreibvorgängen verursacht wird, etwa zwei Transaktionen, die gleichzeitig dieselbe Zeile zu aktualisieren versuchen, führt In-Memory OLTP eine Transaktion erfolgreich durch und beendet die andere.</span><span class="sxs-lookup"><span data-stu-id="0155f-205">If the scaling issue is caused by conflict between two write operations, such as two concurrent transactions trying to update the same row, In-Memory OLTP lets one transaction succeed and fails the other transaction.</span></span> <span data-ttu-id="0155f-206">Die fehlgeschlagene Transaktion muss zur Wiederholung explizit oder implizit erneut gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="0155f-206">The failed transaction must be re-submitted either explicitly or implicitly, re-trying the transaction.</span></span> <span data-ttu-id="0155f-207">In beiden Fällen müssen Sie Änderungen an der Anwendung vornehmen.</span><span class="sxs-lookup"><span data-stu-id="0155f-207">In either case, you need to make changes to the application.</span></span><br /><br /> <span data-ttu-id="0155f-208">Wenn in der Anwendung häufig Konflikte zwischen zwei Schreibvorgängen auftreten, wird der Wert der optimistischen Sperre verringert.</span><span class="sxs-lookup"><span data-stu-id="0155f-208">If your application experiences frequent conflicts between two write operations, the value of optimistic locking is diminished.</span></span> <span data-ttu-id="0155f-209">Die Anwendung ist für In-Memory OLTP nicht geeignet.</span><span class="sxs-lookup"><span data-stu-id="0155f-209">The application is not suitable for In-Memory OLTP.</span></span> <span data-ttu-id="0155f-210">Die meisten OLTP-Anwendungen weisen keine Schreibkonflikte auf, sofern diese nicht durch Sperrenausweitung verursacht werden.</span><span class="sxs-lookup"><span data-stu-id="0155f-210">Most OLTP applications don't have a write conflicts unless the conflict is induced by lock escalation.</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="0155f-211">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="0155f-211">See Also</span></span>  
 [<span data-ttu-id="0155f-212">In-Memory-OLTP &#40;Arbeitsspeicheroptimierung&#41;</span><span class="sxs-lookup"><span data-stu-id="0155f-212">In-Memory OLTP &#40;In-Memory Optimization&#41;</span></span>](in-memory-oltp-in-memory-optimization.md)  
  
  
