---
title: Anleitung zur Abfrageverarbeitung für speicheroptimierte Tabellen | Microsoft-Dokumentation
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: in-memory-oltp
ms.topic: conceptual
ms.assetid: 065296fe-6711-4837-965e-252ef6c13a0f
author: rothja
ms.author: jroth
ms.openlocfilehash: 93489e5dea295964826005e081bcffe889cb7586
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/04/2020
ms.locfileid: "87620874"
---
# <a name="a-guide-to-query-processing-for-memory-optimized-tables"></a><span data-ttu-id="e1184-102">Anleitung zur Abfrageverarbeitung für speicheroptimierte Tabellen</span><span class="sxs-lookup"><span data-stu-id="e1184-102">A Guide to Query Processing for Memory-Optimized Tables</span></span>
  <span data-ttu-id="e1184-103">Mit In-Memory OLTP werden speicheroptimierte Tabellen und systemintern kompilierte gespeicherte Prozeduren in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]eingeführt.</span><span class="sxs-lookup"><span data-stu-id="e1184-103">In-Memory OLTP introduces memory-optimized tables and natively compiled stored procedures in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="e1184-104">Dieser Artikel gibt eine Übersicht über die Abfrageverarbeitung für speicheroptimierte Tabellen und systemintern kompilierte gespeicherte Prozeduren.</span><span class="sxs-lookup"><span data-stu-id="e1184-104">This article gives an overview of query processing for both memory-optimized tables and natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="e1184-105">In diesem Dokument wird erläutert, wie Abfragen in speicheroptimierten Tabellen kompiliert und ausgeführt werden. Die Themen umfassen:</span><span class="sxs-lookup"><span data-stu-id="e1184-105">The document explains how queries on memory-optimized tables are compiled and executed, including:</span></span>  
  
-   <span data-ttu-id="e1184-106">Abfrageverarbeitungspipeline in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] für datenträgerbasierte Tabellen</span><span class="sxs-lookup"><span data-stu-id="e1184-106">The query processing pipeline in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for disk-based tables.</span></span>  
  
-   <span data-ttu-id="e1184-107">Abfrageoptimierung; die Rolle der Statistiken für speicheroptimierte Tabellen sowie der Richtlinien für die Problembehandlung von ungültigen Abfrageplänen</span><span class="sxs-lookup"><span data-stu-id="e1184-107">Query optimization; the role of statistics on memory-optimized tables as well as guidelines for troubleshooting bad query plans.</span></span>  
  
-   <span data-ttu-id="e1184-108">Verwendung von interpretiertem [!INCLUDE[tsql](../../../includes/tsql-md.md)] für den Zugriff auf speicheroptimierte Tabellen</span><span class="sxs-lookup"><span data-stu-id="e1184-108">The use of interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] to access memory-optimized tables.</span></span>  
  
-   <span data-ttu-id="e1184-109">Überlegungen zur Abfrageoptimierung für den Zugriff auf speicheroptimierte Tabellen</span><span class="sxs-lookup"><span data-stu-id="e1184-109">Considerations about query optimization for memory-optimized table access.</span></span>  
  
-   <span data-ttu-id="e1184-110">Kompilierung und Verarbeitung systemintern kompilierter gespeicherter Prozeduren</span><span class="sxs-lookup"><span data-stu-id="e1184-110">Natively compiled stored procedure compilation and processing.</span></span>  
  
-   <span data-ttu-id="e1184-111">Statistiken, die vom Abfrageoptimierer für die Kostenschätzung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="e1184-111">Statistics that are used for cost estimation by the optimizer.</span></span>  
  
-   <span data-ttu-id="e1184-112">Möglichkeiten zur Reparatur ungültiger Abfragepläne</span><span class="sxs-lookup"><span data-stu-id="e1184-112">Ways to fix bad query plans.</span></span>  
  
## <a name="example-query"></a><span data-ttu-id="e1184-113">Beispielabfrage</span><span class="sxs-lookup"><span data-stu-id="e1184-113">Example Query</span></span>  
 <span data-ttu-id="e1184-114">Im folgenden Beispiel werden die Abfrageverarbeitungskonzepte veranschaulicht, die in diesem Artikel erläutert werden.</span><span class="sxs-lookup"><span data-stu-id="e1184-114">The following example will be used to illustrate the query processing concepts discussed in this article.</span></span>  
  
 <span data-ttu-id="e1184-115">Wir gehen von zwei Tabellen aus: "Customer" und "Order".</span><span class="sxs-lookup"><span data-stu-id="e1184-115">We consider two tables, Customer and Order.</span></span> <span data-ttu-id="e1184-116">Das folgende [!INCLUDE[tsql](../../../includes/tsql-md.md)] -Skript enthält die Definitionen für diese beiden Tabellen und zugehörige Indizes in ihrer (herkömmlichen) datenträgerbasierten Form:</span><span class="sxs-lookup"><span data-stu-id="e1184-116">The following [!INCLUDE[tsql](../../../includes/tsql-md.md)] script contains the definitions for these two tables and associated indexes, in their (traditional) disk-based form:</span></span>  
  
```sql  
CREATE TABLE dbo.[Customer] (  
  CustomerID nchar (5) NOT NULL PRIMARY KEY,  
  ContactName nvarchar (30) NOT NULL   
)  
GO  
  
CREATE TABLE dbo.[Order] (  
  OrderID int NOT NULL PRIMARY KEY,  
  CustomerID nchar (5) NOT NULL,  
  OrderDate date NOT NULL  
)  
GO  
CREATE INDEX IX_CustomerID ON dbo.[Order](CustomerID)  
GO  
CREATE INDEX IX_OrderDate ON dbo.[Order](OrderDate)  
GO  
```  
  
 <span data-ttu-id="e1184-117">Zum Erstellen der in diesem Artikel dargestellten Abfragepläne werden die beiden Tabellen mit Beispieldaten aus der Northwind-Beispieldatenbank aufgefüllt. Diese können Sie von [Northwind and pubs Sample Databases for SQL Server 2000](https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs)(Northwind and pubs-Beispieldatenbanken für SQL Server 2000) herunterladen.</span><span class="sxs-lookup"><span data-stu-id="e1184-117">For constructing the query plans shown in this article, the two tables were populated with sample data from the Northwind sample database, which you can download from [Northwind and pubs Sample Databases for SQL Server 2000](https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs).</span></span>  
  
 <span data-ttu-id="e1184-118">Betrachten wir die folgende Abfrage, in der die Tabellen "Customer" und "Order" verknüpft sind und die die Bestell-ID und die zugehörigen Kundeninformationen zurückgibt:</span><span class="sxs-lookup"><span data-stu-id="e1184-118">Consider the following query, which joins the tables Customer and Order and returns the ID of the order and the associated customer information:</span></span>  
  
```sql  
SELECT o.OrderID, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="e1184-119">Der geschätzte Ausführungsplan wird von [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)] wie folgt angezeigt</span><span class="sxs-lookup"><span data-stu-id="e1184-119">The estimated execution plan as displayed by [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)] is as follows</span></span>  
  
 <span data-ttu-id="e1184-120">![Abfrageplan für einen Join datenträgerbasierter Tabellen.](../../database-engine/media/hekaton-query-plan-1.gif "Abfrageplan für einen Join datenträgerbasierter Tabellen.")</span><span class="sxs-lookup"><span data-stu-id="e1184-120">![Query plan for join of disk-based tables.](../../database-engine/media/hekaton-query-plan-1.gif "Query plan for join of disk-based tables.")</span></span>  
<span data-ttu-id="e1184-121">Abfrageplan für einen Join datenträgerbasierter Tabellen.</span><span class="sxs-lookup"><span data-stu-id="e1184-121">Query plan for join of disk-based tables.</span></span>  
  
 <span data-ttu-id="e1184-122">Informationen zu diesem Abfrageplan:</span><span class="sxs-lookup"><span data-stu-id="e1184-122">About this query plan:</span></span>  
  
-   <span data-ttu-id="e1184-123">Die Zeilen der Customer-Tabelle werden aus dem gruppierten Index abgerufen, der die primäre Datenstruktur darstellt und die vollständigen Tabellendaten enthält.</span><span class="sxs-lookup"><span data-stu-id="e1184-123">The rows from the Customer table are retrieved from the clustered index, which is the primary data structure and has the full table data.</span></span>  
  
-   <span data-ttu-id="e1184-124">Daten aus der Tabelle „Order“ werden mithilfe des nicht gruppierten Indexes für die CustomerID-Spalte abgerufen.</span><span class="sxs-lookup"><span data-stu-id="e1184-124">Data from the Order table is retrieved using the nonclustered index on the CustomerID column.</span></span> <span data-ttu-id="e1184-125">Dieser Index enthält die Spalte CustomerID, die für diesen Join verwendet wird, und die Primärschlüsselspalte OrderID, die an den Benutzer zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="e1184-125">This index contains both the CustomerID column, which is used for the join, and the primary key column OrderID, which is returned to the user.</span></span> <span data-ttu-id="e1184-126">Das Zurückgeben zusätzlicher Spalten aus der Order-Tabelle würde Suchen im gruppierten Index für die Order-Tabelle erfordern.</span><span class="sxs-lookup"><span data-stu-id="e1184-126">Returning additional columns from the Order table would require lookups in the clustered index for the Order table.</span></span>  
  
-   <span data-ttu-id="e1184-127">Der logische Operator `Inner Join` wird vom physischen Operator `Merge Join` implementiert.</span><span class="sxs-lookup"><span data-stu-id="e1184-127">The logical operator `Inner Join` is implemented by the physical operator `Merge Join`.</span></span> <span data-ttu-id="e1184-128">Die anderen physischen Jointypen sind `Nested Loops` und `Hash Join`.</span><span class="sxs-lookup"><span data-stu-id="e1184-128">The other physical join types are `Nested Loops` and `Hash Join`.</span></span> <span data-ttu-id="e1184-129">Der `Merge Join`-Operator nutzt die Tatsache, dass beide Indizes nach der Joinspalte CustomerID sortiert werden.</span><span class="sxs-lookup"><span data-stu-id="e1184-129">The `Merge Join` operator takes advantage of the fact that both indexes are sorted on the join column CustomerID.</span></span>  
  
 <span data-ttu-id="e1184-130">Betrachten wir eine leichte Abwandlung dieser Abfrage, die alle Zeilen aus der Order-Tabelle zurückgibt, nicht nur OrderID:</span><span class="sxs-lookup"><span data-stu-id="e1184-130">Consider a slight variation on this query, which returns all rows from the Order table, not only OrderID:</span></span>  
  
```sql  
SELECT o.*, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="e1184-131">Der geschätzte Plan für diese Abfrage ist:</span><span class="sxs-lookup"><span data-stu-id="e1184-131">The estimated plan for this query is:</span></span>  
  
 <span data-ttu-id="e1184-132">![Abfrageplan für einen Hashjoin datenträgerbasierter Tabellen.](../../database-engine/media/hekaton-query-plan-2.gif "Abfrageplan für einen Hashjoin datenträgerbasierter Tabellen.")</span><span class="sxs-lookup"><span data-stu-id="e1184-132">![Query plan for a hash join of disk-based tables.](../../database-engine/media/hekaton-query-plan-2.gif "Query plan for a hash join of disk-based tables.")</span></span>  
<span data-ttu-id="e1184-133">Abfrageplan für einen Hashjoin datenträgerbasierter Tabellen.</span><span class="sxs-lookup"><span data-stu-id="e1184-133">Query plan for a hash join of disk-based tables.</span></span>  
  
 <span data-ttu-id="e1184-134">In dieser Abfrage werden Zeilen aus der Order-Tabelle mithilfe des gruppierten Indexes abgerufen.</span><span class="sxs-lookup"><span data-stu-id="e1184-134">In this query, rows from the Order table are retrieved using the clustered index.</span></span> <span data-ttu-id="e1184-135">Der physische Operator `Hash Match` wird jetzt für `Inner Join` verwendet.</span><span class="sxs-lookup"><span data-stu-id="e1184-135">The `Hash Match` physical operator is now used for the `Inner Join`.</span></span> <span data-ttu-id="e1184-136">Der gruppierte Index für Order wird nicht nach CustomerID sortiert. Deshalb würde `Merge Join` einen Sortieroperator erfordern, der sich auf die Leistung auswirkt.</span><span class="sxs-lookup"><span data-stu-id="e1184-136">The clustered index on Order is not sorted on CustomerID, and so a `Merge Join` would require a sort operator, which would affect performance.</span></span> <span data-ttu-id="e1184-137">Beachten Sie die relativen Kosten des `Hash Match`-Operators (75%) verglichen mit den Kosten des `Merge Join`-Operators im vorherigen Beispiel (46%).</span><span class="sxs-lookup"><span data-stu-id="e1184-137">Note the relative cost of the `Hash Match` operator (75%) compared with the cost of the `Merge Join` operator in the previous example (46%).</span></span> <span data-ttu-id="e1184-138">Der Optimierer hätte den `Hash Match`-Operator auch im vorherigen Beispiel in Betracht gezogen, hat aber festgestellt, dass der `Merge Join`-Operator eine bessere Leistung bietet.</span><span class="sxs-lookup"><span data-stu-id="e1184-138">The optimizer would have considered the `Hash Match` operator also in the previous example, but concluded that the `Merge Join` operator gave better performance.</span></span>  
  
## <a name="ssnoversion-query-processing-for-disk-based-tables"></a>[!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="e1184-139">Abfrageverarbeitung für datenträgerbasierte Tabellen</span><span class="sxs-lookup"><span data-stu-id="e1184-139">Query Processing for Disk-Based Tables</span></span>  
 <span data-ttu-id="e1184-140">Das folgende Diagramm zeigt den Abfrageverarbeitungsfluss in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] für Ad-hoc-Abfragen:</span><span class="sxs-lookup"><span data-stu-id="e1184-140">The following diagram outlines the query processing flow in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for ad hoc queries:</span></span>  
  
 <span data-ttu-id="e1184-141">![Abfrageverarbeitungspipeline in SQL Server.](../../database-engine/media/hekaton-query-plan-3.gif "Abfrageverarbeitungspipeline in SQL Server.")</span><span class="sxs-lookup"><span data-stu-id="e1184-141">![SQL Server query processing pipeline.](../../database-engine/media/hekaton-query-plan-3.gif "SQL Server query processing pipeline.")</span></span>  
<span data-ttu-id="e1184-142">Abfrageverarbeitungspipeline in SQL Server.</span><span class="sxs-lookup"><span data-stu-id="e1184-142">SQL Server query processing pipeline.</span></span>  
  
 <span data-ttu-id="e1184-143">Szenario:</span><span class="sxs-lookup"><span data-stu-id="e1184-143">In this scenario:</span></span>  
  
1.  <span data-ttu-id="e1184-144">Der Benutzer gibt eine Abfrage aus.</span><span class="sxs-lookup"><span data-stu-id="e1184-144">The user issues a query.</span></span>  
  
2.  <span data-ttu-id="e1184-145">Der Parser und die Algebraisierung erstellen eine Abfragestruktur mit logischen Operatoren auf Grundlage des [!INCLUDE[tsql](../../../includes/tsql-md.md)] -Texts, der vom Benutzer bereitgestellt wurde.</span><span class="sxs-lookup"><span data-stu-id="e1184-145">The parser and algebrizer construct a query tree with logical operators based on the [!INCLUDE[tsql](../../../includes/tsql-md.md)] text submitted by the user.</span></span>  
  
3.  <span data-ttu-id="e1184-146">Der Abfrageoptimierer erstellt einen optimierten Abfrageplan, der physische Operatoren enthält (beispielsweise einen Join geschachtelter Schleifen).</span><span class="sxs-lookup"><span data-stu-id="e1184-146">The optimizer creates an optimized query plan containing physical operators (for example, nested-loops join).</span></span> <span data-ttu-id="e1184-147">Nach der Optimierung kann der Plan im Plancache gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="e1184-147">After optimization, the plan may be stored in the plan cache.</span></span> <span data-ttu-id="e1184-148">Dieser Schritt wird umgangen, wenn der Plancache bereits einen Plan für diese Abfrage enthält.</span><span class="sxs-lookup"><span data-stu-id="e1184-148">This step is bypassed if the plan cache already contains a plan for this query.</span></span>  
  
4.  <span data-ttu-id="e1184-149">Die Abfrageausführungs-Engine verarbeitet eine Interpretation des Abfrageplans.</span><span class="sxs-lookup"><span data-stu-id="e1184-149">The query execution engine processes an interpretation of the query plan.</span></span>  
  
5.  <span data-ttu-id="e1184-150">Für jeden Index Seek-, Index Scan- und Table Scan-Operator fordert die Ausführungs-Engine Zeilen aus den entsprechenden Index- und Tabellenstrukturen von Zugriffsmethoden an.</span><span class="sxs-lookup"><span data-stu-id="e1184-150">For each index seek, index scan, and table scan operator, the execution engine requests rows from the respective index and table structures from Access Methods.</span></span>  
  
6.  <span data-ttu-id="e1184-151">Über Zugriffsmethoden werden die Zeilen aus den Index- und Datenseiten im Pufferpool abgerufen und Seiten nach Bedarf vom Datenträger in den Pufferpool geladen.</span><span class="sxs-lookup"><span data-stu-id="e1184-151">Access Methods retrieves the rows from the index and data pages in the buffer pool and loads pages from disk into the buffer pool as needed.</span></span>  
  
 <span data-ttu-id="e1184-152">Für die erste Beispielabfrage fordert die Ausführungs-Engine von Zugriffsmethoden Zeilen im gruppierten Index für Customer und im nicht gruppierten Index für Order an.</span><span class="sxs-lookup"><span data-stu-id="e1184-152">For the first example query, the execution engine requests rows in the clustered index on Customer and the nonclustered index on Order from Access Methods.</span></span> <span data-ttu-id="e1184-153">Zugriffsmethoden durchläuft die B-Struktur-Indexstrukturen, um die angeforderten Zeilen abzurufen.</span><span class="sxs-lookup"><span data-stu-id="e1184-153">Access Methods traverses the B-tree index structures to retrieve the requested rows.</span></span> <span data-ttu-id="e1184-154">In diesem Fall werden alle Zeilen abgerufen, da der Plan vollständige Indexscans fordert.</span><span class="sxs-lookup"><span data-stu-id="e1184-154">In this case all rows are retrieved as the plan calls for full index scans.</span></span>  
  
## <a name="interpreted-tsql-access-to-memory-optimized-tables"></a><span data-ttu-id="e1184-155">Interpretierter [!INCLUDE[tsql](../../../includes/tsql-md.md)] -Zugriff auf speicheroptimierte Tabellen</span><span class="sxs-lookup"><span data-stu-id="e1184-155">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] Access to Memory-Optimized Tables</span></span>  
 [!INCLUDE[tsql](../../../includes/tsql-md.md)] <span data-ttu-id="e1184-156">werden auch als interpretiertes [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span><span class="sxs-lookup"><span data-stu-id="e1184-156">ad hoc batches and stored procedures are also referred to as interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="e1184-157">"Interpretiert" bezieht sich auf die Tatsache, dass der Abfrageplan von der Abfrageausführungs-Engine für jeden Operator im Abfrageplan interpretiert wird.</span><span class="sxs-lookup"><span data-stu-id="e1184-157">Interpreted refers to the fact that the query plan is interpreted by the query execution engine for each operator in the query plan.</span></span> <span data-ttu-id="e1184-158">Die Ausführungs-Engine liest den Operator und die Parameter und führt den Vorgang aus.</span><span class="sxs-lookup"><span data-stu-id="e1184-158">The execution engine reads the operator and its parameters and performs the operation.</span></span>  
  
 <span data-ttu-id="e1184-159">Interpretiertes [!INCLUDE[tsql](../../../includes/tsql-md.md)] kann verwendet werden, um auf speicheroptimierte und datenträgerbasierte Tabellen zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="e1184-159">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] can be used to access both memory-optimized and disk-based tables.</span></span> <span data-ttu-id="e1184-160">Die folgende Abbildung veranschaulicht die Abfrageverarbeitung für den interpretierten [!INCLUDE[tsql](../../../includes/tsql-md.md)] -Zugriff auf speicheroptimierte Tabellen:</span><span class="sxs-lookup"><span data-stu-id="e1184-160">The following figure illustrates query processing for interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access to memory-optimized tables:</span></span>  
  
 <span data-ttu-id="e1184-161">![Abfrageverarbeitungspipeline für interpretierte Transact-SQL.](../../database-engine/media/hekaton-query-plan-4.gif "Abfrageverarbeitungspipeline für interpretierte Transact-SQL.")</span><span class="sxs-lookup"><span data-stu-id="e1184-161">![Query processing pipeline for interpreted tsql.](../../database-engine/media/hekaton-query-plan-4.gif "Query processing pipeline for interpreted tsql.")</span></span>  
<span data-ttu-id="e1184-162">Abfrageverarbeitungspipeline für interpretierten Transact-SQL-Zugriff auf speicheroptimierte Tabellen.</span><span class="sxs-lookup"><span data-stu-id="e1184-162">Query processing pipeline for interpreted Transact-SQL access to memory-optimized tables.</span></span>  
  
 <span data-ttu-id="e1184-163">Wie in der Abbildung veranschaulicht, bleibt die Abfrageverarbeitungspipeline größtenteils unverändert:</span><span class="sxs-lookup"><span data-stu-id="e1184-163">As illustrated by the figure, the query processing pipeline remains mostly unchanged:</span></span>  
  
-   <span data-ttu-id="e1184-164">Der Parser und die Algebraisierung erstellen die Abfragestruktur.</span><span class="sxs-lookup"><span data-stu-id="e1184-164">The parser and algebrizer construct the query tree.</span></span>  
  
-   <span data-ttu-id="e1184-165">Der Abfrageoptimierer erstellt den Ausführungsplan.</span><span class="sxs-lookup"><span data-stu-id="e1184-165">The optimizer creates the execution plan.</span></span>  
  
-   <span data-ttu-id="e1184-166">Die Abfrageausführungs-Engine interpretiert den Ausführungsplan.</span><span class="sxs-lookup"><span data-stu-id="e1184-166">The query execution engine interprets the execution plan.</span></span>  
  
 <span data-ttu-id="e1184-167">Der Hauptunterschied zur herkömmlichen Abfrageverarbeitungspipeline (Abbildung 2) ist, dass Zeilen für speicheroptimierte Tabellen nicht über Zugriffsmethoden aus dem Pufferpool abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="e1184-167">The main difference with the traditional query processing pipeline (figure 2) is that rows for memory-optimized tables are not retrieved from the buffer pool using Access Methods.</span></span> <span data-ttu-id="e1184-168">Stattdessen werden Zeilen mit der In-Memory-OLTP-Engine aus den speicherresidenten Datenstrukturen abgerufen.</span><span class="sxs-lookup"><span data-stu-id="e1184-168">Instead, rows are retrieved from the in-memory data structures through the In-Memory OLTP engine.</span></span> <span data-ttu-id="e1184-169">Aufgrund der Unterschiede in den Datenstrukturen wählt der Abfrageoptimierer in manchen Fällen verschiedene Pläne aus, wie im folgenden Beispiel veranschaulicht wird.</span><span class="sxs-lookup"><span data-stu-id="e1184-169">Differences in data structures cause the optimizer to pick different plans in some cases, as illustrated by the following example.</span></span>  
  
 <span data-ttu-id="e1184-170">Das folgende [!INCLUDE[tsql](../../../includes/tsql-md.md)] -Skript enthält speicheroptimierte Versionen der Order- und Customer-Tabellen, wobei Hashindizes verwendet werden:</span><span class="sxs-lookup"><span data-stu-id="e1184-170">The following [!INCLUDE[tsql](../../../includes/tsql-md.md)] script contains memory-optimized versions of the Order and Customer tables, using hash indexes:</span></span>  
  
```sql  
CREATE TABLE dbo.[Customer] (  
  CustomerID nchar (5) NOT NULL PRIMARY KEY NONCLUSTERED,  
  ContactName nvarchar (30) NOT NULL   
) WITH (MEMORY_OPTIMIZED=ON)  
GO  
  
CREATE TABLE dbo.[Order] (  
  OrderID int NOT NULL PRIMARY KEY NONCLUSTERED,  
  CustomerID nchar (5) NOT NULL INDEX IX_CustomerID HASH(CustomerID) WITH (BUCKET_COUNT=100000),  
  OrderDate date NOT NULL INDEX IX_OrderDate HASH(OrderDate) WITH (BUCKET_COUNT=100000)  
) WITH (MEMORY_OPTIMIZED=ON)  
GO  
```  
  
 <span data-ttu-id="e1184-171">Betrachten wir die gleiche Abfrage bei der Ausführung mit speicheroptimierten Tabellen:</span><span class="sxs-lookup"><span data-stu-id="e1184-171">Consider the same query executed on memory-optimized tables:</span></span>  
  
```sql  
SELECT o.OrderID, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="e1184-172">Der geschätzte Plan lautet wie folgt:</span><span class="sxs-lookup"><span data-stu-id="e1184-172">The estimated plan is as follows:</span></span>  
  
 <span data-ttu-id="e1184-173">![Abfrageplan für den Join speicheroptimierter Tabellen.](../../database-engine/media/hekaton-query-plan-5.gif "Abfrageplan für den Join arbeitsspeicheroptimierter Tabellen.")</span><span class="sxs-lookup"><span data-stu-id="e1184-173">![Query plan for join of memory optimized tables.](../../database-engine/media/hekaton-query-plan-5.gif "Query plan for join of memory optimized tables.")</span></span>  
<span data-ttu-id="e1184-174">Abfrageplan für den Join speicheroptimierter Tabellen.</span><span class="sxs-lookup"><span data-stu-id="e1184-174">Query plan for join of memory-optimized tables.</span></span>  
  
 <span data-ttu-id="e1184-175">Beachten Sie die folgenden Unterschiede beim Plan für die gleiche Abfrage mit datenträgerbasierten Tabellen (Abbildung 1):</span><span class="sxs-lookup"><span data-stu-id="e1184-175">Observe the following differences with the plan for the same query on disk-based tables (figure 1):</span></span>  
  
-   <span data-ttu-id="e1184-176">Dieser Plan enthält einen Tabellenscan statt eines Scans des gruppierten Indexes für die Customer-Tabelle:</span><span class="sxs-lookup"><span data-stu-id="e1184-176">This plan contains a table scan rather than a clustered index scan for the table Customer:</span></span>  
  
    -   <span data-ttu-id="e1184-177">Die Definition der Tabelle enthält keinen gruppierten Index.</span><span class="sxs-lookup"><span data-stu-id="e1184-177">The definition of the table does not contain a clustered index.</span></span>  
  
    -   <span data-ttu-id="e1184-178">Gruppierte Indizes werden nicht bei speicheroptimierten Tabellen unterstützt.</span><span class="sxs-lookup"><span data-stu-id="e1184-178">Clustered indexes are not supported with memory-optimized tables.</span></span> <span data-ttu-id="e1184-179">Stattdessen muss jede speicheroptimierte Tabelle mindestens über einen nicht gruppierten Index verfügen, und alle Indizes für speicheroptimierte Tabellen können effizient auf alle Spalten in der Tabelle zugreifen, ohne dass sie im Index gespeichert werden müssen oder dass auf einen gruppierten Index zurückgegriffen werden muss.</span><span class="sxs-lookup"><span data-stu-id="e1184-179">Instead, every memory-optimized table must have at least one nonclustered index and all indexes on memory-optimized tables can efficiently access all columns in the table without having to store them in the index or refer to a clustered index.</span></span>  
  
-   <span data-ttu-id="e1184-180">Dieser Plan enthält ein `Hash Match` anstelle eines `Merge Join`.</span><span class="sxs-lookup"><span data-stu-id="e1184-180">This plan contains a `Hash Match` rather than a `Merge Join`.</span></span> <span data-ttu-id="e1184-181">Die Indizes der Order- und Customer-Tabelle sind Hashindizes und werden daher nicht sortiert.</span><span class="sxs-lookup"><span data-stu-id="e1184-181">The indexes on both the Order and the Customer table are hash indexes, and are thus not ordered.</span></span> <span data-ttu-id="e1184-182">Ein `Merge Join` würde Sortieroperatoren erfordern, die die Leistung verringern würden.</span><span class="sxs-lookup"><span data-stu-id="e1184-182">A `Merge Join` would require sort operators that would decrease performance.</span></span>  
  
## <a name="natively-compiled-stored-procedures"></a><span data-ttu-id="e1184-183">Systemintern kompilierte gespeicherte Prozeduren</span><span class="sxs-lookup"><span data-stu-id="e1184-183">Natively Compiled Stored Procedures</span></span>  
 <span data-ttu-id="e1184-184">Systemintern kompilierte gespeicherte Prozeduren sind gespeicherte [!INCLUDE[tsql](../../../includes/tsql-md.md)] -Prozeduren, die in Computercode kompiliert werden, statt durch die Abfrageausführungs-Engine interpretiert zu werden.</span><span class="sxs-lookup"><span data-stu-id="e1184-184">Natively compiled stored procedures are [!INCLUDE[tsql](../../../includes/tsql-md.md)] stored procedures compiled to machine code, rather than interpreted by the query execution engine.</span></span> <span data-ttu-id="e1184-185">Das folgende Skript erstellt eine systemintern kompilierte gespeicherte Prozedur, die die Beispielabfrage ausführt (aus dem Abschnitt Beispielabfrage).</span><span class="sxs-lookup"><span data-stu-id="e1184-185">The following script creates a natively compiled stored procedure that runs the example query (from the Example Query section).</span></span>  
  
```sql  
CREATE PROCEDURE usp_SampleJoin  
WITH NATIVE_COMPILATION, SCHEMABINDING, EXECUTE AS OWNER  
AS BEGIN ATOMIC WITH   
(  TRANSACTION ISOLATION LEVEL = SNAPSHOT,  
  LANGUAGE = 'english')  
  
  SELECT o.OrderID, c.CustomerID, c.ContactName   
FROM dbo.[Order] o INNER JOIN dbo.[Customer] c   
  ON c.CustomerID = o.CustomerID  
  
END  
```  
  
 <span data-ttu-id="e1184-186">Systemintern kompilierte gespeicherte Prozeduren werden zur Erstellungszeit kompiliert, während interpretierte gespeicherte Prozeduren bei der ersten Ausführung kompiliert werden.</span><span class="sxs-lookup"><span data-stu-id="e1184-186">Natively compiled stored procedures are compiled at create time, whereas interpreted stored procedures are compiled at first execution time.</span></span> <span data-ttu-id="e1184-187">(Ein Teil der Kompilierung, insbesondere die Analyse und die Algebraisierung, erfolgt während der Erstellung.</span><span class="sxs-lookup"><span data-stu-id="e1184-187">(A portion of the compilation, particularly parsing and algebrization, take place at create.</span></span> <span data-ttu-id="e1184-188">Für interpretierte gespeicherte Prozeduren findet die Optimierung der Abfragepläne bei der ersten Ausführung statt.) Die Neukompilierungslogik ist ähnlich.</span><span class="sxs-lookup"><span data-stu-id="e1184-188">However, for interpreted stored procedures, optimization of the query plans takes place at first execution.) The recompilation logic is similar.</span></span> <span data-ttu-id="e1184-189">Systemintern kompilierte gespeicherte Prozeduren werden bei der ersten Ausführung der Prozedur erneut kompiliert, wenn der Server neu gestartet wird.</span><span class="sxs-lookup"><span data-stu-id="e1184-189">Natively compiled stored procedures are recompiled on first execution of the procedure if the server is restarted.</span></span> <span data-ttu-id="e1184-190">Interpretierte gespeicherte Prozeduren werden erneut kompiliert, wenn sich der Plan nicht mehr im Plancache befindet.</span><span class="sxs-lookup"><span data-stu-id="e1184-190">Interpreted stored procedures are recompiled if the plan is no longer in the plan cache.</span></span> <span data-ttu-id="e1184-191">In der folgenden Tabelle wird zusammengefasst, wann kompilierte und interpretierte gespeicherte Prozeduren kompiliert bzw. erneut kompiliert werden:</span><span class="sxs-lookup"><span data-stu-id="e1184-191">The following table summarizes compilation and recompilation cases for both natively compiled and interpreted stored procedures:</span></span>  
  
||<span data-ttu-id="e1184-192">Systemintern kompiliert</span><span class="sxs-lookup"><span data-stu-id="e1184-192">Natively compiled</span></span>|<span data-ttu-id="e1184-193">Interpretierter</span><span class="sxs-lookup"><span data-stu-id="e1184-193">Interpreted</span></span>|  
|-|-----------------------|-----------------|  
|<span data-ttu-id="e1184-194">Ursprüngliche Kompilierung</span><span class="sxs-lookup"><span data-stu-id="e1184-194">Initial compilation</span></span>|<span data-ttu-id="e1184-195">Bei der Erstellung</span><span class="sxs-lookup"><span data-stu-id="e1184-195">At create time.</span></span>|<span data-ttu-id="e1184-196">Bei der ersten Ausführung</span><span class="sxs-lookup"><span data-stu-id="e1184-196">At first execution.</span></span>|  
|<span data-ttu-id="e1184-197">Automatische Neukompilierung</span><span class="sxs-lookup"><span data-stu-id="e1184-197">Automatic recompilation</span></span>|<span data-ttu-id="e1184-198">Bei der ersten Ausführung der Prozedur nach einem Datenbank- oder Serverneustart.</span><span class="sxs-lookup"><span data-stu-id="e1184-198">Upon first execution of the procedure after a database or server restart.</span></span>|<span data-ttu-id="e1184-199">Beim Serverneustart.</span><span class="sxs-lookup"><span data-stu-id="e1184-199">On server restart.</span></span> <span data-ttu-id="e1184-200">Oder Entfernung aus dem Plancache, normalerweise aufgrund von Schema- oder Statusänderungen oder wegen Arbeitsspeichermangels.</span><span class="sxs-lookup"><span data-stu-id="e1184-200">Or, eviction from the plan cache, usually based on schema or stats changes, or memory pressure.</span></span>|  
|<span data-ttu-id="e1184-201">Manuelle Neukompilierung</span><span class="sxs-lookup"><span data-stu-id="e1184-201">Manual recompilation</span></span>|<span data-ttu-id="e1184-202">Wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="e1184-202">Not supported.</span></span> <span data-ttu-id="e1184-203">Das Problem kann umgangen werden, indem die gespeicherte Prozedur gelöscht und neu erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="e1184-203">The workaround is to drop and recreate the stored procedure.</span></span>|<span data-ttu-id="e1184-204">Verwenden Sie `sp_recompile`.</span><span class="sxs-lookup"><span data-stu-id="e1184-204">Use `sp_recompile`.</span></span> <span data-ttu-id="e1184-205">Sie können den Plan manuell aus dem Cache entfernen, beispielsweise durch DBCC FREEPROCCACHE.</span><span class="sxs-lookup"><span data-stu-id="e1184-205">You can manually evict the plan from the cache, for example through DBCC FREEPROCCACHE.</span></span> <span data-ttu-id="e1184-206">Sie können auch die gespeicherte Prozedur WITH RECOMPILE erstellen. Diese gespeicherte Prozedur wird bei jeder Ausführung erneut kompiliert.</span><span class="sxs-lookup"><span data-stu-id="e1184-206">You can also create the stored procedure WITH RECOMPILE and the stored procedure will be recompiled at every execution.</span></span>|  
  
### <a name="compilation-and-query-processing"></a><span data-ttu-id="e1184-207">Kompilierung und Abfrageverarbeitung</span><span class="sxs-lookup"><span data-stu-id="e1184-207">Compilation and Query Processing</span></span>  
 <span data-ttu-id="e1184-208">Das folgende Diagramm veranschaulicht den Kompilierungsprozess systemintern kompilierte gespeicherte Prozeduren:</span><span class="sxs-lookup"><span data-stu-id="e1184-208">The following diagram illustrates the compilation process for natively compiled stored procedures:</span></span>  
  
 <span data-ttu-id="e1184-209">![Systeminterne Kompilierung gespeicherter Prozeduren.](../../database-engine/media/hekaton-query-plan-6.gif "Systeminterne Kompilierung gespeicherter Prozeduren.")</span><span class="sxs-lookup"><span data-stu-id="e1184-209">![Native compilation of stored procedures.](../../database-engine/media/hekaton-query-plan-6.gif "Native compilation of stored procedures.")</span></span>  
<span data-ttu-id="e1184-210">Systeminterne Kompilierung gespeicherter Prozeduren.</span><span class="sxs-lookup"><span data-stu-id="e1184-210">Native compilation of stored procedures.</span></span>  
  
 <span data-ttu-id="e1184-211">Der Prozess lässt sich folgendermaßen beschreiben:</span><span class="sxs-lookup"><span data-stu-id="e1184-211">The process is described as,</span></span>  
  
1.  <span data-ttu-id="e1184-212">Der Benutzer gibt eine `CREATE PROCEDURE`-Anweisung an [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] aus.</span><span class="sxs-lookup"><span data-stu-id="e1184-212">The user issues a `CREATE PROCEDURE` statement to [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span>  
  
2.  <span data-ttu-id="e1184-213">Der Parser und die Algebraisierung erstellen den Verarbeitungsfluss für die Prozedur sowie die Abfragestrukturen für die [!INCLUDE[tsql](../../../includes/tsql-md.md)] -Abfragen in der gespeicherten Prozedur.</span><span class="sxs-lookup"><span data-stu-id="e1184-213">The parser and algebrizer create the processing flow for the procedure, as well as query trees for the [!INCLUDE[tsql](../../../includes/tsql-md.md)] queries in the stored procedure.</span></span>  
  
3.  <span data-ttu-id="e1184-214">Der Abfrageoptimierer erstellt optimierte Abfrageausführungspläne für alle Abfragen in der gespeicherten Prozedur.</span><span class="sxs-lookup"><span data-stu-id="e1184-214">The optimizer creates optimized query execution plans for all the queries in the stored procedure.</span></span>  
  
4.  <span data-ttu-id="e1184-215">Der In-Memory OLTP-Compiler nimmt den Verarbeitungsfluss mit eingebetteten optimierten Abfrageplänen auf und generiert eine DLL, die den Computercode für die Ausführung der gespeicherten Prozedur enthält.</span><span class="sxs-lookup"><span data-stu-id="e1184-215">The In-Memory OLTP compiler takes the processing flow with the embedded optimized query plans and generates a DLL that contains the machine code for executing the stored procedure.</span></span>  
  
5.  <span data-ttu-id="e1184-216">Die generierte DLL wird in den Arbeitsspeicher geladen.</span><span class="sxs-lookup"><span data-stu-id="e1184-216">The generated DLL is loaded into memory.</span></span>  
  
 <span data-ttu-id="e1184-217">Der Aufruf einer systemintern kompilierten gespeicherten Prozedur wird in einen Funktionsaufruf in der DLL übersetzt.</span><span class="sxs-lookup"><span data-stu-id="e1184-217">Invocation of a natively compiled stored procedure translates to calling a function in the DLL.</span></span>  
  
 <span data-ttu-id="e1184-218">![Ausführung systemintern kompilierter gespeicherten Prozeduren.](../../database-engine/media/hekaton-query-plan-7.gif "Ausführung systemintern kompilierter gespeicherten Prozeduren.")</span><span class="sxs-lookup"><span data-stu-id="e1184-218">![Execution of natively compiled stored procedures.](../../database-engine/media/hekaton-query-plan-7.gif "Execution of natively compiled stored procedures.")</span></span>  
<span data-ttu-id="e1184-219">Ausführung systemintern kompilierter gespeicherten Prozeduren.</span><span class="sxs-lookup"><span data-stu-id="e1184-219">Execution of natively compiled stored procedures.</span></span>  
  
 <span data-ttu-id="e1184-220">Der Aufruf einer systemintern kompilierten gespeicherten Prozedur lässt sich folgendermaßen beschreiben:</span><span class="sxs-lookup"><span data-stu-id="e1184-220">Invocation of a natively compiled stored procedure is described as follows:</span></span>  
  
1.  <span data-ttu-id="e1184-221">Der Benutzer gibt eine `EXEC` *usp_myproc* Anweisung aus.</span><span class="sxs-lookup"><span data-stu-id="e1184-221">The user issues an `EXEC`*usp_myproc* statement.</span></span>  
  
2.  <span data-ttu-id="e1184-222">Der Parser extrahiert den Namen und die Parameter der gespeicherten Prozedur.</span><span class="sxs-lookup"><span data-stu-id="e1184-222">The parser extracts the name and stored procedure parameters.</span></span>  
  
     <span data-ttu-id="e1184-223">Wenn die Anweisung vorbereitet wurde, beispielsweise mit `sp_prep_exec`, muss der Parser den Prozedurnamen und die Parameter nicht zur Ausführungszeit extrahieren.</span><span class="sxs-lookup"><span data-stu-id="e1184-223">If the statement was prepared, for example using `sp_prep_exec`, the parser does not need to extract the procedure name and parameters at execution time.</span></span>  
  
3.  <span data-ttu-id="e1184-224">Die In-Memory OLTP-Laufzeit sucht den DLL-Einstiegspunkt für die gespeicherte Prozedur.</span><span class="sxs-lookup"><span data-stu-id="e1184-224">The In-Memory OLTP runtime locates the DLL entry point for the stored procedure.</span></span>  
  
4.  <span data-ttu-id="e1184-225">Der Computercode in der DLL wird ausgeführt, und die Ergebnisse werden an den Client zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="e1184-225">The machine code in the DLL is executed and the results of are returned to the client.</span></span>  
  
 <span data-ttu-id="e1184-226">**Parameterermittlung**</span><span class="sxs-lookup"><span data-stu-id="e1184-226">**Parameter sniffing**</span></span>  
  
 <span data-ttu-id="e1184-227">Interpretierte gespeicherte [!INCLUDE[tsql](../../../includes/tsql-md.md)] -Prozeduren werden im Gegensatz zu systemintern kompilierten gespeicherten Prozeduren, die zur Erstellungszeit kompiliert werden, bei der ersten Ausführung kompiliert.</span><span class="sxs-lookup"><span data-stu-id="e1184-227">Interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] stored procedures are compiled at first execution, in contrast to natively compiled stored procedures, which are compiled at create time.</span></span> <span data-ttu-id="e1184-228">Wenn interpretierte gespeicherte Prozeduren beim Aufruf kompiliert werden, werden die Werte der Parameter, die für diesen Aufruf angegeben werden, bei der Erstellung des Ausführungsplans vom Abfrageoptimierer verwendet.</span><span class="sxs-lookup"><span data-stu-id="e1184-228">When interpreted stored procedures are compiled at invocation, the values of the parameters supplied for this invocation are used by the optimizer when generating the execution plan.</span></span> <span data-ttu-id="e1184-229">Diese Verwendung von Parametern während der Kompilierung wird als Parameterermittlung bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="e1184-229">This use of parameters during compilation is called parameter sniffing.</span></span>  
  
 <span data-ttu-id="e1184-230">Die Parameterermittlung wird nicht zum Kompilieren von systemintern kompilierten gespeicherten Prozeduren verwendet.</span><span class="sxs-lookup"><span data-stu-id="e1184-230">Parameter sniffing is not used for compiling natively compiled stored procedures.</span></span> <span data-ttu-id="e1184-231">Es wird angenommen, dass alle Parameter für die gespeicherte Prozedur UNBEKANNTE Werte haben.</span><span class="sxs-lookup"><span data-stu-id="e1184-231">All parameters to the stored procedure are considered to have UNKNOWN values.</span></span> <span data-ttu-id="e1184-232">Systemintern kompilierte gespeicherte Prozeduren unterstützen genauso wie interpretierte gespeicherte Prozeduren den `OPTIMIZE FOR`-Hinweis.</span><span class="sxs-lookup"><span data-stu-id="e1184-232">Like interpreted stored procedures, natively compiled stored procedures also support the `OPTIMIZE FOR` hint.</span></span> <span data-ttu-id="e1184-233">Weitere Informationen finden Sie unter [Abfragehinweise &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-query).</span><span class="sxs-lookup"><span data-stu-id="e1184-233">For more information, see [Query Hints &#40;Transact-SQL&#41;](/sql/t-sql/queries/hints-transact-sql-query).</span></span>  
  
### <a name="retrieving-a-query-execution-plan-for-natively-compiled-stored-procedures"></a><span data-ttu-id="e1184-234">Abrufen eines Abfrageausführungsplans für systemintern kompilierte gespeicherte Prozeduren</span><span class="sxs-lookup"><span data-stu-id="e1184-234">Retrieving a Query Execution Plan for Natively Compiled Stored Procedures</span></span>  
 <span data-ttu-id="e1184-235">Der Abfrageausführungsplan für eine nativ kompilierte gespeicherte Prozedur kann mithilfe des **geschätzten Ausführungsplans** in [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)]oder mithilfe der Option SHOWPLAN_XML in [!INCLUDE[tsql](../../../includes/tsql-md.md)]abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="e1184-235">The query execution plan for a natively compiled stored procedure can be retrieved using **Estimated Execution Plan** in [!INCLUDE[ssManStudio](../../includes/ssmanstudio-md.md)], or using the SHOWPLAN_XML option in [!INCLUDE[tsql](../../../includes/tsql-md.md)].</span></span> <span data-ttu-id="e1184-236">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="e1184-236">For example:</span></span>  
  
```sql  
SET SHOWPLAN_XML ON  
GO  
EXEC dbo.usp_myproc  
GO  
SET SHOWPLAN_XML OFF  
GO  
```  
  
 <span data-ttu-id="e1184-237">Der Ausführungsplan, der vom Abfrageoptimierer erstellt wird, besteht aus einer Struktur mit Abfrageoperatoren für die Knoten und Blätter der Struktur.</span><span class="sxs-lookup"><span data-stu-id="e1184-237">The execution plan generated by the query optimizer consists of a tree with query operators on the nodes and leaves of the tree.</span></span> <span data-ttu-id="e1184-238">Der Aufbau der Struktur bestimmt die Interaktion (den Fluss von Zeilen von einem Operator zu anderen) zwischen Operatoren.</span><span class="sxs-lookup"><span data-stu-id="e1184-238">The structure of the tree determines the interaction (the flow of rows from one operator to another) between the operators.</span></span> <span data-ttu-id="e1184-239">In der grafischen Darstellung von [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)]verläuft der Fluss von rechts nach links.</span><span class="sxs-lookup"><span data-stu-id="e1184-239">In the graphical view of [!INCLUDE[ssManStudioFull](../../../includes/ssmanstudiofull-md.md)], the flow is from right to left.</span></span> <span data-ttu-id="e1184-240">Beispielsweise enthält der Abfrageplan in Abbildung 1 zwei Index Scan-Operatoren, die Zeilen für einen Merge Join-Operator ausgeben.</span><span class="sxs-lookup"><span data-stu-id="e1184-240">For example, the query plan in figure 1 contains two index scan operators, which supplies rows to a merge join operator.</span></span> <span data-ttu-id="e1184-241">Der Merge Join-Operator stellt Zeilen für den Select-Operator bereit.</span><span class="sxs-lookup"><span data-stu-id="e1184-241">The merge join operator supplies rows to a select operator.</span></span> <span data-ttu-id="e1184-242">Der Select-Operator gibt schließlich die Zeilen an den Client zurück.</span><span class="sxs-lookup"><span data-stu-id="e1184-242">The select operator, finally, returns the rows to the client.</span></span>  
  
### <a name="query-operators-in-natively-compiled-stored-procedures"></a><span data-ttu-id="e1184-243">Abfrageoperatoren in systemintern kompilierten gespeicherten Prozeduren</span><span class="sxs-lookup"><span data-stu-id="e1184-243">Query Operators in Natively Compiled Stored Procedures</span></span>  
 <span data-ttu-id="e1184-244">In der folgenden Tabelle werden die unterstützten Abfrageoperatoren in systemintern kompilierten gespeicherten Prozeduren zusammengefasst:</span><span class="sxs-lookup"><span data-stu-id="e1184-244">The following table summarizes the query operators supported inside natively compiled stored procedures:</span></span>  
  
|<span data-ttu-id="e1184-245">Operator</span><span class="sxs-lookup"><span data-stu-id="e1184-245">Operator</span></span>|<span data-ttu-id="e1184-246">Beispielabfrage</span><span class="sxs-lookup"><span data-stu-id="e1184-246">Sample query</span></span>|  
|--------------|------------------|  
|<span data-ttu-id="e1184-247">SELECT</span><span class="sxs-lookup"><span data-stu-id="e1184-247">SELECT</span></span>|`SELECT OrderID FROM dbo.[Order]`|  
|<span data-ttu-id="e1184-248">INSERT</span><span class="sxs-lookup"><span data-stu-id="e1184-248">INSERT</span></span>|`INSERT dbo.Customer VALUES ('abc', 'def')`|  
|<span data-ttu-id="e1184-249">UPDATE</span><span class="sxs-lookup"><span data-stu-id="e1184-249">UPDATE</span></span>|`UPDATE dbo.Customer SET ContactName='ghi' WHERE CustomerID='abc'`|  
|<span data-ttu-id="e1184-250">Delete</span><span class="sxs-lookup"><span data-stu-id="e1184-250">DELETE</span></span>|`DELETE dbo.Customer WHERE CustomerID='abc'`|  
|<span data-ttu-id="e1184-251">Compute Scalar</span><span class="sxs-lookup"><span data-stu-id="e1184-251">Compute Scalar</span></span>|<span data-ttu-id="e1184-252">Dieser Operator wird für systeminterne Funktionen und Typkonvertierungen verwendet.</span><span class="sxs-lookup"><span data-stu-id="e1184-252">This operator is used both for intrinsic functions and type conversions.</span></span> <span data-ttu-id="e1184-253">Nicht alle Funktionen und Typkonvertierungen werden in systemintern kompilierten gespeicherten Prozeduren unterstützt.</span><span class="sxs-lookup"><span data-stu-id="e1184-253">Not all functions and type conversions are supported inside natively compiled stored procedures.</span></span><br /><br /> `SELECT OrderID+1 FROM dbo.[Order]`|  
|<span data-ttu-id="e1184-254">Join geschachtelter Schleifen</span><span class="sxs-lookup"><span data-stu-id="e1184-254">Nested Loops Join</span></span>|<span data-ttu-id="e1184-255">Der Operator für geschachtelte Schleifen ist der einzige Joinoperator, der in systemintern kompilierten gespeicherten Prozeduren unterstützt wird.</span><span class="sxs-lookup"><span data-stu-id="e1184-255">Nested Loops is the only join operator supported in natively compiled stored procedures.</span></span> <span data-ttu-id="e1184-256">Alle Pläne, die Joins enthalten, verwenden den Operator für geschachtelte Schleifen, selbst wenn der Plan für die gleiche Abfrage in interpretiertem [!INCLUDE[tsql](../../../includes/tsql-md.md)] einen Hashjoin oder einen Zusammenführungsjoin enthält.</span><span class="sxs-lookup"><span data-stu-id="e1184-256">All plans that contain joins will use the Nested Loops operator, even if the plan for same query executed as interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] contains a hash or merge join.</span></span><br /><br /> `SELECT o.OrderID, c.CustomerID`  <br /> `FROM dbo.[Order] o INNER JOIN dbo.[Customer] c`|  
|<span data-ttu-id="e1184-257">Sortieren</span><span class="sxs-lookup"><span data-stu-id="e1184-257">Sort</span></span>|`SELECT ContactName FROM dbo.Customer`  <br /> `ORDER BY ContactName`|  
|<span data-ttu-id="e1184-258">TOP</span><span class="sxs-lookup"><span data-stu-id="e1184-258">Top</span></span>|`SELECT TOP 10 ContactName FROM dbo.Customer`|  
|<span data-ttu-id="e1184-259">Top-sort</span><span class="sxs-lookup"><span data-stu-id="e1184-259">Top-sort</span></span>|<span data-ttu-id="e1184-260">Der `TOP`-Ausdruck (die Anzahl der zurückzugebenden Zeilen) darf 8.000 Zeilen nicht überschreiten.</span><span class="sxs-lookup"><span data-stu-id="e1184-260">The `TOP` expression (the number of rows to be returned) cannot exceed 8,000 rows.</span></span> <span data-ttu-id="e1184-261">Weniger, wenn die Abfrage auch Join- und Aggregationsoperatoren enthält.</span><span class="sxs-lookup"><span data-stu-id="e1184-261">Fewer if there are also join and aggregation operators in the query.</span></span> <span data-ttu-id="e1184-262">Joins und Aggregationen reduzieren normalerweise die Anzahl der zu sortierenden Zeilen im Vergleich zur Zeilenanzahl der Basistabellen.</span><span class="sxs-lookup"><span data-stu-id="e1184-262">Joins and aggregation do typically reduce the number of rows to be sorted, compared with the row count of the base tables.</span></span><br /><br /> `SELECT TOP 10 ContactName FROM dbo.Customer`  <br /> `ORDER BY ContactName`|  
|<span data-ttu-id="e1184-263">Stream Aggregate</span><span class="sxs-lookup"><span data-stu-id="e1184-263">Stream Aggregate</span></span>|<span data-ttu-id="e1184-264">Beachten Sie, dass der Hash Match-Operator keine Aggregationen unterstützt.</span><span class="sxs-lookup"><span data-stu-id="e1184-264">Note that the Hash Match operator is not supported for aggregation.</span></span> <span data-ttu-id="e1184-265">Daher verwenden alle Aggregationen in den systemintern kompilierten gespeicherten Prozeduren den Stream Aggregate-Operator, selbst wenn der Plan für die gleiche Abfrage in interpretiertem [!INCLUDE[tsql](../../../includes/tsql-md.md)] den Hash Match-Operator verwendet.</span><span class="sxs-lookup"><span data-stu-id="e1184-265">Therefore, all aggregation in natively compiled stored procedures uses the Stream Aggregate operator, even if the plan for the same query in interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] uses the Hash Match operator.</span></span><br /><br /> `SELECT count(CustomerID) FROM dbo.Customer`|  
  
## <a name="column-statistics-and-joins"></a><span data-ttu-id="e1184-266">Spaltenstatistiken und Joins</span><span class="sxs-lookup"><span data-stu-id="e1184-266">Column Statistics and Joins</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="e1184-267">werden Statistiken für Werte in den Indexschlüsselspalten beibehalten, damit die Kosten für bestimmte Vorgänge wie Indexscans und Indexsuchen geschätzt werden können.</span><span class="sxs-lookup"><span data-stu-id="e1184-267">maintains statistics on values in index key columns to help estimate the cost of certain operations, such as index scan and index seeks.</span></span> <span data-ttu-id="e1184-268">(Von [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] werden auch Statistiken zu Nicht-Indexschlüsselspalten erstellt, wenn Sie sie explizit erstellen oder wenn sie vom Abfrageoptimierer in Reaktion auf eine Abfrage mit einem Prädikat erstellt werden.) Das wesentliche Maß für die Kostenschätzung ist die Anzahl der Zeilen, die von einem einzelnen Operator verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="e1184-268">( [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] also creates statistics on non-index key columns if you explicitly create them or if the query optimizer creates them in response to a query with a predicate.) The main metric in cost estimation is the number of rows processed by a single operator.</span></span> <span data-ttu-id="e1184-269">Beachten Sie, dass für datenträgerbasierte Tabellen die Anzahl der Seiten, auf die von einem bestimmten Operator zugegriffen wird, für die Kostenschätzung maßgeblich ist.</span><span class="sxs-lookup"><span data-stu-id="e1184-269">Note that for disk-based tables, the number of pages accessed by a particular operator is significant in cost estimation.</span></span> <span data-ttu-id="e1184-270">Da die Seitenanzahl bei speicheroptimierten Tabellen jedoch nicht von Bedeutung ist (da sie immer 0 ist), steht hier die Zeilenanzahl im Vordergrund.</span><span class="sxs-lookup"><span data-stu-id="e1184-270">However, as page count is not important for memory-optimized tables (it is always zero), this discussion focuses on row count.</span></span> <span data-ttu-id="e1184-271">Die Schätzung beginnt mit den Index Seek- und Index Scan-Operatoren im Plan und schließt danach die anderen Operatoren wie den Join-Operator ein.</span><span class="sxs-lookup"><span data-stu-id="e1184-271">The estimation starts with the index seek and scan operators in the plan, and is then extended to include the other operators, like the join operator.</span></span> <span data-ttu-id="e1184-272">Die geschätzte Anzahl der von einem Joinoperator zu verarbeitenden Zeilen basiert auf der Schätzung für den zugrunde liegenden Index-, Seek- und Scan-Operator.</span><span class="sxs-lookup"><span data-stu-id="e1184-272">The estimated number of rows to be processed by a join operator is based on the estimation for the underlying index, seek, and scan operators.</span></span> <span data-ttu-id="e1184-273">Beim interpretierten [!INCLUDE[tsql](../../../includes/tsql-md.md)] -Zugriff auf speicheroptimierte Tabellen können Sie den tatsächlichen Ausführungsplan beobachten, um den Unterschied zwischen der geschätzten und der tatsächlichen Zeilenanzahl für die Operatoren im Plan herauszufinden.</span><span class="sxs-lookup"><span data-stu-id="e1184-273">For interpreted [!INCLUDE[tsql](../../../includes/tsql-md.md)] access to memory-optimized tables, you can observe the actual execution plan to see the difference between the estimated and actual row counts for the operators in the plan.</span></span>  
  
 <span data-ttu-id="e1184-274">Für das Beispiel in Abbildung 1 gilt:</span><span class="sxs-lookup"><span data-stu-id="e1184-274">For the example in figure 1,</span></span>  
  
-   <span data-ttu-id="e1184-275">Der Scan des gruppierten Indexes für Customer ergibt 91 geschätzte und 91 tatsächliche Zeilen.</span><span class="sxs-lookup"><span data-stu-id="e1184-275">The clustered index scan on Customer has estimated 91; actual 91.</span></span>  
  
-   <span data-ttu-id="e1184-276">Der Scan des nicht gruppierten Indexes für CustomerID ergibt 830 geschätzte und tatsächliche Zeilen.</span><span class="sxs-lookup"><span data-stu-id="e1184-276">The nonclustered index scan on CustomerID has estimated 830; actual 830.</span></span>  
  
-   <span data-ttu-id="e1184-277">Der Merge Join-Operator ergibt 815 geschätzte und 830 tatsächliche Zeilen.</span><span class="sxs-lookup"><span data-stu-id="e1184-277">The Merge Join operator has estimated 815; actual 830.</span></span>  
  
 <span data-ttu-id="e1184-278">Die Schätzungen für die Indexscans sind genau.</span><span class="sxs-lookup"><span data-stu-id="e1184-278">The estimates for the index scans are accurate.</span></span> [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="e1184-279">behält die Zeilenanzahl für datenträgerbasierte Tabellen bei.</span><span class="sxs-lookup"><span data-stu-id="e1184-279">maintains the row count for disk-based tables.</span></span> <span data-ttu-id="e1184-280">Schätzungen für vollständige Tabellen- und Indexscans sind immer genau.</span><span class="sxs-lookup"><span data-stu-id="e1184-280">Estimates for full table and index scans are always accurate.</span></span> <span data-ttu-id="e1184-281">Die Schätzung für den Join ist auch ziemlich genau.</span><span class="sxs-lookup"><span data-stu-id="e1184-281">The estimate for the join is fairly accurate, too.</span></span>  
  
 <span data-ttu-id="e1184-282">Wenn sich diese Schätzungen ändern, ändern sich auch die Kostenüberlegungen für verschiedene Planalternativen.</span><span class="sxs-lookup"><span data-stu-id="e1184-282">If these estimates change, the cost considerations for different plan alternatives change as well.</span></span> <span data-ttu-id="e1184-283">Wenn beispielsweise eine der Seiten des Joins eine geschätzte Zeilenanzahl von 1 oder nur einige Zeilen hat, ist die Verwendung von Joins geschachtelter Schleifen kostengünstiger.</span><span class="sxs-lookup"><span data-stu-id="e1184-283">For example, if one of the sides of the join has an estimated row count of 1 or just a few rows, using a nested loops joins is less expensive.</span></span>  
  
 <span data-ttu-id="e1184-284">Im Folgenden finden Sie den Plan für die Abfrage:</span><span class="sxs-lookup"><span data-stu-id="e1184-284">The following is the plan for the query:</span></span>  
  
```  
SELECT o.OrderID, c.* FROM dbo.[Customer] c INNER JOIN dbo.[Order] o ON c.CustomerID = o.CustomerID  
```  
  
 <span data-ttu-id="e1184-285">Nachdem alle Zeilen bis auf eine in der Customer-Tabelle gelöscht wurden:</span><span class="sxs-lookup"><span data-stu-id="e1184-285">After deleting all rows but one in the table Customer:</span></span>  
  
 <span data-ttu-id="e1184-286">![Spaltenstatistiken und Joins.](../../database-engine/media/hekaton-query-plan-9.gif "Spaltenstatistiken und Joins.")</span><span class="sxs-lookup"><span data-stu-id="e1184-286">![Column statistics and joins.](../../database-engine/media/hekaton-query-plan-9.gif "Column statistics and joins.")</span></span>  
  
 <span data-ttu-id="e1184-287">Bei diesem Abfrageplan:</span><span class="sxs-lookup"><span data-stu-id="e1184-287">Regarding this query plan:</span></span>  
  
-   <span data-ttu-id="e1184-288">Die Hashübereinstimmung wurde durch einen physischen Joinoperator für geschachtelte Schleifen ersetzt.</span><span class="sxs-lookup"><span data-stu-id="e1184-288">The Hash Match has been replaced with a Nested Loops physical join operator.</span></span>  
  
-   <span data-ttu-id="e1184-289">Der vollständige Indexscan für IX_CustomerID wurde durch eine Indexsuche ersetzt.</span><span class="sxs-lookup"><span data-stu-id="e1184-289">The full index scan on IX_CustomerID has been replaced with an index seek.</span></span> <span data-ttu-id="e1184-290">Dies führte zum Scannen von 5 Zeilen anstelle der für den vollständigen Indexscan erforderlichen 830 Zeilen.</span><span class="sxs-lookup"><span data-stu-id="e1184-290">This resulted in scanning 5 rows, instead of the 830 rows required for the full index scan.</span></span>  
  
### <a name="statistics-and-cardinality-for-memory-optimized-tables"></a><span data-ttu-id="e1184-291">Statistiken und Kardinalität für speicheroptimierte Tabellen</span><span class="sxs-lookup"><span data-stu-id="e1184-291">Statistics and Cardinality for Memory-Optimized Tables</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="e1184-292">behält Statistiken auf Spaltenebene für speicheroptimierte Tabellen bei.</span><span class="sxs-lookup"><span data-stu-id="e1184-292">maintains column-level statistics for memory-optimized tables.</span></span> <span data-ttu-id="e1184-293">Darüber hinaus behält es die tatsächliche Zeilenanzahl der Tabelle bei.</span><span class="sxs-lookup"><span data-stu-id="e1184-293">In addition, it maintains the actual row count of the table.</span></span> <span data-ttu-id="e1184-294">Im Gegensatz zu datenträgerbasierten Tabellen werden die Statistiken für speicheroptimierte Tabellen aber nicht automatisch aktualisiert.</span><span class="sxs-lookup"><span data-stu-id="e1184-294">However, in contrast to disk-based tables, the statistics for memory-optimized tables are not automatically updated.</span></span> <span data-ttu-id="e1184-295">Daher müssen Statistiken nach wichtigen Änderungen an den Tabellen manuell aktualisiert werden.</span><span class="sxs-lookup"><span data-stu-id="e1184-295">Therefore, statistics need to be manually updated after significant changes in the tables.</span></span> <span data-ttu-id="e1184-296">Weitere Informationen finden Sie unter [Statistiken für speicheroptimierte Tabellen](memory-optimized-tables.md).</span><span class="sxs-lookup"><span data-stu-id="e1184-296">For more information, see [Statistics for Memory-Optimized Tables](memory-optimized-tables.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="e1184-297">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="e1184-297">See Also</span></span>  
 [<span data-ttu-id="e1184-298">Speicheroptimierte Tabellen</span><span class="sxs-lookup"><span data-stu-id="e1184-298">Memory-Optimized Tables</span></span>](memory-optimized-tables.md)  
  
  
