---
title: Gruppieren von Änderungen an verknüpften Zeilen mithilfe von logischen Datensätzen | Microsoft-Dokumentation
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: replication
ms.topic: conceptual
helpviewer_keywords:
- merge replication logical records [SQL Server replication]
- articles [SQL Server replication], logical records
- logical records [SQL Server replication]
ms.assetid: ad76799c-4486-4b98-9705-005433041321
author: MashaMSFT
ms.author: mathoma
ms.openlocfilehash: 433e0edbe83d102e6002bd133f967f27a236f66e
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/04/2020
ms.locfileid: "87607703"
---
# <a name="group-changes-to-related-rows-with-logical-records"></a><span data-ttu-id="2a11d-102">Gruppieren von Änderungen an verknüpften Zeilen mithilfe von logischen Datensätzen</span><span class="sxs-lookup"><span data-stu-id="2a11d-102">Group Changes to Related Rows with Logical Records</span></span>
  
> [!NOTE]
>  [!INCLUDE[ssNoteDepFutureAvoid](../../../includes/ssnotedepfutureavoid-md.md)]

 <span data-ttu-id="2a11d-103">Standardmäßig werden Datenänderungen beim Mergereplikationsprozess auf Zeilenbasis verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="2a11d-103">By default, merge replication processes data changes on a row-by-row basis.</span></span> <span data-ttu-id="2a11d-104">In vielen Fällen ist das zweckmäßig, jedoch müssen bei einigen Anwendungen verknüpfte Zeilen als Einheit verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="2a11d-104">In many circumstances this is appropriate, but for some applications, it is essential that related rows be processed as a unit.</span></span> <span data-ttu-id="2a11d-105">Mit der Funktion logischer Datensätze der Mergereplikation können Sie eine Beziehung zwischen verknüpften Zeilen in verschiedenen Tabellen definieren, sodass Zeilen als Einheit verarbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="2a11d-105">The logical records feature of merge replication allows you to define a relationship between related rows in different tables so that the rows are processed as a unit.</span></span>

> [!NOTE]
>  <span data-ttu-id="2a11d-106">Logische Datensätze können allein oder in Verbindung mit Joinfiltern verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="2a11d-106">The logical records feature can be used alone or in conjunction with join filters.</span></span> <span data-ttu-id="2a11d-107">Weitere Informationen zu Joinfiltern finden Sie unter [Join Filters](join-filters.md).</span><span class="sxs-lookup"><span data-stu-id="2a11d-107">For more information about join filters, see [Join Filters](join-filters.md).</span></span> <span data-ttu-id="2a11d-108">Zum Verwenden logischer Datensätze muss die Veröffentlichung mindestens einen Kompatibilitätsgrad von 90RTM aufweisen.</span><span class="sxs-lookup"><span data-stu-id="2a11d-108">To use logical records, the compatibility level of the publication must be at least 90RTM.</span></span>

 <span data-ttu-id="2a11d-109">Nehmen Sie die folgenden drei verknüpften Tabellen als Beispiel:</span><span class="sxs-lookup"><span data-stu-id="2a11d-109">Consider these three related tables:</span></span>

 <span data-ttu-id="2a11d-110">![Logischer Datensatz für drei Tabellen, mit ausschließlich Spaltennamen](../media/logical-records-01.gif "Logischer Datensatz für drei Tabellen, mit ausschließlich Spaltennamen")</span><span class="sxs-lookup"><span data-stu-id="2a11d-110">![Three table logical record, with column names only](../media/logical-records-01.gif "Three table logical record, with column names only")</span></span>

 <span data-ttu-id="2a11d-111">Die **Customers** -Tabelle ist die übergeordnete Tabelle in dieser Beziehung und enthält eine **CustID**-Primärschlüsselspalte.</span><span class="sxs-lookup"><span data-stu-id="2a11d-111">The **Customers** table is the parent table in this relationship and has a primary key column **CustID**.</span></span> <span data-ttu-id="2a11d-112">Die **Orders** -Tabelle enthält eine **OrderID**-Primärschlüsselspalte sowie eine FOREIGN KEY-Einschränkung für die **CustID** -Spalte, die auf die **CustID** -Spalte in der **Customers** -Tabelle verweist.</span><span class="sxs-lookup"><span data-stu-id="2a11d-112">The **Orders** table has a primary key column **OrderID**, with a foreign key constraint on the **CustID** column that references the **CustID** column in the **Customers** table.</span></span> <span data-ttu-id="2a11d-113">Dementsprechend enthält die **OrderItems** -Tabelle eine **OrderItemID**-Primärschlüsselspalte sowie eine FOREIGN KEY-Einschränkung für die **OrderID** -Spalte, die auf die **OrderID** -Spalte in der **Orders** -Tabelle verweist.</span><span class="sxs-lookup"><span data-stu-id="2a11d-113">Similarly, the **OrderItems** table has a primary key column **OrderItemID**, with a foreign key constraint on the **OrderID** column that references the **OrderID** column in the **Orders** table.</span></span>

 <span data-ttu-id="2a11d-114">In diesem Beispiel besteht ein logischer Datensatz aus allen Zeilen in der **Orders** -Tabelle, die sich auf einen einzelnen **CustID** -Wert beziehen, und allen Zeilen der **OrderItems** -Tabelle, die sich auf jene Zeilen in der **Orders** -Tabelle beziehen.</span><span class="sxs-lookup"><span data-stu-id="2a11d-114">In this example, a logical record consists of all the rows in the **Orders** table that are related to a single **CustID** value and all of the rows in the **OrderItems** table that are related to those rows in the **Orders** table.</span></span> <span data-ttu-id="2a11d-115">Das Diagramm zeigt alle Zeilen in den drei Tabellen, die im logischen Datensatz für Customer 2 enthalten sind:</span><span class="sxs-lookup"><span data-stu-id="2a11d-115">This diagram shows all the rows in the three tables that are in the logical record for Customer2:</span></span>

 <span data-ttu-id="2a11d-116">![Logischer Datensatz für drei Tabellen mit Werten](../media/logical-records-02.gif "Logischer Datensatz für drei Tabellen mit Werten")</span><span class="sxs-lookup"><span data-stu-id="2a11d-116">![Three table logical record with values](../media/logical-records-02.gif "Three table logical record with values")</span></span>

 <span data-ttu-id="2a11d-117">Informationen zum Definieren einer logischen Datensatzbeziehung zwischen Artikeln finden Sie unter [Definieren einer logische Datensatzbeziehung zwischen Mergetabellenartikeln](../publish/define-a-logical-record-relationship-between-merge-table-articles.md).</span><span class="sxs-lookup"><span data-stu-id="2a11d-117">To define a logical record relationship between articles, see [Define a Logical Record Relationship Between Merge Table Articles](../publish/define-a-logical-record-relationship-between-merge-table-articles.md).</span></span>

## <a name="benefits-of-logical-records"></a><span data-ttu-id="2a11d-118">Vorteile logischer Datensätze</span><span class="sxs-lookup"><span data-stu-id="2a11d-118">Benefits of Logical Records</span></span>
 <span data-ttu-id="2a11d-119">Logische Datensätze bieten zwei entscheidende Vorteile:</span><span class="sxs-lookup"><span data-stu-id="2a11d-119">The logical records feature has two primary benefits:</span></span>

-   <span data-ttu-id="2a11d-120">Datenänderungen werden als Einheit angewendet.</span><span class="sxs-lookup"><span data-stu-id="2a11d-120">Application of data changes as a unit.</span></span>

-   <span data-ttu-id="2a11d-121">Gleichzeitige Erkennung und Lösung von Konflikten in mehreren Zeilen aus mehreren Tabellen.</span><span class="sxs-lookup"><span data-stu-id="2a11d-121">The detection and resolution of conflicts simultaneously on multiple rows from multiple tables.</span></span>

### <a name="the-application-of-changes-as-a-unit"></a><span data-ttu-id="2a11d-122">Anwendung von Änderungen als Einheit</span><span class="sxs-lookup"><span data-stu-id="2a11d-122">The Application of Changes As a Unit</span></span>
 <span data-ttu-id="2a11d-123">Falls die Mergeverarbeitung unterbrochen wird, wie z. B. bei einer gelöschten Verbindung, wird bei Verwendung logischer Datensätze für die teilweise abgeschlossene Gruppe verknüpfter replizierter Änderungen ein Rollback ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="2a11d-123">If merge processing is interrupted, such as in the case of a dropped connection, the partially completed set of related replicated changes is rolled back if logical records are used.</span></span> <span data-ttu-id="2a11d-124">Beispiel: Ein Abonnent fügt einen neuen Auftrag mit **OrderID** = 6 und zwei neue Zeilen in der **OrderItems** -Tabelle mit **OrderItemID** = 10 und **OrderItemID** = 11 für **OrderID** = 6 hinzu.</span><span class="sxs-lookup"><span data-stu-id="2a11d-124">For example, consider the case where a Subscriber adds a new order with **OrderID** = 6 and two new rows in the **OrderItems** table with **OrderItemID** = 10 and **OrderItemID** = 11 for **OrderID** = 6.</span></span>

 <span data-ttu-id="2a11d-125">![Logischer Datensatz für drei Tabellen mit Werten](../media/logical-records-04.gif "Logischer Datensatz für drei Tabellen mit Werten")</span><span class="sxs-lookup"><span data-stu-id="2a11d-125">![Three table logical record with values](../media/logical-records-04.gif "Three table logical record with values")</span></span>

 <span data-ttu-id="2a11d-126">Wenn der Replikationsprozess unterbrochen wird, nachdem die **Orders** -Zeile für **OrderID** = 6 abgeschlossen wurde, jedoch bevor die **OrderItems** 10 und 11 abgeschlossen wurden, ist der **OrderTotal** -Wert für **OrderID** = 6 ohne Verwendung logischer Datensätze nicht mit der Summe der **OrderAmount** -Werte für die **OrderItems** -Zeilen konsistent.</span><span class="sxs-lookup"><span data-stu-id="2a11d-126">If the replication process is interrupted after the **Orders** row for **OrderID** = 6 is complete, but before the **OrderItems** 10 and 11 are completed, and logical records are not used, the **OrderTotal** value for **OrderID** = 6 will not be consistent with the sum of the **OrderAmount** values for the **OrderItems** rows.</span></span> <span data-ttu-id="2a11d-127">Bei Verwendung logischer Datensätze wird für die **Orders** -Zeile für **OrderID** = 6 erst dann ein Commit ausgeführt, wenn die verknüpften **OrderItems** -Änderungen repliziert wurden.</span><span class="sxs-lookup"><span data-stu-id="2a11d-127">If logical records are used, the **Orders** row for **OrderID** = 6 is not committed until the related **OrderItems** changes are replicated.</span></span>

 <span data-ttu-id="2a11d-128">Ein anderes Szenario bei der Verwendung logischer Datensätze wäre folgendes: Jemand fragt Datensätze ab, während Änderungen vom Mergeprozess angewendet werden. Der Benutzer sieht dann die teilweise replizierten Änderungen erst, wenn sie abgeschlossen sind.</span><span class="sxs-lookup"><span data-stu-id="2a11d-128">In a different scenario, if logical records are used, and someone is querying tables when the merge process is applying changes, the user will not see the partially replicated changes until they are all complete.</span></span> <span data-ttu-id="2a11d-129">Beispiel: Die Orders-Zeile für **OrderID** = 6 wurde vom Replikationsprozess hochgeladen. Jedoch fragt ein Benutzer die Tabellen ab, bevor der Replikationsprozess die **OrderItems** -Zeilen repliziert hat. Der **OrderTotal** -Wert wäre nun nicht mit der Summe der **OrderAmount** -Werte identisch.</span><span class="sxs-lookup"><span data-stu-id="2a11d-129">For example, the replication process has uploaded the Orders row for **OrderID** = 6, but a user queries the tables before the replication process has replicated the **OrderItems** rows, the **OrderTotal** value would not be the same as the sum of the **OrderAmount** values.</span></span> <span data-ttu-id="2a11d-130">Bei der Verwendung logischer Datensätze wäre die **Orders** -Zeile erst dann zu sehen, wenn die **OrderItems** -Zeilen abgeschlossen wurden und ein Commit für die Transaktion als Einheit ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="2a11d-130">If logical records are used, the **Orders** row would not be visible until the **OrderItems** rows are complete and the transaction has been committed as a unit.</span></span>

### <a name="the-application-of-conflict-handling-to-more-than-one-table"></a><span data-ttu-id="2a11d-131">Anwendung der Konfliktbehandlung auf mehrere Tabellen</span><span class="sxs-lookup"><span data-stu-id="2a11d-131">The Application of Conflict Handling to More Than One Table</span></span>
 <span data-ttu-id="2a11d-132">Nehmen Sie als Beispiel den Fall, dass zwei Abonnenten das obige Dataset verwenden:</span><span class="sxs-lookup"><span data-stu-id="2a11d-132">Consider the case where two Subscribers have the data set above:</span></span>

-   <span data-ttu-id="2a11d-133">Ein Benutzer ändert auf dem ersten Abonnenten den **OrderAmount** -Wert von **OrderItemID** 5 von 100 auf 150 und den **OrderTotal** -Wert von **OrderID** 3 von 200 auf 250.</span><span class="sxs-lookup"><span data-stu-id="2a11d-133">A user at the first Subscriber changes the **OrderAmount** of **OrderItemID** 5 from 100 to 150 and the **OrderTotal** of **OrderID** 3 from 200 to 250.</span></span>

-   <span data-ttu-id="2a11d-134">Ein Benutzer ändert auf dem zweiten Abonnenten den **OrderAmount** -Wert von **OrderItemID** 6 von 25 auf 125 und den **OrderTotal** -Wert von **OrderID** 3 von 200 auf 300.</span><span class="sxs-lookup"><span data-stu-id="2a11d-134">A user at the second Subscriber changes the **OrderAmount** of **OrderItemID** 6 from 25 to 125 and the **OrderTotal** of **OrderID** 3 from 200 to 300.</span></span>

 <span data-ttu-id="2a11d-135">Würden diese Änderungen ohne Verwendung logischer Datensätze repliziert werden, ergäben die unterschiedlichen **OrderTotal** -Werte einen Konflikt, und nur einer der Werte würde repliziert.</span><span class="sxs-lookup"><span data-stu-id="2a11d-135">If these changes are replicated without using logical records, the different **OrderTotal** values would result in a conflict and only one of them would be replicated.</span></span> <span data-ttu-id="2a11d-136">Die nicht in Konflikt stehenden Änderungen in der **OrderItems** -Tabelle würden problemlos repliziert. Das würde dazu führen, dass die endgültigen **OrderTotal** -Werte in Bezug auf die **OrderItems** -Zeilen inkonsistent wären.</span><span class="sxs-lookup"><span data-stu-id="2a11d-136">But the non-conflicting changes in the **OrderItems** table would be replicated without conflict, leaving the final **OrderTotal** values in an inconsistent state with respect to the **OrderItems** rows.</span></span> <span data-ttu-id="2a11d-137">Werden logische Datensätze in diesem Szenario verwendet, würde auch für die Änderung von **OrderItems** , die mit der verlierenden Änderung der **Orders** -Tabelle verbunden ist, ein Rollback ausgeführt. Die endgültigen **OrderTotal** -Werte entsprächen dann einer genauen Zusammenfassung der **OrderItems** -Zeilen.</span><span class="sxs-lookup"><span data-stu-id="2a11d-137">If logical records are used in this scenario, the **OrderItems** change associated with the losing **Orders** table change would also be rolled back, and the final **OrderTotal** value would be an accurate summary of the **OrderItems** rows.</span></span>

 <span data-ttu-id="2a11d-138">Weitere Informationen zur Konflikterkennung und -lösung bei logischen Datensätzen finden Sie unter [Ermitteln und Lösen von Konflikten in logischen Datensätzen](advanced-merge-replication-conflict-resolving-in-logical-record.md).</span><span class="sxs-lookup"><span data-stu-id="2a11d-138">For more information about options related to conflict detection and resolution with logical records, see [Detecting and Resolving Conflicts in Logical Records](advanced-merge-replication-conflict-resolving-in-logical-record.md).</span></span>

## <a name="considerations-for-using-logical-records"></a><span data-ttu-id="2a11d-139">Überlegungen zum Verwenden logischer Datensätze</span><span class="sxs-lookup"><span data-stu-id="2a11d-139">Considerations for Using Logical Records</span></span>
 <span data-ttu-id="2a11d-140">Beachten Sie bei der Verwendung von logischen Datensätzen Folgendes:</span><span class="sxs-lookup"><span data-stu-id="2a11d-140">Keep the following considerations in mind when using logical records.</span></span>

### <a name="general-considerations"></a><span data-ttu-id="2a11d-141">Allgemeine Überlegungen</span><span class="sxs-lookup"><span data-stu-id="2a11d-141">General Considerations</span></span>

-   <span data-ttu-id="2a11d-142">Halten Sie die Anzahl der Tabellen in einem logischen Datensatz so gering wie möglich: Empfohlen werden maximal fünf Tabellen.</span><span class="sxs-lookup"><span data-stu-id="2a11d-142">It is recommended that you keep the number of tables in a logical record as low as possible; five tables or less is recommended.</span></span>

-   <span data-ttu-id="2a11d-143">Logische Datensätze können nicht auf Spalten verweisen, die folgende Datentypen enthalten:</span><span class="sxs-lookup"><span data-stu-id="2a11d-143">Logical records cannot reference columns with any of the following data types:</span></span>

    -   <span data-ttu-id="2a11d-144">`varchar(max)` und `nvarchar(max)`</span><span class="sxs-lookup"><span data-stu-id="2a11d-144">`varchar(max)` and `nvarchar(max)`</span></span>

    -   `varbinary(max)`

    -   <span data-ttu-id="2a11d-145">`text` und `ntext`</span><span class="sxs-lookup"><span data-stu-id="2a11d-145">`text` and `ntext`</span></span>

    -   `image`

    -   `XML`

    -   `UDT`

-   <span data-ttu-id="2a11d-146">Fremdschlüsselbeziehungen in veröffentlichten Tabellen können nicht mit der Option CASCADE definiert werden.</span><span class="sxs-lookup"><span data-stu-id="2a11d-146">Foreign key relationships in published tables cannot be defined with the CASCADE option.</span></span> <span data-ttu-id="2a11d-147">Weitere Informationen finden Sie unter [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql) und [ALTER TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-table-transact-sql).</span><span class="sxs-lookup"><span data-stu-id="2a11d-147">For more information, see [CREATE TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/create-table-transact-sql) and [ALTER TABLE &#40;Transact-SQL&#41;](/sql/t-sql/statements/alter-table-transact-sql).</span></span>

-   <span data-ttu-id="2a11d-148">Sie können keine Spalten aktualisieren, die in der Klausel der logischen Beziehung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="2a11d-148">You cannot update any columns that are used in the logical relation clause.</span></span>

-   <span data-ttu-id="2a11d-149">Eine benutzerdefinierte Konfliktlösung mit Geschäftslogikhandlern oder benutzerdefinierte Konfliktlöser werden nicht für Artikel unterstützt, die in einen logischen Datensatz eingeschlossen sind.</span><span class="sxs-lookup"><span data-stu-id="2a11d-149">Custom conflict resolution with business logic handlers or custom resolvers is not supported for articles that are included in a logical record.</span></span>

-   <span data-ttu-id="2a11d-150">Wenn logische Datensätze in einer Veröffentlichung verwendet werden, die parametrisierte Filter enthält, müssen Sie jeden Abonnenten mit einer Momentaufnahme für dessen Partition initialisieren.</span><span class="sxs-lookup"><span data-stu-id="2a11d-150">If logical records are used in a publication that includes parameterized filters, you must initialize each Subscriber with a snapshot for its partition.</span></span> <span data-ttu-id="2a11d-151">Falls Sie einen Abonnenten mit einer anderen Methode initialisieren, schlägt der Merge-Agent fehl.</span><span class="sxs-lookup"><span data-stu-id="2a11d-151">If you initialize a Subscriber with another method, the Merge Agent will fail.</span></span> <span data-ttu-id="2a11d-152">Weitere Informationen finden Sie unter [Snapshots for Merge Publications with Parameterized Filters](../snapshots-for-merge-publications-with-parameterized-filters.md).</span><span class="sxs-lookup"><span data-stu-id="2a11d-152">For more information, see [Snapshots for Merge Publications with Parameterized Filters](../snapshots-for-merge-publications-with-parameterized-filters.md).</span></span>

-   <span data-ttu-id="2a11d-153">Konflikte, die logische Datensätze einschließen, werden im Konflikt-Viewer nicht angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2a11d-153">Conflicts that involve logical records are not displayed in Conflict Viewer.</span></span> <span data-ttu-id="2a11d-154">Mit den gespeicherten Replikationsprozeduren können Informationen zu diesen Konflikten angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="2a11d-154">To view information about these conflicts, use replication stored procedures.</span></span> <span data-ttu-id="2a11d-155">Weitere Informationen finden Sie unter [Anzeigen von Konfliktinformationen zu Mergeveröffentlichungen &#40;Replikationsprogrammierung mit Transact-SQL&#41;](../view-conflict-information-for-merge-publications.md)</span><span class="sxs-lookup"><span data-stu-id="2a11d-155">For more information, see [View Conflict Information for Merge Publications &#40;Replication Transact-SQL Programming&#41;](../view-conflict-information-for-merge-publications.md).</span></span>

### <a name="publication-settings"></a><span data-ttu-id="2a11d-156">Veröffentlichungseinstellungen</span><span class="sxs-lookup"><span data-stu-id="2a11d-156">Publication Settings</span></span>

-   <span data-ttu-id="2a11d-157">Die Veröffentlichung muss mindestens einen Kompatibilitätsgrad von 90RTM aufweisen.</span><span class="sxs-lookup"><span data-stu-id="2a11d-157">The publication must have a compatibility level of 90RTM or greater.</span></span> <span data-ttu-id="2a11d-158">Weitere Informationen finden Sie im Abschnitt „Kompatibilitätsgrad von Veröffentlichungen“ [Abwärtskompatibilität von Replikationen](../replication-backward-compatibility.md).</span><span class="sxs-lookup"><span data-stu-id="2a11d-158">For more information, see the "Publication Compatibility Level" section of [Replication Backward Compatibility](../replication-backward-compatibility.md).</span></span>

-   <span data-ttu-id="2a11d-159">Die Veröffentlichung muss den systemeigenen Momentaufnahmemodus verwenden.</span><span class="sxs-lookup"><span data-stu-id="2a11d-159">The publication must use native snapshot mode.</span></span> <span data-ttu-id="2a11d-160">Dies ist die Standardeinstellung, es sei denn, Sie replizieren in [!INCLUDE[ssEW](../../../includes/ssew-md.md)]. Logische Datensätze werden von diesem Programm nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="2a11d-160">This is the default unless you are replicating to [!INCLUDE[ssEW](../../../includes/ssew-md.md)], which does not support logical records.</span></span>

-   <span data-ttu-id="2a11d-161">Die Veröffentlichung kann eine Websynchronisierung nicht zulassen.</span><span class="sxs-lookup"><span data-stu-id="2a11d-161">The publication cannot allow Web synchronization.</span></span> <span data-ttu-id="2a11d-162">Weitere Informationen zur Websynchronisierung finden Sie unter [Web Synchronization for Merge Replication](../web-synchronization-for-merge-replication.md).</span><span class="sxs-lookup"><span data-stu-id="2a11d-162">For more information about Web synchronization, see [Web Synchronization for Merge Replication](../web-synchronization-for-merge-replication.md).</span></span>

-   <span data-ttu-id="2a11d-163">Gehen Sie folgendermaßen vor, wenn Sie logische Datensätze für eine gefilterte Veröffentlichung verwenden möchten:</span><span class="sxs-lookup"><span data-stu-id="2a11d-163">In order to use logical records on a filtered publication:</span></span>

    -   <span data-ttu-id="2a11d-164">Vorausberechnete Partitionen müssen ebenfalls verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="2a11d-164">Precomputed partitions must also be used.</span></span> <span data-ttu-id="2a11d-165">Die Anforderungen für vorausberechnete Partitionen treffen auch auf logische Datensätze zu.</span><span class="sxs-lookup"><span data-stu-id="2a11d-165">The requirements of precomputed partitions also apply to logical records.</span></span> <span data-ttu-id="2a11d-166">Weitere Informationen finden Sie unter [Optimieren Parametrisierter Filter-Leistung mit Vorausberechneten Partitionen ](parameterized-filters-optimize-for-precomputed-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="2a11d-166">For more information, see [Optimize Parameterized Filter Performance with Precomputed Partitions](parameterized-filters-optimize-for-precomputed-partitions.md).</span></span>

    -   <span data-ttu-id="2a11d-167">Sie können keine nicht überlappenden parametrisierten Filter verwenden.</span><span class="sxs-lookup"><span data-stu-id="2a11d-167">You cannot use nonoverlapping parameterized filters.</span></span> <span data-ttu-id="2a11d-168">Weitere Informationen finden Sie im Abschnitt zum Festlegen von Partitionsoptionen unter [Parameterized Row Filters](parameterized-filters-parameterized-row-filters.md).</span><span class="sxs-lookup"><span data-stu-id="2a11d-168">For more information, see the "Setting 'partition options'" section of [Parameterized Row Filters](parameterized-filters-parameterized-row-filters.md).</span></span>

-   <span data-ttu-id="2a11d-169">Wenn die Veröffentlichung Joinfilter verwendet, muss die **join unique key** -Eigenschaft für alle Joinfilter, die an Beziehungen logischer Datensätze beteiligt sind, auf **true** festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="2a11d-169">If the publication uses join filters, the **join unique key** property must be set to **true** for all join filters that are involved in logical record relationships.</span></span> <span data-ttu-id="2a11d-170">Weitere Informationen finden Sie unter [Join Filters](join-filters.md).</span><span class="sxs-lookup"><span data-stu-id="2a11d-170">For more information, see [Join Filters](join-filters.md).</span></span>

### <a name="relationships-between-tables"></a><span data-ttu-id="2a11d-171">Beziehungen zwischen Tabellen</span><span class="sxs-lookup"><span data-stu-id="2a11d-171">Relationships Between Tables</span></span>

-   <span data-ttu-id="2a11d-172">Tabellen, die über logische Datensätze verknüpft sind, müssen Primärschlüssel/Fremdschlüssel-Beziehungen aufweisen.</span><span class="sxs-lookup"><span data-stu-id="2a11d-172">Tables related through logical records must have a primary key-foreign key relationship.</span></span>

-   <span data-ttu-id="2a11d-173">Die Option NOT FOR REPLICATION kann für FOREIGN KEY-Einschränkungen nicht festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="2a11d-173">The NOT FOR REPLICATION option cannot be set for foreign key constraints.</span></span>

-   <span data-ttu-id="2a11d-174">Untergeordnete Tabellen können nur eine übergeordnete Tabelle aufweisen.</span><span class="sxs-lookup"><span data-stu-id="2a11d-174">Child tables can have only one parent table.</span></span>

     <span data-ttu-id="2a11d-175">Eine Datenbank, in der z. B. Kurse und Studenten nachverfolgt werden, könnte folgendermaßen aufgebaut sein:</span><span class="sxs-lookup"><span data-stu-id="2a11d-175">For example, a database tracking classes and students might have a design similar to:</span></span>

     <span data-ttu-id="2a11d-176">![Untergeordnete Tabelle mit mehr als einer übergeordneten Tabelle](../media/logical-records-03.gif "Untergeordnete Tabelle mit mehr als einer übergeordneten Tabelle")</span><span class="sxs-lookup"><span data-stu-id="2a11d-176">![Child table with more than one parent table](../media/logical-records-03.gif "Child table with more than one parent table")</span></span>

     <span data-ttu-id="2a11d-177">Sie können keinen logischen Datensatz verwenden, der die drei Tabellen in dieser Beziehung darstellt, da die Zeilen in **ClassMembers** keiner einzelnen Primärschlüsselzeile zugewiesen sind.</span><span class="sxs-lookup"><span data-stu-id="2a11d-177">You cannot use a logical record to represent the three tables in this relationship, because the rows in **ClassMembers** are not associated with a single primary key row.</span></span> <span data-ttu-id="2a11d-178">Die Tabellen **Classes** und **ClassMembers** könnten jedoch einen logischen Datensatz bilden, ebenso die Tabellen **ClassMembers** und **Students**, aber nicht alle drei zusammen.</span><span class="sxs-lookup"><span data-stu-id="2a11d-178">The tables **Classes** and **ClassMembers** could still form a logical record, as could the tables **ClassMembers** and **Students**, but not all three.</span></span>

-   <span data-ttu-id="2a11d-179">Die Veröffentlichung kann keine kreisförmigen Joinfilterbeziehungen enthalten.</span><span class="sxs-lookup"><span data-stu-id="2a11d-179">The publication cannot contain circular join filter relationships.</span></span>

     <span data-ttu-id="2a11d-180">Nehmen Sie das Beispiel **Customers**, **Orders**und **OrderItems**: Sie könnten keine logischen Datensätze verwenden, wenn die **Orders** -Tabelle auch eine FOREIGN KEY-Einschränkung aufweisen würde, die auf die **OrderItems** -Tabelle verweist.</span><span class="sxs-lookup"><span data-stu-id="2a11d-180">Using the example with the tables **Customers**, **Orders**, and **OrderItems**, you could not use logical records if the **Orders** table also had a foreign key constraint that referenced the **OrderItems** table.</span></span>

## <a name="performance-implications-of-logical-records"></a><span data-ttu-id="2a11d-181">Leistungseinschränkungen logischer Datensätze</span><span class="sxs-lookup"><span data-stu-id="2a11d-181">Performance implications of logical records</span></span>
 <span data-ttu-id="2a11d-182">Logische Datensätze wirken sich auf die Leistung aus.</span><span class="sxs-lookup"><span data-stu-id="2a11d-182">The logical record feature does come with a performance cost.</span></span> <span data-ttu-id="2a11d-183">Ohne logische Datensätze kann der Replikations-Agent alle Änderungen für einen bestimmten Artikel gleichzeitig verarbeiten. Da die Änderungen zeilenweise erfolgen, bestehen außerdem nur minimale Sperr- und Transaktionsprotokollanforderungen für die Anwendung von Änderungen.</span><span class="sxs-lookup"><span data-stu-id="2a11d-183">If logical records are not used, the replication agent can process all of the changes for a given article at the same time, and because the changes are applied in a row-by-row fashion, the locking and transaction log requirements necessary for applying the changes are minimal.</span></span>

 <span data-ttu-id="2a11d-184">Werden logische Datensätzen verwendet, muss der Merge-Agent die Änderungen für jeden vollständigen logischen Datensatz auf einmal verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="2a11d-184">If logical records are used, the Merge Agent must process the changes for each entire logical record together.</span></span> <span data-ttu-id="2a11d-185">Das wirkt sich auf die Dauer aus, die der Merge-Agent zum Replizieren der Zeilen benötigt.</span><span class="sxs-lookup"><span data-stu-id="2a11d-185">This has an effect on the amount of time it takes the Merge Agent to replicate the rows.</span></span> <span data-ttu-id="2a11d-186">Darüber hinaus können sich die Sperranforderungen erhöhen, da der Agent eine separate Transaktion für jeden logischen Datensatz öffnet.</span><span class="sxs-lookup"><span data-stu-id="2a11d-186">Additionally, because the agent opens a separate transaction for each logical record, locking requirements can increase.</span></span>

## <a name="see-also"></a><span data-ttu-id="2a11d-187">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="2a11d-187">See Also</span></span>
 [<span data-ttu-id="2a11d-188">Artikeloptionen für die Mergereplikation</span><span class="sxs-lookup"><span data-stu-id="2a11d-188">Article Options for Merge Replication</span></span>](article-options-for-merge-replication.md)


