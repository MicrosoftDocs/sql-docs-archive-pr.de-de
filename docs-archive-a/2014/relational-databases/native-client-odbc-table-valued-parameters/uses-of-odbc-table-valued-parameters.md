---
title: Verwendungen von ODBC-Tabellenwert Parametern | Microsoft-Dokumentation
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- table-valued parameters (ODBC), scenarios
- ODBC, table-valued parameters
ms.assetid: f1b73932-4570-4a8a-baa0-0f229d9c32ee
author: rothja
ms.author: jroth
ms.openlocfilehash: 2b128246f7c4ed9a9cec5e28698c743877f9873d
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/04/2020
ms.locfileid: "87724566"
---
# <a name="uses-of-odbc-table-valued-parameters"></a><span data-ttu-id="5d99d-102">Verwendungen von ODBC-Tabellenwertparametern</span><span class="sxs-lookup"><span data-stu-id="5d99d-102">Uses of ODBC Table-Valued Parameters</span></span>
  <span data-ttu-id="5d99d-103">In diesem Thema werden die wichtigsten Benutzerszenarien für die Verwendung von Tabellenwertparametern mit ODBC erläutert:</span><span class="sxs-lookup"><span data-stu-id="5d99d-103">This topic discusses the primary user scenarios for using table-valued parameters with ODBC:</span></span>  
  
-   <span data-ttu-id="5d99d-104">Tabellenwertparameter mit vollständig gebundenen mehrzeiligen Puffern (Senden von Daten als Tabellenwertparameter mit allen Werten im Arbeitsspeicher)</span><span class="sxs-lookup"><span data-stu-id="5d99d-104">Table-Valued Parameter with Fully Bound Multirow Buffers (Send Data as a TVP with All Values in Memory)</span></span>  
  
-   <span data-ttu-id="5d99d-105">Tabellenwertparameter mit Zeilenstreaming (Senden von Daten als Tabellenwertparameter mithilfe von Data-at-Execution)</span><span class="sxs-lookup"><span data-stu-id="5d99d-105">Table-Valued Parameter with Row Streaming (Send Data as a TVP Using Data-At-Execution)</span></span>  
  
-   <span data-ttu-id="5d99d-106">Abrufen von Tabellenwertparameter-Metadaten aus dem Systemkatalog</span><span class="sxs-lookup"><span data-stu-id="5d99d-106">Retrieving Table-Valued Parameter Metadata from the System Catalog</span></span>  
  
-   <span data-ttu-id="5d99d-107">Abrufen von Tabellenwertparameter-Metadaten für eine vorbereitete Anweisung</span><span class="sxs-lookup"><span data-stu-id="5d99d-107">Retrieving Table-Valued Parameter Metadata for a Prepared Statement</span></span>  
  
## <a name="table-valued-parameter-with-fully-bound-multirow-buffers-send-data-as-a-tvp-with-all-values-in-memory"></a><span data-ttu-id="5d99d-108">Tabellenwertparameter mit vollständig gebundenen mehrzeiligen Puffern (Senden von Daten als Tabellenwertparameter mit allen Werten im Arbeitsspeicher)</span><span class="sxs-lookup"><span data-stu-id="5d99d-108">Table-Valued Parameter with Fully Bound Multirow Buffers (Send Data as a TVP with All Values in Memory)</span></span>  
 <span data-ttu-id="5d99d-109">Bei der Verwendung mit vollständig gebundenen mehrzeiligen Puffern sind alle Parameterwerte im Arbeitsspeicher verfügbar.</span><span class="sxs-lookup"><span data-stu-id="5d99d-109">When used with fully bound multirow buffers, all parameter values are available in memory.</span></span> <span data-ttu-id="5d99d-110">Dies ist beispielsweise für eine OLTP-Transaktion typisch, bei der Tabellenwertparameter in eine einzeln gespeicherte Prozedur gepackt werden können.</span><span class="sxs-lookup"><span data-stu-id="5d99d-110">This is typical, for example, of an OLTP transaction, in which table-valued parameters can be packaged into a single stored procedure.</span></span> <span data-ttu-id="5d99d-111">Ohne Tabellenwertparameter wären mehrere Serveraufrufe oder die dynamische Generierung eines komplexen Batches mit mehreren Anweisungen erforderlich.</span><span class="sxs-lookup"><span data-stu-id="5d99d-111">Without table-valued parameters, this would involve either generating a complex multi-statement batch dynamically, or making multiple calls to the server.</span></span>  
  
 <span data-ttu-id="5d99d-112">Der Tabellenwert Parameter selbst wird mithilfe von [SQLBindParameter](https://go.microsoft.com/fwlink/?LinkId=59328) zusammen mit den anderen Parametern gebunden.</span><span class="sxs-lookup"><span data-stu-id="5d99d-112">The table-valued parameter itself is bound by using [SQLBindParameter](https://go.microsoft.com/fwlink/?LinkId=59328) along with the other parameters.</span></span> <span data-ttu-id="5d99d-113">Nachdem alle Parameter gebunden wurden, legt die Anwendung für jeden Tabellenwert Parameter das Parameter Fokus Attribut (SQL_SOPT_SS_PARAM_FOCUS) fest und ruft SQLBindParameter für die Spalten des Tabellenwert Parameters auf.</span><span class="sxs-lookup"><span data-stu-id="5d99d-113">After all parameters have been bound, the application sets the parameter focus attribute, SQL_SOPT_SS_PARAM_FOCUS, on each table-valued parameter and calls SQLBindParameter for the columns of the table-valued parameter.</span></span>  
  
 <span data-ttu-id="5d99d-114">Der Servertyp für Tabellenwertparameter ist SQL_SS_TABLE, ein neuer [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-spezifischer Typ.</span><span class="sxs-lookup"><span data-stu-id="5d99d-114">The server type for a table-valued parameter is a new [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-specific type, SQL_SS_TABLE.</span></span> <span data-ttu-id="5d99d-115">Der C-Bindungstyp für SQL_SS_TABLE muss stets SQL_C_DEFAULT sein.</span><span class="sxs-lookup"><span data-stu-id="5d99d-115">The binding C type for SQL_SS_TABLE must always be SQL_C_DEFAULT.</span></span> <span data-ttu-id="5d99d-116">Für den gebundenen Parameter des Tabellenwertparameters werden keine Daten übertragen. Dieser wird zur Übergabe von Tabellenmetadaten und zur Steuerung der Datenübergabe in die einzelnen Spalten des Tabellenwertparameters verwendet.</span><span class="sxs-lookup"><span data-stu-id="5d99d-116">No data is transferred for the table-valued parameter bound parameter; it is used to pass table metadata and to control how to pass data in the constituent columns of the table-valued parameter.</span></span>  
  
 <span data-ttu-id="5d99d-117">Die Länge des Tabellenwertparameters ist auf die Anzahl der an den Server gesendeten Zeilen festgelegt.</span><span class="sxs-lookup"><span data-stu-id="5d99d-117">The length of the table-valued parameter is set to the number of rows being sent to the server.</span></span> <span data-ttu-id="5d99d-118">Der *ColumnSize* -Parameter von SQLBindParameter für einen Tabellenwert Parameter gibt die maximale Anzahl von Zeilen an, die gesendet werden können. Dies ist die Array Größe der Spalten Puffer.</span><span class="sxs-lookup"><span data-stu-id="5d99d-118">The *ColumnSize* parameter of SQLBindParameter for a table-valued parameter specifies the maximum number of rows that can be sent; this is the array size of the column buffers.</span></span> <span data-ttu-id="5d99d-119">*ParameterValuePtr* ist der Parameter Puffer für einen Tabellenwert Parameter in SQLBindParameter.</span><span class="sxs-lookup"><span data-stu-id="5d99d-119">*ParameterValuePtr* is the parameter buffer,for a table-valued parameter in SQLBindParameter.</span></span> <span data-ttu-id="5d99d-120">*ParameterValuePtr* und die zugehörige *BufferLength* werden verwendet, um bei Bedarf den Typnamen des Tabellenwert Parameters zu übergeben.</span><span class="sxs-lookup"><span data-stu-id="5d99d-120">*ParameterValuePtr* and its associated *BufferLength* are used to pass the type name of the table-valued parameter when required.</span></span> <span data-ttu-id="5d99d-121">Der Typname wird nicht für gespeicherte Prozeduraufrufe benötigt, er ist jedoch für SQL-Anweisungen erforderlich.</span><span class="sxs-lookup"><span data-stu-id="5d99d-121">The type name is not required for stored procedure calls, but it is required for SQL statements.</span></span>  
  
 <span data-ttu-id="5d99d-122">Wenn ein Tabellenwert Parameter-Typname für einen SQLBindParameter-Befehl angegeben wird, muss er immer als Unicode-Wert angegeben werden, auch in Anwendungen, die als ANSI-Anwendungen erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="5d99d-122">When a table-valued parameter type name is specified on a call to SQLBindParameter, it must always be specified as a Unicode value, even in applications that are built as ANSI applications.</span></span> <span data-ttu-id="5d99d-123">Wenn Sie mithilfe von SQLSetDescField einen Typnamen für einen Tabellenwert Parameter angeben, können Sie einen Literalwert verwenden, der der Art und Weise entspricht, in der die Anwendung erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="5d99d-123">When you specify a table-valued parameter type name by using SQLSetDescField, you can use a literal that conforms to the way the application is built.</span></span> <span data-ttu-id="5d99d-124">Der ODBC-Treiber-Manager führt die eventuell erforderliche Unicode-Konvertierung aus.</span><span class="sxs-lookup"><span data-stu-id="5d99d-124">The ODBC Driver Manager will perform any required Unicode conversion.</span></span>  
  
 <span data-ttu-id="5d99d-125">Metadaten für Tabellenwert Parameter und Tabellenwert Parameter-Spalten können einzeln und explizit mithilfe von SQLGetDescRec, SQLSetDescRec, SQLGetDescField und SQLSetDescField bearbeitet werden.</span><span class="sxs-lookup"><span data-stu-id="5d99d-125">Metadata for table-valued parameters and table-valued parameter columns can be manipulated individually and explicitly by using SQLGetDescRec, SQLSetDescRec, SQLGetDescField, and SQLSetDescField.</span></span> <span data-ttu-id="5d99d-126">Das Überladen von SQLBindParameter ist jedoch in der Regel bequemer und erfordert in den meisten Fällen keinen expliziten deskriptorzugriff.</span><span class="sxs-lookup"><span data-stu-id="5d99d-126">However, overloading SQLBindParameter is usually more convenient and does not require explicit descriptor access in most cases.</span></span> <span data-ttu-id="5d99d-127">Diese Vorgehensweise ist mit der Definition von SQLBindParameter für andere Datentypen konsistent, mit dem Unterschied, dass für einen Tabellenwert Parameter die betroffenen Deskriptorfelder leicht abweichen.</span><span class="sxs-lookup"><span data-stu-id="5d99d-127">This approach is consistent with the definition of SQLBindParameter for other data types, except that for a table-valued parameter the affected descriptor fields are slightly different.</span></span>  
  
 <span data-ttu-id="5d99d-128">Manchmal verwendet eine Anwendung einen Tabellenwertparameter mit dynamischem SQL, und der Name des Tabellenwertparameters muss bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="5d99d-128">Sometimes, an application uses a table-valued parameter with dynamic SQL and the type name of the table-valued parameter must be supplied.</span></span> <span data-ttu-id="5d99d-129">Wenn dies der Fall ist und der Tabellenwert Parameter nicht im aktuellen Standardschema für die Verbindung definiert ist, müssen SQL_CA_SS_TYPE_CATALOG_NAME und SQL_CA_SS_TYPE_SCHEMA_NAME mithilfe von SQLSetDescField festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="5d99d-129">If this is the case and the table-valued parameter is not defined in the current default schema for the connection, SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME must be set by using SQLSetDescField.</span></span> <span data-ttu-id="5d99d-130">Da Tabellentypdefinitionen und Tabellenwertparameter in derselben Datenbank vorliegen müssen, darf SQL_CA_SS_TYPE_CATALOG_NAME nicht festgelegt werden, wenn die Anwendung Tabellenwertparameter verwendet.</span><span class="sxs-lookup"><span data-stu-id="5d99d-130">Because table type definitions and table-valued parameters must be in the same database, SQL_CA_SS_TYPE_CATALOG_NAME must not be set if the application uses table-valued parameters.</span></span> <span data-ttu-id="5d99d-131">Andernfalls meldet SQLSetDescField einen Fehler.</span><span class="sxs-lookup"><span data-stu-id="5d99d-131">Otherwise, SQLSetDescField will report an error.</span></span>  
  
 <span data-ttu-id="5d99d-132">Beispielcode für dieses Szenario finden Sie unter `demo_fixed_TVP_binding` Verwenden von [Tabellenwert Parametern &#40;ODBC-&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="5d99d-132">Sample code for this scenario is in the procedure `demo_fixed_TVP_binding` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="table-valued-parameter-with-row-streaming-send-data-as-a-tvp-using-data-at-execution"></a><span data-ttu-id="5d99d-133">Tabellenwertparameter mit Zeilenstreaming (Senden von Daten als Tabellenwertparameter mithilfe von Data-at-Execution)</span><span class="sxs-lookup"><span data-stu-id="5d99d-133">Table-Valued Parameter with Row Streaming (Send Data as a TVP Using Data-At-Execution)</span></span>  
 <span data-ttu-id="5d99d-134">In diesem Szenario stellt die Anwendung dem Treiber Zeilen nach Anforderung bereit. Diese werden an den Server gestreamt.</span><span class="sxs-lookup"><span data-stu-id="5d99d-134">In this scenario, the application supplies rows to the driver as it requests them and they are streamed to the server.</span></span> <span data-ttu-id="5d99d-135">Hierdurch wird das Puffern aller Zeilen im Arbeitsspeicher vermieden.</span><span class="sxs-lookup"><span data-stu-id="5d99d-135">This avoids having to buffer all rows in memory.</span></span> <span data-ttu-id="5d99d-136">Dies ist für Masseneinfügungs-/-updateszenarien repräsentativ.</span><span class="sxs-lookup"><span data-stu-id="5d99d-136">This is representative of bulk insert/update scenarios.</span></span> <span data-ttu-id="5d99d-137">Tabellenwertparameter bieten eine Leistungsfähigkeit, die zwischen Parameterarrays und Massenkopieren liegt.</span><span class="sxs-lookup"><span data-stu-id="5d99d-137">Table-valued parameters provide a performance point somewhere between parameter arrays and bulk copy.</span></span> <span data-ttu-id="5d99d-138">Tabellenwertparameter sind ebenso einfach zu programmieren wie Parameterarrays, sie bieten jedoch eine größere Flexibilität auf dem Server.</span><span class="sxs-lookup"><span data-stu-id="5d99d-138">That is, table-valued parameters are about as easy to program as parameter arrays, but they provide greater flexibility at the server.</span></span>  
  
 <span data-ttu-id="5d99d-139">Das Binden des Tabellenwertparameters und der zugehörigen Spalten erfolgt wie im vorherigen Abschnitt "Tabellenwertparameter mit vollständig gebundenen mehrzeiligen Puffern" beschrieben, der Längenindikator des Tabellenwertparameters selbst wird jedoch auf SQL_DATA_AT_EXEC festgelegt.</span><span class="sxs-lookup"><span data-stu-id="5d99d-139">The table-valued parameter and its columns are bound as discussed in the previous section, Table-Valued Parameter with Fully Bound Multirow Buffers, but the length indicator of the table-valued parameter itself is set to SQL_DATA_AT_EXEC.</span></span> <span data-ttu-id="5d99d-140">Der Treiber antwortet auf SQLExecute oder SQLExecuteDirect auf die übliche Weise bei Data-at-Execution-Parametern, d. h. durch Zurückgeben von SQL_NEED_DATA.</span><span class="sxs-lookup"><span data-stu-id="5d99d-140">The driver responds to SQLExecute or SQLExecuteDirect in the usual way for data-at-execution parameters-that is, by returning SQL_NEED_DATA.</span></span> <span data-ttu-id="5d99d-141">Wenn der Treiber bereit ist, Daten für einen Tabellenwert Parameter zu akzeptieren, gibt SQLParamData den Wert von *ParameterValuePtr* in SQLBindParameter zurück.</span><span class="sxs-lookup"><span data-stu-id="5d99d-141">When the driver is ready to accept data for a table-valued parameter, SQLParamData returns the value of *ParameterValuePtr* in SQLBindParameter.</span></span>  
  
 <span data-ttu-id="5d99d-142">Eine Anwendung verwendet SQLPutData für einen Tabellenwert Parameter, um die Verfügbarkeit von Daten für die einzelnen Tabellenwert Parameter-Spalten anzugeben.</span><span class="sxs-lookup"><span data-stu-id="5d99d-142">An application uses SQLPutData for a table-valued parameter to indicate the availability of data for table-valued parameter constituent columns.</span></span> <span data-ttu-id="5d99d-143">Wenn SQLPutData für einen Tabellenwert Parameter aufgerufen wird, muss *DataPtr* immer NULL sein, und *StrLen_Or_Ind* muss entweder 0 oder eine Zahl sein, die kleiner oder gleich der für Tabellenwert Parameter-Puffer angegebenen Array Größe ist (der *ColumnSize* -Parameter von SQLBindParameter).</span><span class="sxs-lookup"><span data-stu-id="5d99d-143">When SQLPutData is called for a table-valued parameter, *DataPtr* must always be null and *StrLen_or_Ind* must be either 0 or a number less than or equal to the array size specified for table-valued parameter buffers (the *ColumnSize* parameter of SQLBindParameter).</span></span> <span data-ttu-id="5d99d-144">Der Wert 0 gibt an, dass keine weiteren Zeilen für den Tabellenwertparameter vorhanden sind, und der Treiber fährt mit der Verarbeitung des nächsten tatsächlichen Prozedurparameters fort.</span><span class="sxs-lookup"><span data-stu-id="5d99d-144">0 signifies that there are no more rows for the table-valued parameter, and the driver will proceed to process to the next actual procedure parameter.</span></span> <span data-ttu-id="5d99d-145">Wenn *StrLen_Or_Ind* nicht 0 ist, verarbeitet der Treiber die einzelnen Tabellenwert Parameter-Spalten auf dieselbe Weise wie Parameter gebundene Parameter, die nicht Tabellenwert Parameter sind: jede Tabellenwert Parameter-Spalte kann die tatsächliche Daten Länge angeben, SQL_NULL_DATA, oder Sie kann Daten bei der Ausführung über Ihren Längen-/Indikatorpuffer angeben.</span><span class="sxs-lookup"><span data-stu-id="5d99d-145">When *StrLen_or_Ind* is not 0, the driver will process the table-valued parameter constituent columns in the same way as non-table-valued parameter bound parameters: Each table-valued parameter column can specify its actual data length, SQL_NULL_DATA, or it can specify data at execution via its length/indicator buffer.</span></span> <span data-ttu-id="5d99d-146">Tabellenwert Parameter-Spaltenwerte können von wiederholten Aufrufen von SQLPutData wie gewohnt übergeben werden, wenn ein Zeichen-oder Binärwert in Teile übergeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="5d99d-146">Table-valued parameter column values can be passed by repeated calls to SQLPutData as usual when a character or binary value is to be passed in pieces.</span></span>  
  
 <span data-ttu-id="5d99d-147">Nachdem alle Tabellenwertparameter-Spalten verarbeitet wurden, kehrt der Treiber zum Tabellenwertparameter zurück, um weitere Tabellenwertparameter-Datenzeilen zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="5d99d-147">When all table-valued parameter columns have been processed, the driver returns to the table-valued parameter to process further rows of table-valued parameter data.</span></span> <span data-ttu-id="5d99d-148">Bei Data-at-Execution-Tabellenwertparametern führt der Treiber daher nicht den üblichen sequenziellen Scan gebundener Parameter durch.</span><span class="sxs-lookup"><span data-stu-id="5d99d-148">Therefore, for data-at-execution table-valued parameters, the driver does not follow the usual sequential scan of bound parameters.</span></span> <span data-ttu-id="5d99d-149">Ein gebundener Tabellenwert Parameter wird abgerufen, bis SQLPutData mit *StrLen_Or_IndPtr* gleich 0 aufgerufen wird. zu diesem Zeitpunkt überspringt der Treiber Tabellenwert Parameter-Spalten und wechselt zum nächsten tatsächlichen Parameter der gespeicherten Prozedur.</span><span class="sxs-lookup"><span data-stu-id="5d99d-149">A bound table-valued parameter will be polled until SQLPutData is called with *StrLen_Or_IndPtr* equal to 0, at which time the driver skips table-valued parameter columns and moves to the next actual stored procedure parameter.</span></span>  <span data-ttu-id="5d99d-150">Wenn SQLPutData einen Indikator Wert größer oder gleich 1 übergibt, verarbeitet der Treiber Tabellenwert Parameter-Spalten und-Zeilen sequenziell, bis er über Werte für alle gebundenen Zeilen und Spalten verfügt.</span><span class="sxs-lookup"><span data-stu-id="5d99d-150">When SQLPutData passes an indicator value greater than or equal to 1, the driver processes table-valued parameter columns and rows sequentially until it has values for all bound rows and columns.</span></span> <span data-ttu-id="5d99d-151">Anschließend kehrt der Treiber zum Tabellenwertparameter zurück.</span><span class="sxs-lookup"><span data-stu-id="5d99d-151">Then the driver returns to the table-valued parameter.</span></span> <span data-ttu-id="5d99d-152">Zwischen dem empfangen des Tokens für den Tabellenwert Parameter von SQLParamData und dem Aufruf von SQLPutData (hstmt, NULL, n) für einen Tabellenwert Parameter muss die Anwendung Tabellenwert Parameter-Spaltendaten und Indikator Puffer Inhalte für die nächste Zeile oder Zeilen festlegen, die an den Server übergeben werden.</span><span class="sxs-lookup"><span data-stu-id="5d99d-152">Between receiving the token for the table-valued parameter from SQLParamData and calling SQLPutData(hstmt, NULL, n) for a table-valued parameter, the application must set table-valued parameter constituent column data and indicator buffer contents for the next row or rows to be passed to the server.</span></span>  
  
 <span data-ttu-id="5d99d-153">Beispielcode für dieses Szenario finden Sie in der Routine `demo_variable_TVP_binding` unter [Verwenden von Tabellenwert Parametern &#40;ODBC-&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="5d99d-153">Sample code for this scenario is in the routine `demo_variable_TVP_binding` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="retrieving-table-valued-parameter-metadata-from-the-system-catalog"></a><span data-ttu-id="5d99d-154">Abrufen von Tabellenwertparameter-Metadaten aus dem Systemkatalog</span><span class="sxs-lookup"><span data-stu-id="5d99d-154">Retrieving Table-Valued Parameter Metadata from the System Catalog</span></span>  
 <span data-ttu-id="5d99d-155">Wenn eine Anwendung sqlprocedurecolenns für eine Prozedur mit Tabellenwert Parameter-Parametern aufruft, wird data_type als SQL_SS_TABLE zurückgegeben, und TYPE_NAME ist der Name des Tabellentyps für den Tabellenwert Parameter.</span><span class="sxs-lookup"><span data-stu-id="5d99d-155">When an application calls SQLProcedureColumns for a procedure that has table-valued parameter parameters, DATA_TYPE is returned as SQL_SS_TABLE and TYPE_NAME is the name of the table type for the table-valued parameter.</span></span> <span data-ttu-id="5d99d-156">Dem Resultset, das von sqlprocedurecolrens zurückgegeben wird, werden zwei weitere Spalten hinzugefügt: SS_TYPE_CATALOG_NAME gibt den Namen des Katalogs zurück, in dem der Tabellentyp des Tabellenwert Parameters definiert ist, und SS_TYPE_SCHEMA_NAME gibt den Namen des Schemas zurück, in dem der Tabellentyp des Tabellenwert Parameters definiert ist.</span><span class="sxs-lookup"><span data-stu-id="5d99d-156">Two additional columns are added to the result set returned by SQLProcedureColumns: SS_TYPE_CATALOG_NAME returns the name of the catalog where the table type of the table-value parameter is defined, and SS_TYPE_SCHEMA_NAME returns the name of the schema where the where the table type of the table-value parameter is defined.</span></span> <span data-ttu-id="5d99d-157">In Übereinstimmung mit der ODBC-Spezifikation werden SS_TYPE_CATALOG_NAME und SS_TYPE_SCHEMA_NAME vor allen treiberspezifischen Spalten angezeigt, die in früheren Versionen von [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] hinzugefügt wurden sowie nach allen Spalten, die von ODBC selbst benötigt werden.</span><span class="sxs-lookup"><span data-stu-id="5d99d-157">In conformance with the ODBC specification, SS_TYPE_CATALOG_NAME and SS_TYPE_SCHEMA_NAME appear before all driver specific columns that were added in previous versions of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], and after all columns mandated by ODBC itself.</span></span>  
  
 <span data-ttu-id="5d99d-158">Die neuen Spalten werden nicht nur für Tabellenwertparameter, sondern auch für Parameter des CLR-benutzerdefinierten Typs aufgefüllt.</span><span class="sxs-lookup"><span data-stu-id="5d99d-158">The new columns will be populated not only for table-valued parameters, but also for CLR user-defined type parameters.</span></span> <span data-ttu-id="5d99d-159">Die vorhandenen Schema- und Katalogspalten von Parametern des benutzerdefinierten Typs werden noch aufgefüllt, in Zukunft wird die Anwendungsentwicklung jedoch durch gemeinsame Schema- und Katalogspalten für Datentypen, die diese erfordern, erleichtert.</span><span class="sxs-lookup"><span data-stu-id="5d99d-159">The existing schema and catalog columns of UDT parameters will still be populated, but having common schema and catalog columns for data types that require them will simplify application development in the future.</span></span> <span data-ttu-id="5d99d-160">(Beachten Sie, dass XML-Schemaauflistungen einige Unterschiede aufweisen und nicht in dieser Änderung enthalten sind.)</span><span class="sxs-lookup"><span data-stu-id="5d99d-160">(Note that XML schema collections are somewhat different and are not included in this change.)</span></span>  
  
 <span data-ttu-id="5d99d-161">Eine Anwendung verwendet SQLTables, um die Namen von Tabellentypen auf die gleiche Weise zu bestimmen wie für persistente Tabellen, Systemtabellen und Sichten.</span><span class="sxs-lookup"><span data-stu-id="5d99d-161">An application uses SQLTables to determine the names of table types the same way it does for persistent tables, system tables, and views.</span></span> <span data-ttu-id="5d99d-162">Die Einführung eines neuen Tabellentyps ? TABLE TYPE ? ermöglicht es einer Anwendung, Tabellentypen zu identifizieren, die mit Tabellenwertparametern verbunden sind.</span><span class="sxs-lookup"><span data-stu-id="5d99d-162">A new table type, TABLE TYPE, is introduced to enable an application to identify table types associated with table-valued parameters.</span></span> <span data-ttu-id="5d99d-163">Tabellentypen und reguläre Tabellen verwenden unterschiedliche Namespaces.</span><span class="sxs-lookup"><span data-stu-id="5d99d-163">Table types and regular tables use different namespaces.</span></span> <span data-ttu-id="5d99d-164">Daher können Sie den gleichen Namen für einen Tabellentyp und eine tatsächliche Tabelle verwenden.</span><span class="sxs-lookup"><span data-stu-id="5d99d-164">This means that you can use the same name for both a table type and an actual table.</span></span> <span data-ttu-id="5d99d-165">Für diesen Fall wurde ein neues Anweisungsattribut ? SQL_SOPT_SS_NAME_SCOPE ? eingeführt.</span><span class="sxs-lookup"><span data-stu-id="5d99d-165">To handle this, a new statement attribute, SQL_SOPT_SS_NAME_SCOPE, has been introduced.</span></span> <span data-ttu-id="5d99d-166">Dieses Attribut gibt an, ob SQLTables und andere Katalog Funktionen, die einen Tabellennamen als Parameter annehmen, den Tabellennamen als den Namen einer tatsächlichen Tabelle oder den Namen eines Tabellentyps interpretieren sollen.</span><span class="sxs-lookup"><span data-stu-id="5d99d-166">This attribute specifies whether SQLTables and other catalog functions that take a table name as a parameter should interpret the table name as the name of an actual table or the name of a table type.</span></span>  
  
 <span data-ttu-id="5d99d-167">Eine Anwendung verwendet SQLColumns, um die Spalten für einen Tabellentyp auf die gleiche Weise zu bestimmen wie für persistente Tabellen, muss jedoch zuerst SQL_SOPT_SS_NAME_SCOPE festlegen, um anzugeben, dass Sie mit Tabellentypen anstelle tatsächlicher Tabellen arbeitet.</span><span class="sxs-lookup"><span data-stu-id="5d99d-167">An application uses SQLColumns to determine the columns for a table type in the same way it does for persistent tables, but must first set SQL_SOPT_SS_NAME_SCOPE to indicate that it is working with table types rather than actual tables.</span></span> <span data-ttu-id="5d99d-168">SQLPrimaryKeys kann auch mit Tabellentypen verwendet werden, und zwar mithilfe von SQL_SOPT_SS_NAME_SCOPE.</span><span class="sxs-lookup"><span data-stu-id="5d99d-168">SQLPrimaryKeys can also be used with table types, again using SQL_SOPT_SS_NAME_SCOPE.</span></span>  
  
 <span data-ttu-id="5d99d-169">Beispielcode für dieses Szenario finden Sie in der Routine `demo_metadata_from_catalog_APIs` unter [Verwenden von Tabellenwert Parametern &#40;ODBC-&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="5d99d-169">Sample code for this scenario is in the routine `demo_metadata_from_catalog_APIs` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="retrieving-table-valued-parameter-metadata-for-a-prepared-statement"></a><span data-ttu-id="5d99d-170">Abrufen von Tabellenwertparameter-Metadaten für eine vorbereitete Anweisung</span><span class="sxs-lookup"><span data-stu-id="5d99d-170">Retrieving Table-Valued Parameter Metadata for a Prepared Statement</span></span>  
 <span data-ttu-id="5d99d-171">In diesem Szenario verwendet eine Anwendung SQLNumParameters und SQLDescribeParam, um Metadaten für Tabellenwert Parameter abzurufen.</span><span class="sxs-lookup"><span data-stu-id="5d99d-171">In this scenario, an application uses SQLNumParameters and SQLDescribeParam to retrieve metadata for table-valued parameters.</span></span>  
  
 <span data-ttu-id="5d99d-172">Das IPD-Feld SQL_CA_SS_TYPE_NAME wird verwendet, um den Typnamen für den Tabellenwertparameter abzurufen.</span><span class="sxs-lookup"><span data-stu-id="5d99d-172">The IPD field SQL_CA_SS_TYPE_NAME is used to retrieve the type name for the table-valued parameter.</span></span> <span data-ttu-id="5d99d-173">Die IPD-Felder SQL_CA_SS_TYPE_SCHEMA_NAME und SQL_CA_SS_TYPE_CATALOG_NAME werden zum Abrufen seines Katalogs bzw. Schemas verwendet.</span><span class="sxs-lookup"><span data-stu-id="5d99d-173">The IPD fields SQL_CA_SS_TYPE_SCHEMA_NAME and SQL_CA_SS_TYPE_CATALOG_NAME are used to retrieve its catalog and schema, respectively.</span></span>  
  
 <span data-ttu-id="5d99d-174">Tabellentypdefinitionen und Tabellenwertparameter müssen sich in der gleichen Datenbank befinden.</span><span class="sxs-lookup"><span data-stu-id="5d99d-174">Table type definitions and table-valued parameters must be in the same database.</span></span> <span data-ttu-id="5d99d-175">SQLSetDescField meldet einen Fehler, wenn eine Anwendung SQL_CA_SS_TYPE_CATALOG_NAME festlegt, wenn Tabellenwert Parameter verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="5d99d-175">SQLSetDescField will report an error if an application sets SQL_CA_SS_TYPE_CATALOG_NAME when using table-valued parameters.</span></span>  
  
 <span data-ttu-id="5d99d-176">SQL_CA_SS_TYPE_CATALOG_NAME und SQL_CA_SS_TYPE_SCHEMA_NAME können auch verwendet werden, um den Katalog und das Schema abzurufen, die mit Parametern des CLR-benutzerdefinierten Typs verbunden sind.</span><span class="sxs-lookup"><span data-stu-id="5d99d-176">SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME can also be used to retrieve the catalog and schema associated with CLR user-defined type parameters.</span></span> <span data-ttu-id="5d99d-177">SQL_CA_SS_TYPE_CATALOG_NAME und SQL_CA_SS_TYPE_SCHEMA_NAME sind Alternativen zu den vorhandenen typspezifischen Katalogschemaattributen für CLR-benutzerdefinierte Typen.</span><span class="sxs-lookup"><span data-stu-id="5d99d-177">SQL_CA_SS_TYPE_CATALOG_NAME and SQL_CA_SS_TYPE_SCHEMA_NAME are alternatives to the existing type specific catalog schema attributes for CLR UDT types.</span></span>  
  
 <span data-ttu-id="5d99d-178">Eine Anwendung verwendet SQLColumns auch zum Abrufen von Spalten Metadaten für einen Tabellenwert Parameter in diesem Szenario, da SQLDescribeParam keine Metadaten für die Spalten einer Tabellenwert Parameter-Spalte zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="5d99d-178">An application uses SQLColumns to retrieve column metadata for a table-valued parameter in this scenario, too, because SQLDescribeParam does not return metadata for the columns of a table-valued parameter column.</span></span>  
  
 <span data-ttu-id="5d99d-179">Der Beispielcode für diesen Anwendungsfall befindet sich in der Routine `demo_metadata_from_prepared_statement` in [Verwenden von Tabellenwert Parametern &#40;ODBC-&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span><span class="sxs-lookup"><span data-stu-id="5d99d-179">Sample code for this use case is in the routine `demo_metadata_from_prepared_statement` in [Use Table-Valued Parameters &#40;ODBC&#41;](../native-client-odbc-how-to/use-table-valued-parameters-odbc.md).</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="5d99d-180">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="5d99d-180">See Also</span></span>  
 [<span data-ttu-id="5d99d-181">Tabellenwert Parameter &#40;ODBC-&#41;</span><span class="sxs-lookup"><span data-stu-id="5d99d-181">Table-Valued Parameters &#40;ODBC&#41;</span></span>](table-valued-parameters-odbc.md)  
  
  
