---
title: XML-Indizes (SQL Server) | Microsoft-Dokumentation
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: conceptual
helpviewer_keywords:
- removing indexes
- deleting indexes
- secondary indexes [XML in SQL Server]
- xml data type [SQL Server], indexes
- dropping indexes
- PATH index
- DROP_EXISTING clause
- XML [SQL Server], indexes
- primary indexes [XML in SQL Server]
- indexes [SQL Server], XML
- XML indexes [SQL Server], secondary
- BLOBs, XML indexes
- disabling indexes
- XML indexes [SQL Server], modifying
- XML indexes [SQL Server]
- XML indexes [SQL Server], primary
- modifying indexes
- XML indexes [SQL Server], dropping
- VALUE index
- XML indexes [SQL Server], xml data type
- PROPERTY index
- XML indexes [SQL Server], creating
ms.assetid: f5c9209d-b3f3-4543-b30b-01365a5e7333
author: rothja
ms.author: jroth
ms.openlocfilehash: bf9a33bc18790bf8821d778746a708f78bbb3d8f
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/04/2020
ms.locfileid: "87619675"
---
# <a name="xml-indexes-sql-server"></a><span data-ttu-id="59fac-102">XML-Indizes (SQL Server)</span><span class="sxs-lookup"><span data-stu-id="59fac-102">XML Indexes (SQL Server)</span></span>
  <span data-ttu-id="59fac-103">XML-Indizes können für `xml`-Datentypspalten erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="59fac-103">XML indexes can be created on `xml` data type columns.</span></span> <span data-ttu-id="59fac-104">Sie indizieren alle Tags, Werte und Pfade für die XML-Instanzen in der Spalte. Die Indizierung verbessert zudem die Abfrageleistung.</span><span class="sxs-lookup"><span data-stu-id="59fac-104">They index all tags, values and paths over the XML instances in the column and benefit query performance.</span></span> <span data-ttu-id="59fac-105">Ihre Anwendung kann in folgenden Situationen von einem XML-Index profitieren:</span><span class="sxs-lookup"><span data-stu-id="59fac-105">Your application may benefit from an XML index in the following situations:</span></span>  
  
-   <span data-ttu-id="59fac-106">In Ihren Arbeitsauslastungen sind Abfragen von XML-Spalten üblich.</span><span class="sxs-lookup"><span data-stu-id="59fac-106">Queries on XML columns are common in your workload.</span></span> <span data-ttu-id="59fac-107">Die Wartungskosten für den XML-Index während der Datenänderung müssen berücksichtigt werden.</span><span class="sxs-lookup"><span data-stu-id="59fac-107">XML index maintenance cost during data modification must be considered.</span></span>  
  
-   <span data-ttu-id="59fac-108">Ihre XML-Werte sind relativ groß, und die abgerufenen Teile sind relativ klein.</span><span class="sxs-lookup"><span data-stu-id="59fac-108">Your XML values are relatively large and the retrieved parts are relatively small.</span></span> <span data-ttu-id="59fac-109">Mit dem Erstellen eines Index wird vermieden, dass zur Laufzeit die gesamten Daten analysiert werden müssen. Davon profitieren Indexsuchen und die Abfrageverarbeitung wird effizienter.</span><span class="sxs-lookup"><span data-stu-id="59fac-109">Building the index avoids parsing the whole data at run time and benefits index lookups for efficient query processing.</span></span>  
  
 <span data-ttu-id="59fac-110">XML-Indizes fallen in die folgenden Kategorien:</span><span class="sxs-lookup"><span data-stu-id="59fac-110">XML indexes fall into the following categories:</span></span>  
  
-   <span data-ttu-id="59fac-111">Primärer XML-Index</span><span class="sxs-lookup"><span data-stu-id="59fac-111">Primary XML index</span></span>  
  
-   <span data-ttu-id="59fac-112">Sekundärer XML-Index</span><span class="sxs-lookup"><span data-stu-id="59fac-112">Secondary XML index</span></span>  
  
 <span data-ttu-id="59fac-113">Der erste Index für die Spalte des Datentyps `xml` muss der primäre XML-Index sein.</span><span class="sxs-lookup"><span data-stu-id="59fac-113">The first index on the `xml` type column must be the primary XML index.</span></span> <span data-ttu-id="59fac-114">Mithilfe des primären XML-Index werden drei Arten sekundärer Indizes unterstützt: PATH, VALUE und PROPERTY.</span><span class="sxs-lookup"><span data-stu-id="59fac-114">Using the primary XML index, the following types of secondary indexes are supported: PATH, VALUE, and PROPERTY.</span></span> <span data-ttu-id="59fac-115">Abhängig vom Typ der Abfragen können diese sekundären Indizes die Abfrageleistung steigern.</span><span class="sxs-lookup"><span data-stu-id="59fac-115">Depending on the type of queries, these secondary indexes might help improve query performance.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="59fac-116">Sie können einen XML-Index nur dann erstellen oder bearbeiten, wenn die Datenbankoptionen korrekt für die Arbeit mit dem `xml`-Datentyp festgelegt sind.</span><span class="sxs-lookup"><span data-stu-id="59fac-116">You cannot create or modify an XML index unless the database options are set correctly for working with the `xml` data type.</span></span> <span data-ttu-id="59fac-117">Weitere Informationen finden Sie unter [Verwenden der Volltextsuche mit XML-Spalten](use-full-text-search-with-xml-columns.md).</span><span class="sxs-lookup"><span data-stu-id="59fac-117">For more information, see [Use Full-Text Search with XML Columns](use-full-text-search-with-xml-columns.md).</span></span>  
  
 <span data-ttu-id="59fac-118">XML-Instanzen werden in Spalten vom Typ `xml` als BLOBs (Binary Large Objects) gespeichert.</span><span class="sxs-lookup"><span data-stu-id="59fac-118">XML instances are stored in `xml` type columns as large binary objects (BLOBs).</span></span> <span data-ttu-id="59fac-119">Diese XML-Instanzen können groß sein, und die gespeicherte binäre Darstellung von Instanzen vom Datentyp `xml` kann bis zu 2 GB groß sein.</span><span class="sxs-lookup"><span data-stu-id="59fac-119">These XML instances can be large, and the stored binary representation of `xml` data type instances can be up to 2 GB.</span></span> <span data-ttu-id="59fac-120">Ohne Index werden diese BLOBs zur Laufzeit aufgeteilt, um eine Abfrage auszuwerten.</span><span class="sxs-lookup"><span data-stu-id="59fac-120">Without an index, these binary large objects are shredded at run time to evaluate a query.</span></span> <span data-ttu-id="59fac-121">Diese Aufteilung kann zeitaufwändig sein.</span><span class="sxs-lookup"><span data-stu-id="59fac-121">This shredding can be time-consuming.</span></span> <span data-ttu-id="59fac-122">Angenommen, beispielsweise liegt die folgende Abfrage vor:</span><span class="sxs-lookup"><span data-stu-id="59fac-122">For example, consider the following query:</span></span>  
  
```  
WITH XMLNAMESPACES ('https://schemas.microsoft.com/sqlserver/2004/07/adventure-works/ProductModelDescription' AS "PD")  
  
SELECT CatalogDescription.query('  
  /PD:ProductDescription/PD:Summary  
') as Result  
FROM Production.ProductModel  
WHERE CatalogDescription.exist ('/PD:ProductDescription/@ProductModelID[.="19"]') = 1  
```  
  
 <span data-ttu-id="59fac-123">Um die XML-Instanzen auszuwählen, die die Bedingung in der `WHERE` -Klausel erfüllen, wird der XML-BLOB (Binary Large Object) in jeder Zeile der `Production.ProductModel` -Tabelle zur Laufzeit aufgeteilt.</span><span class="sxs-lookup"><span data-stu-id="59fac-123">To select the XML instances that satisfy the condition in the `WHERE` clause, the XML binary large object (BLOB) in each row of table `Production.ProductModel` is shredded at run time.</span></span> <span data-ttu-id="59fac-124">Dann wird der Ausdruck `(/PD:ProductDescription/@ProductModelID[.="19"]`) in der `exist()` -Methode ausgewertet.</span><span class="sxs-lookup"><span data-stu-id="59fac-124">Then, the expression `(/PD:ProductDescription/@ProductModelID[.="19"]`) in the `exist()` method is evaluated.</span></span> <span data-ttu-id="59fac-125">Diese Aufteilung zur Laufzeit kann abhängig von der Größe und Anzahl der in der Spalte gespeicherten Instanzen kostenintensiv sein.</span><span class="sxs-lookup"><span data-stu-id="59fac-125">This run-time shredding can be costly, depending on the size and number of instances stored in the column.</span></span>  
  
 <span data-ttu-id="59fac-126">Wenn das Abfragen von XML-BLOBs in Ihrer Anwendungsumgebung häufig vorkommt, ist das Indizieren der Spalten des Datentyps `xml` hilfreich.</span><span class="sxs-lookup"><span data-stu-id="59fac-126">If querying XML binary large objects (BLOBs) is common in your application environment, it helps to index the `xml` type columns.</span></span> <span data-ttu-id="59fac-127">Das Verwalten des Indexes während der Datenänderung verursacht jedoch auch Kosten.</span><span class="sxs-lookup"><span data-stu-id="59fac-127">However, there is a cost associated with maintaining the index during data modification.</span></span>  
  
## <a name="primary-xml-index"></a><span data-ttu-id="59fac-128">Primärer XML-Index</span><span class="sxs-lookup"><span data-stu-id="59fac-128">Primary XML Index</span></span>  
 <span data-ttu-id="59fac-129">Der primäre XML-Index indiziert alle Tags, Werte und Pfade innerhalb der XML-Instanzen in einer XML-Spalte.</span><span class="sxs-lookup"><span data-stu-id="59fac-129">The primary XML index indexes all tags, values, and paths within the XML instances in an XML column.</span></span> <span data-ttu-id="59fac-130">Damit ein primärer XML-Index erstellt werden kann, muss die Tabelle, in der die XML-Spalte enthalten ist, einen gruppierten Index für den Primärschlüssel der Tabelle aufweisen.</span><span class="sxs-lookup"><span data-stu-id="59fac-130">To create a primary XML index, the table in which the XML column occurs must have a clustered index on the primary key of the table.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="59fac-131">verwendet diesen Primärschlüssel zum Korrelieren von Zeilen im primären XML-Index mit Zeilen in der Tabelle, in der die XML-Spalte enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="59fac-131">uses this primary key to correlate rows in the primary XML index with rows in the table that contains the XML column.</span></span>  
  
 <span data-ttu-id="59fac-132">Der primäre XML-Index ist eine aufgeteilte und persistente Darstellung der XML-BLOBs in der `xml`-Datentypspalte.</span><span class="sxs-lookup"><span data-stu-id="59fac-132">The primary XML index is a shredded and persisted representation of the XML BLOBs in the `xml` data type column.</span></span> <span data-ttu-id="59fac-133">Für jeden XML-BLOB in der Spalte erstellt der Index mehrere Datenzeilen.</span><span class="sxs-lookup"><span data-stu-id="59fac-133">For each XML binary large object (BLOB) in the column, the index creates several rows of data.</span></span> <span data-ttu-id="59fac-134">Die Anzahl der Zeilen im Index entspricht ungefähr der Anzahl der Knoten im XML-BLOB.</span><span class="sxs-lookup"><span data-stu-id="59fac-134">The number of rows in the index is approximately equal to the number of nodes in the XML binary large object.</span></span> <span data-ttu-id="59fac-135">Wenn eine Abfrage die vollständige XML-Instanz abruft, stellt [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] die Instanz aus der XML-Spalte bereit.</span><span class="sxs-lookup"><span data-stu-id="59fac-135">When a query retrieves the full XML instance, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] provides the instance from the XML column.</span></span> <span data-ttu-id="59fac-136">Abfragen innerhalb der XML-Instanzen verwenden den primären XML-Index und können Skalarwerte oder XML-Teilbäume zurückgeben, indem der Index selbst verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="59fac-136">Queries within XML instances use the primary XML index, and can return scalar values or XML subtrees by using the index itself.</span></span>  
  
 <span data-ttu-id="59fac-137">Jede Zeile speichert die folgenden Knoteninformationen:</span><span class="sxs-lookup"><span data-stu-id="59fac-137">Each row stores the following node information:</span></span>  
  
-   <span data-ttu-id="59fac-138">Tagname, z. B. einen Element- oder Attributnamen.</span><span class="sxs-lookup"><span data-stu-id="59fac-138">Tag name such as an element or attribute name.</span></span>  
  
-   <span data-ttu-id="59fac-139">Knotenwert.</span><span class="sxs-lookup"><span data-stu-id="59fac-139">Node value.</span></span>  
  
-   <span data-ttu-id="59fac-140">Knotentyp, z. B. Elementknoten, Attributknoten oder Textknoten.</span><span class="sxs-lookup"><span data-stu-id="59fac-140">Node type such as an element node, attribute node, or text node.</span></span>  
  
-   <span data-ttu-id="59fac-141">Informationen zur Dokumentreihenfolge, die durch einen internen Knotenbezeichner dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="59fac-141">Document order information, represented by an internal node identifier.</span></span>  
  
-   <span data-ttu-id="59fac-142">Pfad von jedem Knoten zum Stamm der XML-Struktur.</span><span class="sxs-lookup"><span data-stu-id="59fac-142">Path from each node to the root of the XML tree.</span></span> <span data-ttu-id="59fac-143">Diese Spalte wird in der Abfrage nach path-Ausdrücken durchsucht.</span><span class="sxs-lookup"><span data-stu-id="59fac-143">This column is searched for path expressions in the query.</span></span>  
  
-   <span data-ttu-id="59fac-144">Primärschlüssel der Basistabelle.</span><span class="sxs-lookup"><span data-stu-id="59fac-144">Primary key of the base table.</span></span> <span data-ttu-id="59fac-145">Der Primärschlüssel der Basistabelle wird im primären XML-Index für den Rückwärtsjoin mit der Basistabelle dupliziert, und die maximale Anzahl von Spalten im Primärschlüssel der Basistabelle ist auf 15 beschränkt.</span><span class="sxs-lookup"><span data-stu-id="59fac-145">The primary key of the base table is duplicated in the primary XML index for a back join with the base table, and the maximum number of columns in the primary key of the base table is limited to 15.</span></span>  
  
 <span data-ttu-id="59fac-146">Diese Knoteninformationen werden zum Auswerten und Erstellen der XML-Ergebnisse für eine angegebene Abfrage verwendet.</span><span class="sxs-lookup"><span data-stu-id="59fac-146">This node information is used to evaluate and construct XML results for a specified query.</span></span> <span data-ttu-id="59fac-147">Zu Optimierungszwecken werden der Tagname und die Knotentypinformationen als ganze Zahlen codiert; die Path-Spalte verwendet die gleiche Codierung.</span><span class="sxs-lookup"><span data-stu-id="59fac-147">For optimization purposes, the tag name and the node type information are encoded as integer values, and the Path column uses the same encoding.</span></span> <span data-ttu-id="59fac-148">Pfade werden außerdem in umgekehrter Reihenfolge gespeichert, damit eine Pfadzuordnung erfolgen kann, wenn nur das Pfadsuffix bekannt ist.</span><span class="sxs-lookup"><span data-stu-id="59fac-148">Also, paths are stored in reverse order to allow matching paths when only the path suffix is known.</span></span> <span data-ttu-id="59fac-149">Beispiel:</span><span class="sxs-lookup"><span data-stu-id="59fac-149">For example:</span></span>  
  
-   <span data-ttu-id="59fac-150">`//ContactRecord/PhoneNumber` , wobei nur die beiden letzten Schritte bekannt sind.</span><span class="sxs-lookup"><span data-stu-id="59fac-150">`//ContactRecord/PhoneNumber` where only the last two steps are known</span></span>  
  
 <span data-ttu-id="59fac-151">oder</span><span class="sxs-lookup"><span data-stu-id="59fac-151">OR</span></span>  
  
-   <span data-ttu-id="59fac-152">`/Book/*/Title` ; dabei wird das Platzhalterzeichen (`*`) in der Mitte des Ausdrucks angegeben.</span><span class="sxs-lookup"><span data-stu-id="59fac-152">`/Book/*/Title` where the wildcard character (`*`) is specified in the middle of the expression.</span></span>  
  
 <span data-ttu-id="59fac-153">Der Abfrageprozessor verwendet den primären XML-Index für Abfragen, die [xml-Datentypmethoden](/sql/t-sql/xml/xml-data-type-methods) beinhalten und entweder Skalarwerte oder die XML-Teilbäume vom primären Index selbst wiedergeben.</span><span class="sxs-lookup"><span data-stu-id="59fac-153">The query processor uses the primary XML index for queries that involve [xml Data Type Methods](/sql/t-sql/xml/xml-data-type-methods) and returns either scalar values or the XML subtrees from the primary index itself.</span></span> <span data-ttu-id="59fac-154">(Dieser Index speichert alle notwendigen Informationen, um die XML-Instanz zu rekonstruieren).</span><span class="sxs-lookup"><span data-stu-id="59fac-154">(This index stores all the necessary information to reconstruct the XML instance.)</span></span>  
  
 <span data-ttu-id="59fac-155">Die folgende Abfrage gibt beispielsweise Zusammenfassungs Informationen zurück, die in der `CatalogDescription``xml` Type-Spalte in der-Tabelle gespeichert sind `ProductModel` .</span><span class="sxs-lookup"><span data-stu-id="59fac-155">For example, the following query returns summary information stored in the `CatalogDescription``xml` type column in the `ProductModel` table.</span></span> <span data-ttu-id="59fac-156">Die Abfrage gibt <`Summary`>-Informationen nur für die Produktmodelle zurück, deren Katalogbeschreibung auch die <`Features`>-Beschreibung speichert.</span><span class="sxs-lookup"><span data-stu-id="59fac-156">The query returns <`Summary`> information only for product models whose catalog description also stores the <`Features`> description.</span></span>  
  
```  
WITH XMLNAMESPACES ('https://schemas.microsoft.com/sqlserver/2004/07/adventure-works/ProductModelDescription' AS "PD")SELECT CatalogDescription.query('  /PD:ProductDescription/PD:Summary') as ResultFROM Production.ProductModelWHERE CatalogDescription.exist ('/PD:ProductDescription/PD:Features') = 1  
```  
  
 <span data-ttu-id="59fac-157">Hinsichtlich des primären XML-Indexes werden die einzelnen XML-BLOB-Instanzen in der Basistabelle nicht aufgeteilt, sondern die Zeilen in dem Index, der dem jeweiligen XML-BLOB entspricht, werden sequenziell nach dem in der `exist()` -Methode angegebenen Ausdruck durchsucht.</span><span class="sxs-lookup"><span data-stu-id="59fac-157">With regard to the primary XML index, instead of shredding each XML binary large object instance in the base table, the rows in the index that correspond to each XML binary large object are searched sequentially for the expression specified in the `exist()` method.</span></span> <span data-ttu-id="59fac-158">Wenn der Pfad in der Path-Spalte im Index gefunden wird, wird das <`Summary`>-Element mit seinen Unterstrukturen aus dem primären XML-Index abgerufen und in einen XML-BLOB als Ergebnis der `query()`-Methode konvertiert.</span><span class="sxs-lookup"><span data-stu-id="59fac-158">If the path is found in the Path column in the index, the <`Summary`> element together with its subtrees is retrieved from the primary XML index and converted into an XML binary large object as the result of the `query()` method.</span></span>  
  
 <span data-ttu-id="59fac-159">Beachten Sie, dass der primäre XML-Index beim Abrufen einer vollständigen XML-Instanz nicht verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="59fac-159">Note that the primary XML index is not used when retrieving a full XML instance.</span></span> <span data-ttu-id="59fac-160">Die folgende Abfrage ruft z. B. die gesamte XML-Instanz aus der Tabelle ab, die die Produktionsanweisungen für ein bestimmtes Produktmodell beschreibt.</span><span class="sxs-lookup"><span data-stu-id="59fac-160">For example, the following query retrieves from the table the whole XML instance that describes the manufacturing instructions for a specific product model.</span></span>  
  
```  
USE AdventureWorks2012;SELECT InstructionsFROM Production.ProductModel WHERE ProductModelID=7;  
```  
  
## <a name="secondary-xml-indexes"></a><span data-ttu-id="59fac-161">Sekundäre XML-Indizes</span><span class="sxs-lookup"><span data-stu-id="59fac-161">Secondary XML Indexes</span></span>  
 <span data-ttu-id="59fac-162">Wenn Sie die Suchleistung verbessern möchten, können Sie sekundäre XML-Indizes erstellen.</span><span class="sxs-lookup"><span data-stu-id="59fac-162">To enhance search performance, you can create secondary XML indexes.</span></span> <span data-ttu-id="59fac-163">Ein primärer XML-Index muss zuerst beendet werden, bevor Sie sekundäre Indizes erstellen können.</span><span class="sxs-lookup"><span data-stu-id="59fac-163">A primary XML index must first exist before you can create secondary indexes.</span></span> <span data-ttu-id="59fac-164">Die folgenden Typen werden unterschieden:</span><span class="sxs-lookup"><span data-stu-id="59fac-164">These are the types:</span></span>  
  
-   <span data-ttu-id="59fac-165">Sekundärer XML PATH-Index</span><span class="sxs-lookup"><span data-stu-id="59fac-165">PATH secondary XML index</span></span>  
  
-   <span data-ttu-id="59fac-166">Sekundärer XML VALUE-Index</span><span class="sxs-lookup"><span data-stu-id="59fac-166">VALUE secondary XML index</span></span>  
  
-   <span data-ttu-id="59fac-167">Sekundärer XML PROPERTY-Index</span><span class="sxs-lookup"><span data-stu-id="59fac-167">PROPERTY secondary XML index</span></span>  
  
 <span data-ttu-id="59fac-168">Es folgen einige Richtlinien zum Erstellen eines oder mehrerer sekundärer Indizes:</span><span class="sxs-lookup"><span data-stu-id="59fac-168">Following are some guidelines for creating one or more secondary indexes:</span></span>  
  
-   <span data-ttu-id="59fac-169">Wenn bei Ihrer Arbeitsauslastung im erheblichen Ausmaß Pfadausdrücke für XML-Spalten verwendet werden, führt der sekundäre XML-Index des Typs PATH wahrscheinlich zu einer Beschleunigung Ihrer Arbeitsauslastung.</span><span class="sxs-lookup"><span data-stu-id="59fac-169">If your workload uses path expressions significantly on XML columns, the PATH secondary XML index is likely to speed up your workload.</span></span> <span data-ttu-id="59fac-170">Der häufigste Fall ist das Verwenden der **exist()** -Methode für XML-Spalten in der WHERE-Klausel von Transact-SQL.</span><span class="sxs-lookup"><span data-stu-id="59fac-170">The most common case is the use of the **exist()** method on XML columns in the WHERE clause of Transact-SQL.</span></span>  
  
-   <span data-ttu-id="59fac-171">Wenn bei Ihrer Arbeitsauslastung mehrere Werte aus einzelnen XML-Instanzen mithilfe von Pfadausdrucken abgerufen werden, kann das Gruppieren der Pfade innerhalb jeder XML-Instanz im PROPERTY-Index nützlich sein.</span><span class="sxs-lookup"><span data-stu-id="59fac-171">If your workload retrieves multiple values from individual XML instances by using path expressions, clustering paths within each XML instance in the PROPERTY index may be helpful.</span></span> <span data-ttu-id="59fac-172">Diese Situation tritt üblicherweise in einem Eigenschaftsbehälterszenario auf, wenn die Eigenschaften eines Objekts abgerufen werden und dessen Primärschlüsselwert bekannt ist.</span><span class="sxs-lookup"><span data-stu-id="59fac-172">This scenario typically occurs in a property bag scenario when properties of an object are fetched and its primary key value is known.</span></span>  
  
-   <span data-ttu-id="59fac-173">Wenn bei Ihrer Arbeitsauslastung das Abfragen von Werten innerhalb von XML-Instanzen vorkommt, ohne dass dabei die Element- oder Attributnamen bekannt sind, die diese Werte enthalten, können Sie den VALUE-Index erstellen.</span><span class="sxs-lookup"><span data-stu-id="59fac-173">If your workload involves querying for values within XML instances without knowing the element or attribute names that contain those values, you may want to create the VALUE index.</span></span> <span data-ttu-id="59fac-174">Diese Situation kommt üblicherweise beim Durchsuchen von descendant-Achsen vor, z. B. bei //author[last-name="Howard"], wo die \<author>-Elemente in jeder beliebigen Ebene der Hierarchie auftreten können.</span><span class="sxs-lookup"><span data-stu-id="59fac-174">This typically occurs with descendant axes lookups, such as //author[last-name="Howard"], where \<author> elements can occur at any level of the hierarchy.</span></span> <span data-ttu-id="59fac-175">Sie kommt auch bei Abfragen mit Platzhaltern vor, z. B. bei /book [@\* = "novel"], wobei die Abfrage nach \<book>-Elementen sucht, die über ein beliebiges Attribut verfügen, das den Wert „novel“ aufweist.</span><span class="sxs-lookup"><span data-stu-id="59fac-175">It also occurs in wildcard queries, such as /book [@\* = "novel"], where the query looks for \<book> elements that have some attribute having the value "novel".</span></span>  
  
### <a name="path-secondary-xml-index"></a><span data-ttu-id="59fac-176">Sekundärer XML PATH-Index</span><span class="sxs-lookup"><span data-stu-id="59fac-176">PATH Secondary XML Index</span></span>  
 <span data-ttu-id="59fac-177">Wenn Ihre Abfragen im Allgemeinen path-Ausdrücke für Spalten des Typs `xml` angeben, beschleunigt ein sekundärer PATH-Index möglicherweise die Suche.</span><span class="sxs-lookup"><span data-stu-id="59fac-177">If your queries generally specify path expressions on `xml` type columns, a PATH secondary index may be able to speed up the search.</span></span> <span data-ttu-id="59fac-178">Wie bereits zuvor in diesem Thema beschrieben, ist der primäre Index hilfreich, wenn Sie Abfragen verwenden, die die **exist()** -Methode in der WHERE-Klausel angeben.</span><span class="sxs-lookup"><span data-stu-id="59fac-178">As described earlier in this topic, the primary index is helpful when you have queries that specify **exist()** method in the WHERE clause.</span></span> <span data-ttu-id="59fac-179">Wenn Sie einen sekundären PATH-Index hinzufügen, können Sie die Suchleistung in solchen Abfragen möglicherweise verbessern.</span><span class="sxs-lookup"><span data-stu-id="59fac-179">If you add a PATH secondary index, you may also improve the search performance in such queries.</span></span>  
  
 <span data-ttu-id="59fac-180">Zwar vermeidet ein primärer XML-Index das Aufteilen des XML-BLOBs zur Laufzeit, er bietet jedoch möglicherweise nicht die optimale Leistung für Abfragen, die auf path-Ausdrücken basieren.</span><span class="sxs-lookup"><span data-stu-id="59fac-180">Although a primary XML index avoids having to shred the XML binary large objects at run time, it may not provide the best performance for queries based on path expressions.</span></span> <span data-ttu-id="59fac-181">Da alle Zeilen im primären XML-Index, die einem XML-BLOB entsprechen, sequenziell nach großen XML-Instanzen durchsucht werden, kann diese sequenzielle Suche langsam sein.</span><span class="sxs-lookup"><span data-stu-id="59fac-181">Because all rows in the primary XML index corresponding to an XML binary large object are searched sequentially for large XML instances, the sequential search may be slow.</span></span> <span data-ttu-id="59fac-182">In diesem Fall kann ein sekundärer Index, der auf den Pfad- und Knotenwerten im primären Index aufbaut, die Indexsuche erheblich beschleunigen.</span><span class="sxs-lookup"><span data-stu-id="59fac-182">In this case, having a secondary index built on the path values and node values in the primary index can significantly speed up the index search.</span></span> <span data-ttu-id="59fac-183">Im sekundären PATH-Index sind die path- und node-Werte Schlüsselspalten, die effizientere Suchläufe beim Suchen nach Pfaden ermöglichen.</span><span class="sxs-lookup"><span data-stu-id="59fac-183">In the PATH secondary index, the path and node values are key columns that allow for more efficient seeks when searching for paths.</span></span> <span data-ttu-id="59fac-184">Der Abfrageoptimierer kann den PATH-Index für Ausdrücke wie die im folgenden Beispiel gezeigten verwenden:</span><span class="sxs-lookup"><span data-stu-id="59fac-184">The query optimizer may use the PATH index for expressions such as those shown in the following:</span></span>  
  
-   <span data-ttu-id="59fac-185">`/root/Location` ; gibt nur den Pfad an.</span><span class="sxs-lookup"><span data-stu-id="59fac-185">`/root/Location` which specify only a path</span></span>  
  
 <span data-ttu-id="59fac-186">oder</span><span class="sxs-lookup"><span data-stu-id="59fac-186">OR</span></span>  
  
-   <span data-ttu-id="59fac-187">`/root/Location/@LocationID[.="10"]` ; gibt den Pfad- und Knotenwert an.</span><span class="sxs-lookup"><span data-stu-id="59fac-187">`/root/Location/@LocationID[.="10"]` where both the path and the node value are specified.</span></span>  
  
 <span data-ttu-id="59fac-188">Die folgende Abfrage zeigt, in welchen Fällen der PATH-Index hilfreich ist:</span><span class="sxs-lookup"><span data-stu-id="59fac-188">The following query shows where the PATH index is helpful:</span></span>  
  
```  
WITH XMLNAMESPACES ('https://schemas.microsoft.com/sqlserver/2004/07/adventure-works/ProductModelDescription' AS "PD")  
  
SELECT CatalogDescription.query('  
  /PD:ProductDescription/PD:Summary  
') AS Result  
FROM Production.ProductModel  
WHERE CatalogDescription.exist ('/PD:ProductDescription/@ProductModelID[.="19"]') = 1  
```  
  
 <span data-ttu-id="59fac-189">In der Abfrage entsprechen der path-Ausdruck `/PD:ProductDescription/@ProductModelID` und der Wert `"19"` in der `exist()` -Methode den Schlüsselfeldern des PATH-Indexes.</span><span class="sxs-lookup"><span data-stu-id="59fac-189">In the query, the path expression `/PD:ProductDescription/@ProductModelID` and value `"19"` in the `exist()` method correspond to the key fields of the PATH index.</span></span> <span data-ttu-id="59fac-190">Auf diese Weise wird die direkte Suche im PATH-Index ermöglicht und eine bessere Suchleistung als bei einer sequenziellen Suche nach path-Werten im primären Index bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="59fac-190">This allows for direct seek in the PATH index and provides better search performance than the sequential search for path values in the primary index.</span></span>  
  
### <a name="value-secondary-xml-index"></a><span data-ttu-id="59fac-191">Sekundärer XML VALUE-Index</span><span class="sxs-lookup"><span data-stu-id="59fac-191">VALUE Secondary XML Index</span></span>  
 <span data-ttu-id="59fac-192">Wenn Abfragen wertbasiert sind, z.B. `/Root/ProductDescription/@*[. = "Mountain Bike"]` oder `//ProductDescription[@Name = "Mountain Bike"]`, und der Pfad nicht vollständig angegeben wird oder einen Platzhalter enthält, erzielen Sie möglicherweise schnellere Ergebnisse, indem Sie einen sekundären XML-Index erstellen, der auf Knotenwerten im primären XML-Index basiert.</span><span class="sxs-lookup"><span data-stu-id="59fac-192">If queries are value based, for example, `/Root/ProductDescription/@*[. = "Mountain Bike"]` or `//ProductDescription[@Name = "Mountain Bike"]`, and the path is not fully specified or it includes a wildcard, you might obtain faster results by building a secondary XML index that is built on node values in the primary XML index.</span></span>  
  
 <span data-ttu-id="59fac-193">Die Schlüsselspalten des VALUE-Indexes sind der Knotenwert und der Pfad des primären XML-Indexes.</span><span class="sxs-lookup"><span data-stu-id="59fac-193">The key columns of the VALUE index are (node value and path) of the primary XML index.</span></span> <span data-ttu-id="59fac-194">Wenn die Arbeitslast das Abfragen von Werten aus XML-Instanzen umfasst, ohne dass die Element- oder Attributnamen bekannt sind, die die Werte enthalten, kann der VALUE-Index hilfreich sein.</span><span class="sxs-lookup"><span data-stu-id="59fac-194">If your workload involves querying for values from XML instances without knowing the element or attribute names that contain the values, a VALUE index may be useful.</span></span> <span data-ttu-id="59fac-195">Der folgende Ausdruck profitiert z. B. vom Vorhandensein eines VALUE-Indexes:</span><span class="sxs-lookup"><span data-stu-id="59fac-195">For example, the following expression will benefit from having a VALUE index:</span></span>  
  
-   <span data-ttu-id="59fac-196">`//author[LastName="someName"]`, wobei der Wert des <`LastName`>-Elements bekannt ist, das übergeordnete <`author`>-Element jedoch an beliebiger Position auftreten kann.</span><span class="sxs-lookup"><span data-stu-id="59fac-196">`//author[LastName="someName"]` where you know the value of the <`LastName`> element, but the <`author`> parent can occur anywhere.</span></span>  
  
-   <span data-ttu-id="59fac-197">`/book[@* = "someValue"]`, wobei die Abfrage nach dem <`book`>-Element sucht, das ein Attribut mit dem Wert `"someValue"` aufweist.</span><span class="sxs-lookup"><span data-stu-id="59fac-197">`/book[@* = "someValue"]` where the query looks for the <`book`> element that has some attribute having the value `"someValue"`.</span></span>  
  
 <span data-ttu-id="59fac-198">Die folgende Abfrage gibt `ContactID` aus der `Contact` -Tabelle zurück.</span><span class="sxs-lookup"><span data-stu-id="59fac-198">The following query returns `ContactID` from the `Contact` table.</span></span> <span data-ttu-id="59fac-199">Die- `WHERE` Klausel gibt einen Filter an, der nach Werten in der `AdditionalContactInfo``xml` Type-Spalte sucht.</span><span class="sxs-lookup"><span data-stu-id="59fac-199">The `WHERE` clause specifies a filter that looks for values in the `AdditionalContactInfo``xml` type column.</span></span> <span data-ttu-id="59fac-200">Die Kontakt-IDs werden nur zurückgegeben, wenn der entsprechende XML-BLOB mit den zusätzlichen Kontaktinformationen eine bestimmte Rufnummer enthält.</span><span class="sxs-lookup"><span data-stu-id="59fac-200">The contact IDs are returned only if the corresponding additional contact information XML binary large object includes a specific telephone number.</span></span> <span data-ttu-id="59fac-201">Da das <`telephoneNumber`>-Element an beliebiger Position im XML auftreten kann, gibt der path-Ausdruck die descendant-or-self-Achse an.</span><span class="sxs-lookup"><span data-stu-id="59fac-201">Because the <`telephoneNumber`> element may appear anywhere in the XML, the path expression specifies the descendent-or-self axis.</span></span>  
  
```  
WITH XMLNAMESPACES (  
  'https://schemas.microsoft.com/sqlserver/2004/07/adventure-works/ContactInfo' AS CI,  
  'https://schemas.microsoft.com/sqlserver/2004/07/adventure-works/ContactTypes' AS ACT)  
  
SELECT ContactID   
FROM   Person.Contact  
WHERE  AdditionalContactInfo.exist('//ACT:telephoneNumber/ACT:number[.="111-111-1111"]') = 1  
```  
  
 <span data-ttu-id="59fac-202">In dieser Situation ist der Suchwert für <`number`> bekannt, kann jedoch an beliebiger Position in der XML-Instanz als untergeordnetes Element des <`telephoneNumber`>-Elements angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="59fac-202">In this situation, the search value for <`number`> is known, but it can appear anywhere in the XML instance as a child of the <`telephoneNumber`> element.</span></span> <span data-ttu-id="59fac-203">Diese Art der Abfrage kann möglicherweise von einer Indexsuche profitieren, die auf einem bestimmten Wert basiert.</span><span class="sxs-lookup"><span data-stu-id="59fac-203">This kind of query might benefit from an index lookup based on a specific value.</span></span>  
  
### <a name="property-secondary-index"></a><span data-ttu-id="59fac-204">Sekundärer PROPERTY-Index</span><span class="sxs-lookup"><span data-stu-id="59fac-204">PROPERTY Secondary Index</span></span>  
 <span data-ttu-id="59fac-205">Abfragen, die einen oder mehrere Werte aus einzelnen XML-Instanzen abrufen, können möglicherweise von einem PROPERTY-Index profitieren.</span><span class="sxs-lookup"><span data-stu-id="59fac-205">Queries that retrieve one or more values from individual XML instances might benefit from a PROPERTY index.</span></span> <span data-ttu-id="59fac-206">Dieses Szenario tritt auf, wenn Sie Objekteigenschaften mithilfe der **value ()** -Methode des `xml` -Typs abrufen und wenn der Primärschlüssel Wert des-Objekts bekannt ist.</span><span class="sxs-lookup"><span data-stu-id="59fac-206">This scenario occurs when you retrieve object properties by using the **value()** method of the `xml` type and when the primary key value of the object is known.</span></span>  
  
 <span data-ttu-id="59fac-207">Der PROPERTY-Index basiert auf Spalten (PK, Pfad- und Knotenwert) des primären XML-Indexes, wobei PK der Primärschlüssel der Basistabelle ist.</span><span class="sxs-lookup"><span data-stu-id="59fac-207">The PROPERTY index is built on columns (PK, Path and node value) of the primary XML index where PK is the primary key of the base table.</span></span>  
  
 <span data-ttu-id="59fac-208">Die folgende Abfrage ruft z. B. für Produktmodell `19`die folgenden `ProductModelID` - und `ProductModelName` -Attributwerte mithilfe der `value()` -Methode ab.</span><span class="sxs-lookup"><span data-stu-id="59fac-208">For example, for product model `19`, the following query retrieves the `ProductModelID` and `ProductModelName` attribute values using the `value()` method.</span></span> <span data-ttu-id="59fac-209">Der PROPERTY-Index kann eine schnellere Ausführung als die Verwendung des primären XML-Indexes oder der anderen sekundären XML-Indizes bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="59fac-209">Instead of using the primary XML index or the other secondary XML indexes, the PROPERTY index may provide faster execution.</span></span>  
  
```  
WITH XMLNAMESPACES ('https://schemas.microsoft.com/sqlserver/2004/07/adventure-works/ProductModelDescription' AS "PD")  
  
SELECT CatalogDescription.value('(/PD:ProductDescription/@ProductModelID)[1]', 'int') as ModelID,  
       CatalogDescription.value('(/PD:ProductDescription/@ProductModelName)[1]', 'varchar(30)') as ModelName          
FROM Production.ProductModel     
WHERE ProductModelID = 19  
```  
  
 <span data-ttu-id="59fac-210">Mit Ausnahme der Unterschiede, die weiter unten in diesem Thema beschrieben werden, ähnelt das Erstellen eines XML-Indexes für eine `xml` Typspalte dem Erstellen eines Indexes für eine Spalte, die nicht `xml` vom Typ ist.</span><span class="sxs-lookup"><span data-stu-id="59fac-210">Except for the differences described later in this topic, creating an XML index on an`xml` type column is similar to creating an index on a non-`xml` type column.</span></span> <span data-ttu-id="59fac-211">Die folgenden [!INCLUDE[tsql](../../includes/tsql-md.md)] -DDL-Anweisungen können zum Erstellen und Verwalten von XML-Indizes verwendet werden:</span><span class="sxs-lookup"><span data-stu-id="59fac-211">The following [!INCLUDE[tsql](../../includes/tsql-md.md)] DDL statements can be used to create and manage XML indexes:</span></span>  
  
-   [<span data-ttu-id="59fac-212">CREATE INDEX &#40;Transact-SQL&#41;</span><span class="sxs-lookup"><span data-stu-id="59fac-212">CREATE INDEX &#40;Transact-SQL&#41;</span></span>](/sql/t-sql/statements/create-index-transact-sql)  
  
-   [<span data-ttu-id="59fac-213">ALTER INDEX &#40;Transact-SQL&#41;</span><span class="sxs-lookup"><span data-stu-id="59fac-213">ALTER INDEX &#40;Transact-SQL&#41;</span></span>](/sql/t-sql/statements/alter-index-transact-sql)  
  
-   [<span data-ttu-id="59fac-214">DROP INDEX &#40;Transact-SQL&#41;</span><span class="sxs-lookup"><span data-stu-id="59fac-214">DROP INDEX &#40;Transact-SQL&#41;</span></span>](/sql/t-sql/statements/drop-index-transact-sql)  
  
## <a name="getting-information-about-xml-indexes"></a><span data-ttu-id="59fac-215">Abrufen von Informationen zu XML-Indizes</span><span class="sxs-lookup"><span data-stu-id="59fac-215">Getting Information about XML Indexes</span></span>  
 <span data-ttu-id="59fac-216">XML-Indexeinträge erscheinen in der Katalogsicht sys.indexes, wobei der Index den "Typ" 3 besitzt</span><span class="sxs-lookup"><span data-stu-id="59fac-216">XML index entries appear in the catalog view, sys.indexes, with the index "type" 3.</span></span> <span data-ttu-id="59fac-217">Die Namensspalte enthält den Namen des XML-Index.</span><span class="sxs-lookup"><span data-stu-id="59fac-217">The name column contains the name of the XML index.</span></span>  
  
 <span data-ttu-id="59fac-218">XML-Indizes sind auch in der Katalogsicht sys.xml_indexes aufgezeichnet.</span><span class="sxs-lookup"><span data-stu-id="59fac-218">XML indexes are also recorded in the catalog view, sys.xml_indexes.</span></span> <span data-ttu-id="59fac-219">Diese enthält alle Spalten von sys.indexes und einige spezielle Spalten, die für XML-Indizes nützlich sind.</span><span class="sxs-lookup"><span data-stu-id="59fac-219">This contains all the columns of sys.indexes and some specific ones that are useful for XML indexes.</span></span> <span data-ttu-id="59fac-220">Der Wert NULL in der Spalte secondary_type zeigt einen primären XML-Index an; die Werte 'P', 'R' und 'V' stehen für sekundäre PATH-, PROPERTY- bzw. VALUE-XML-Indizes.</span><span class="sxs-lookup"><span data-stu-id="59fac-220">The value NULL in the column, secondary_type, indicates a primary XML index; the values 'P', 'R' and 'V' stand for PATH, PROPERTY, and VALUE secondary XML indexes, respectively.</span></span>  
  
 <span data-ttu-id="59fac-221">Der von XML-Indizes verwendete Speicherplatz kann in der Tabellenwertfunktion [sys.dm_db_index_physical_stats](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql)gefunden werden.</span><span class="sxs-lookup"><span data-stu-id="59fac-221">The space use of XML indexes can be found in the table-valued function [sys.dm_db_index_physical_stats](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql).</span></span> <span data-ttu-id="59fac-222">Sie stellt für alle Indextypen Informationen bereit, wie z. B. zur Anzahl der belegten Datenträgerseiten, zur durchschnittlichen Zeilengröße in Byte und zur Anzahl der Datensätze.</span><span class="sxs-lookup"><span data-stu-id="59fac-222">It provides information, such as the number of disk pages occupied, average row size in bytes, and number of records, for all index types..</span></span> <span data-ttu-id="59fac-223">Dieses schließt auch XML-Indizes ein.</span><span class="sxs-lookup"><span data-stu-id="59fac-223">This also includes XML indexes.</span></span> <span data-ttu-id="59fac-224">Diese Informationen sind für jede Datenbankpartition verfügbar.</span><span class="sxs-lookup"><span data-stu-id="59fac-224">This information is available for each database partition.</span></span> <span data-ttu-id="59fac-225">XML-Indizes verwenden das Partitionierungsschema und die Partitionierungsfunktion der Basistabelle.</span><span class="sxs-lookup"><span data-stu-id="59fac-225">XML indexes use the same partitioning scheme and partitioning function of the base table.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="59fac-226">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="59fac-226">See Also</span></span>  
 <span data-ttu-id="59fac-227">[sys.dm_db_index_physical_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql) </span><span class="sxs-lookup"><span data-stu-id="59fac-227">[sys.dm_db_index_physical_stats &#40;Transact-SQL&#41;](/sql/relational-databases/system-dynamic-management-views/sys-dm-db-index-physical-stats-transact-sql) </span></span>  
 [<span data-ttu-id="59fac-228">XML-Daten &#40;SQL Server&#41;</span><span class="sxs-lookup"><span data-stu-id="59fac-228">XML Data &#40;SQL Server&#41;</span></span>](../xml/xml-data-sql-server.md)  
  
  
