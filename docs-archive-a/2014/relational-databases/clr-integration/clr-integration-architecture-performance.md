---
title: Leistung der CLR-Integration | Microsoft-Dokumentation
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: clr
ms.topic: reference
helpviewer_keywords:
- common language runtime [SQL Server], performance
- common language runtime [SQL Server], compilation process
- performance [CLR integration]
ms.assetid: 7ce2dfc0-4b1f-4dcb-a979-2c4f95b4cb15
author: rothja
ms.author: jroth
ms.openlocfilehash: 33e45039ed98ea3df607df1714b3c6108ec17c35
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/04/2020
ms.locfileid: "87720020"
---
# <a name="performance-of-clr-integration"></a><span data-ttu-id="40e29-102">Leistungsfähigkeit der CLR-Integration</span><span class="sxs-lookup"><span data-stu-id="40e29-102">Performance of CLR Integration</span></span>
  <span data-ttu-id="40e29-103">In diesem Thema werden einige der Entwurfs Optionen erläutert, die die Leistung der [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] Integration in die [!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework Common Language Runtime (CLR) verbessern.</span><span class="sxs-lookup"><span data-stu-id="40e29-103">This topic discusses some of the design choices that enhance the performance of [!INCLUDE[msCoName](../../../includes/msconame-md.md)] [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] integration with the [!INCLUDE[msCoName](../../../includes/msconame-md.md)] .NET Framework common language runtime (CLR).</span></span>  
  
## <a name="the-compilation-process"></a><span data-ttu-id="40e29-104">Der Kompilierungsprozess</span><span class="sxs-lookup"><span data-stu-id="40e29-104">The Compilation Process</span></span>  
 <span data-ttu-id="40e29-105">Wenn während der Kompilierung von SQL-Ausdrücken ein Verweis auf eine verwaltete Routine gefunden wird, wird ein [!INCLUDE[msCoName](../../../includes/msconame-md.md)] Intermediate Language (MSIL)-Stub generiert.</span><span class="sxs-lookup"><span data-stu-id="40e29-105">During compilation of SQL expressions, when a reference to a managed routine is encountered, a [!INCLUDE[msCoName](../../../includes/msconame-md.md)] intermediate language (MSIL) stub is generated.</span></span> <span data-ttu-id="40e29-106">Dieser Stub enthält Code zum Marshallen der Routineparameter von [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] zu CLR, zum Aufrufen der Funktion und zur Rückgabe des Ergebnisses.</span><span class="sxs-lookup"><span data-stu-id="40e29-106">This stub includes code to marshal the routine parameters from [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] to the CLR, invoke the function, and return the result.</span></span> <span data-ttu-id="40e29-107">Dieser "Verbindungscode" basiert auf dem Parametertyp und der Parameterrichtung (IN, OUT oder Verweis).</span><span class="sxs-lookup"><span data-stu-id="40e29-107">This "glue" code is based on the type of parameter and on parameter direction (in, out, or reference).</span></span>  
  
 <span data-ttu-id="40e29-108">Der Verbindungscode ermöglicht typspezifische Optimierungen und stellt die wirksame Durchsetzung der [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]-Semantik sicher, wie beispielsweise NULL-Zulässigkeit, Einschränkungsfacets, Nach-Wert-Verarbeitung und standardmäßige Ausnahmebehandlung.</span><span class="sxs-lookup"><span data-stu-id="40e29-108">The glue code enables type-specific optimizations and ensures efficient enforcement of [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] semantics, such as nullability, constraining facets, by-value, and standard exception handling.</span></span> <span data-ttu-id="40e29-109">Durch die Codegenerierung für genaue Argumenttypen vermeiden Sie Kosten für Typenumwandlung und die Erstellung von Wrapperobjekten ("Boxing" genannt) über die Aufrufgrenze hinweg.</span><span class="sxs-lookup"><span data-stu-id="40e29-109">By generating code for the exact types of the arguments, you avoid type coercion or wrapper object creation costs (called "boxing") across the invocation boundary.</span></span>  
  
 <span data-ttu-id="40e29-110">Der generierte Stub wird dann mithilfe des Just-in-Time(JIT)-Kompilierungsdiensts von CLR in systemeigenen Code kompiliert und für die spezifische Hardwarearchitektur, in der [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] ausgeführt wird, optimiert.</span><span class="sxs-lookup"><span data-stu-id="40e29-110">The generated stub is then compiled to native code and optimized for the particular hardware architecture on which [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] executes, using the JIT (just-in-time) compilation services of the CLR.</span></span> <span data-ttu-id="40e29-111">Die JIT-Dienste werden auf Methodenebene aufgerufen und ermöglichen es der [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]-Hostumgebung, eine einheitliche Kompilierungseinheit zu erstellen, die sowohl [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] als auch die CLR-Ausführung beinhaltet.</span><span class="sxs-lookup"><span data-stu-id="40e29-111">The JIT services are invoked at the method level and allow the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] hosting environment to create a single compilation unit that spans both [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and CLR execution.</span></span> <span data-ttu-id="40e29-112">Sobald der Stub kompiliert ist, wird der resultierende Funktionszeiger zur Laufzeitimplementierung der Funktion.</span><span class="sxs-lookup"><span data-stu-id="40e29-112">Once the stub is compiled, the resulting function pointer becomes the run-time implementation of the function.</span></span> <span data-ttu-id="40e29-113">Dieses Codegenerierungsverfahren stellt sicher, dass keine zusätzlichen Aufrufkosten durch Reflexion oder Metadatenzugriff zur Laufzeit entstehen.</span><span class="sxs-lookup"><span data-stu-id="40e29-113">This code generation approach ensures that there are no additional invocation costs related to reflection or metadata access at run time.</span></span>  
  
### <a name="fast-transitions-between-sql-server-and-clr"></a><span data-ttu-id="40e29-114">Schnelle Übergänge zwischen SQL Server und CLR</span><span class="sxs-lookup"><span data-stu-id="40e29-114">Fast Transitions Between SQL Server and CLR</span></span>  
 <span data-ttu-id="40e29-115">Der Kompilierungsprozess erzeugt einen Funktionszeiger, der zur Laufzeit über systemeigenen Code aufgerufen werden kann.</span><span class="sxs-lookup"><span data-stu-id="40e29-115">The compilation process yields a function pointer that can be called at run time from native code.</span></span> <span data-ttu-id="40e29-116">Bei benutzerdefinierten Skalarwertfunktionen erfolgt dieser Funktionsaufruf auf Zeilenbasis.</span><span class="sxs-lookup"><span data-stu-id="40e29-116">In the case of scalar-valued user-defined functions, this function invocation happens on a per-row basis.</span></span> <span data-ttu-id="40e29-117">Um die Kosten für den Übergang zwischen [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] und CLR zu minimieren, verfügen Anweisungen, die verwaltete Aufrufe beinhalten, über einen Startschritt zur Identifizierung der Zielanwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="40e29-117">To minimize the cost of transitioning between [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and the CLR, statements that contain any managed invocation have a startup step to identify the target application domain.</span></span> <span data-ttu-id="40e29-118">Dieser Identifizierungsschritt reduziert die Kosten für den Übergang der einzelnen Zeilen.</span><span class="sxs-lookup"><span data-stu-id="40e29-118">This identification step reduces the cost of transitioning for each row.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="40e29-119">Überlegungen zur Leistung</span><span class="sxs-lookup"><span data-stu-id="40e29-119">Performance Considerations</span></span>  
 <span data-ttu-id="40e29-120">Im Folgenden werden Informationen über Leistungsaspekte in Bezug auf die CLR-Integration in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] gegeben.</span><span class="sxs-lookup"><span data-stu-id="40e29-120">The following summarizes performance considerations specific to CLR integration in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="40e29-121">Ausführlichere Informationen finden Sie unter "[Verwenden der CLR-Integration in SQL Server 2005](https://go.microsoft.com/fwlink/?LinkId=50332)" auf der MSDN-Website.</span><span class="sxs-lookup"><span data-stu-id="40e29-121">More detailed information can be found in "[Using CLR Integration in SQL Server 2005](https://go.microsoft.com/fwlink/?LinkId=50332)" on the MSDN Web site.</span></span> <span data-ttu-id="40e29-122">Allgemeine Informationen zur Leistung von verwaltetem Code finden Sie auf der MSDN-Website unter "[verbessern der Leistung und Skalierbarkeit von .NET-Anwendungen](https://go.microsoft.com/fwlink/?LinkId=50333)".</span><span class="sxs-lookup"><span data-stu-id="40e29-122">General information regarding managed code performance can be found in "[Improving .NET Application Performance and Scalability](https://go.microsoft.com/fwlink/?LinkId=50333)" on the MSDN Web site.</span></span>  
  
### <a name="user-defined-functions"></a><span data-ttu-id="40e29-123">Benutzerdefinierte Funktionen</span><span class="sxs-lookup"><span data-stu-id="40e29-123">User-Defined Functions</span></span>  
 <span data-ttu-id="40e29-124">CLR-Funktionen profitieren im Vergleich zu benutzerdefinierten [!INCLUDE[tsql](../../../includes/tsql-md.md)]-Funktionen von einem schnelleren Aufrufpfad.</span><span class="sxs-lookup"><span data-stu-id="40e29-124">CLR functions benefit from a quicker invocation path than that of [!INCLUDE[tsql](../../../includes/tsql-md.md)] user-defined functions.</span></span> <span data-ttu-id="40e29-125">Zudem bietet verwalteter Code im Vergleich zu [!INCLUDE[tsql](../../../includes/tsql-md.md)] deutliche Leistungsvorteile in Bezug auf den prozeduralen Code, die Berechnung und die Zeichenfolgenbearbeitung.</span><span class="sxs-lookup"><span data-stu-id="40e29-125">Additionally, managed code has a decisive performance advantage over [!INCLUDE[tsql](../../../includes/tsql-md.md)] in terms of procedural code, computation, and string manipulation.</span></span> <span data-ttu-id="40e29-126">Rechenintensive CLR-Funktionen, die keinen Datenzugriff ausführen, sollten bevorzugt in verwaltetem Code geschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="40e29-126">CLR functions that are computing-intensive and that do not perform data access are better written in managed code.</span></span> [!INCLUDE[tsql](../../../includes/tsql-md.md)]<span data-ttu-id="40e29-127">-Funktionen führen Datenzugriffe jedoch effizienter aus als die CLR-Integration.</span><span class="sxs-lookup"><span data-stu-id="40e29-127">functions do, however, perform data access more efficiently than CLR integration.</span></span>  
  
### <a name="user-defined-aggregates"></a><span data-ttu-id="40e29-128">Benutzerdefinierte Aggregate</span><span class="sxs-lookup"><span data-stu-id="40e29-128">User-Defined Aggregates</span></span>  
 <span data-ttu-id="40e29-129">Verwalteter Code ist deutlich leistungsfähiger als die cursorbasierte Aggregation.</span><span class="sxs-lookup"><span data-stu-id="40e29-129">Managed code can significantly outperform cursor-based aggregation.</span></span> <span data-ttu-id="40e29-130">Verwalteter Code ist in der Regel etwas langsamer als integrierte [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]-Aggregatfunktionen.</span><span class="sxs-lookup"><span data-stu-id="40e29-130">Managed code generally performs slightly slower than built-in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] aggregate functions.</span></span> <span data-ttu-id="40e29-131">Wir empfehlen daher, eine systemeigene integrierte Aggregatfunktion zu verwenden, sofern sie zur Verfügung steht.</span><span class="sxs-lookup"><span data-stu-id="40e29-131">We recommend that if a native built-in aggregate function exists, you should use it.</span></span> <span data-ttu-id="40e29-132">In Fällen, in denen die benötigte Aggregation nicht vom System unterstützt wird, sollten Sie aus Gründen der Leistungsfähigkeit ein CLR-benutzerdefiniertes Aggregat einer cursorbasierten Implementierung den Vorzug geben.</span><span class="sxs-lookup"><span data-stu-id="40e29-132">In cases in which the needed aggregation is not natively supported, consider a CLR user-defined aggregate over a cursor-based implementation for performance reasons.</span></span>  
  
### <a name="streaming-table-valued-functions"></a><span data-ttu-id="40e29-133">Streaming-Tabellenwertfunktionen</span><span class="sxs-lookup"><span data-stu-id="40e29-133">Streaming Table-Valued Functions</span></span>  
 <span data-ttu-id="40e29-134">Anwendungen müssen oft als Reaktion auf einen Funktionsaufruf eine Tabelle als Ergebnis zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="40e29-134">Applications often need to return a table as a result of invoking a function.</span></span> <span data-ttu-id="40e29-135">Beispiele dafür sind das Lesen von Tabellendaten aus einer Datei als Teil eines Importvorgangs oder die Konvertierung von durch Trennzeichen getrennten Werte in eine relationale Darstellung.</span><span class="sxs-lookup"><span data-stu-id="40e29-135">Examples include reading tabular data from a file as part of an import operation, and converting comma-separated-values to a relational representation.</span></span> <span data-ttu-id="40e29-136">In der Regel erreichen Sie dies durch Materialisieren und Auffüllen der Ergebnistabelle, bevor sie vom Aufrufer verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="40e29-136">Typically, you can accomplish this by materializing and populating the result table before it can be consumed by the caller.</span></span> <span data-ttu-id="40e29-137">Mit der Integration von CLR in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] wird ein neuer Erweiterungsmechanismus eingeführt, der als Streaming-Tabellenwertfunktion (STVF) bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="40e29-137">The integration of the CLR into [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] introduces a new extensibility mechanism called a streaming table-valued function (STVF).</span></span> <span data-ttu-id="40e29-138">Verwaltete STVF sind leistungsfähiger als vergleichbare Implementierungen mit erweiterten gespeicherten Prozeduren.</span><span class="sxs-lookup"><span data-stu-id="40e29-138">Managed STVFs perform better than comparable extended stored procedure implementations.</span></span>  
  
 <span data-ttu-id="40e29-139">STVFs sind verwaltete Funktionen, die eine `IEnumerable`-Schnittstelle zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="40e29-139">STVFs are managed functions that return an `IEnumerable` interface.</span></span> <span data-ttu-id="40e29-140">`IEnumerable` verfügt über Methoden, um in von STVF zurückgegebenen Resultsets zu navigieren.</span><span class="sxs-lookup"><span data-stu-id="40e29-140">`IEnumerable` has methods to navigate the result set returned by the STVF.</span></span> <span data-ttu-id="40e29-141">Wenn die STVF aufgerufen wird, wird die zurückgegebene `IEnumerable`-Schnittstelle direkt mit dem Abfrageplan verbunden.</span><span class="sxs-lookup"><span data-stu-id="40e29-141">When the STVF is invoked, the returned `IEnumerable` is directly connected to the query plan.</span></span> <span data-ttu-id="40e29-142">Der Abfrageplan ruft `IEnumerable`-Methoden auf, wenn er Zeilen abrufen muss.</span><span class="sxs-lookup"><span data-stu-id="40e29-142">The query plan calls `IEnumerable` methods when it needs to fetch rows.</span></span> <span data-ttu-id="40e29-143">Dieses Iterationsmodell ermöglicht es, dass Ergebnisse sofort nach Abruf der ersten Zeile verarbeitet werden. Es muss nicht gewartet werden, bis die gesamte Tabelle aufgefüllt ist.</span><span class="sxs-lookup"><span data-stu-id="40e29-143">This iteration model allows results to be consumed immediately after the first row is produced, instead of waiting until the entire table is populated.</span></span> <span data-ttu-id="40e29-144">Dadurch wird zudem der durch den Funktionsaufruf benötigte Arbeitsspeicher stark reduziert.</span><span class="sxs-lookup"><span data-stu-id="40e29-144">It also significantly reduces the memory consumed by invoking the function.</span></span>  
  
### <a name="arrays-vs-cursors"></a><span data-ttu-id="40e29-145">Arrays oder Cursor</span><span class="sxs-lookup"><span data-stu-id="40e29-145">Arrays vs. Cursors</span></span>  
 <span data-ttu-id="40e29-146">Wenn [!INCLUDE[tsql](../../../includes/tsql-md.md)]-Cursor Daten traversieren müssen, die als Array einfacher auszudrücken sind, kann verwalteter Code verwendet und die Leistung dadurch gesteigert werden.</span><span class="sxs-lookup"><span data-stu-id="40e29-146">When [!INCLUDE[tsql](../../../includes/tsql-md.md)] cursors must traverse data that is more easily expressed as an array, managed code can be used with significant performance gains.</span></span>  
  
### <a name="string-data"></a><span data-ttu-id="40e29-147">Zeichenfolgendaten</span><span class="sxs-lookup"><span data-stu-id="40e29-147">String Data</span></span>  
 [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="40e29-148">Zeichendaten, wie z. B. `varchar`, können in verwalteten Funktionen vom Typ SqlString oder SqlChars sein.</span><span class="sxs-lookup"><span data-stu-id="40e29-148">character data, such as `varchar`, can be of the type SqlString or SqlChars in managed functions.</span></span> <span data-ttu-id="40e29-149">SqlString-Variablen erstellen im Arbeitsspeicher eine Instanz des gesamten Werts.</span><span class="sxs-lookup"><span data-stu-id="40e29-149">SqlString variables create an instance of the entire value into memory.</span></span> <span data-ttu-id="40e29-150">SqlChars-Variablen stellen eine Streamingschnittstelle bereit, mit der eine höhere Leistung und bessere Skalierbarkeit erreicht wird, die jedoch nicht zum Erstellen einer Instanz des gesamten Werts im Arbeitsspeicher verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="40e29-150">SqlChars variables provide a streaming interface that can be used to achieve better performance and scalability by not creating an instance of the entire value into memory.</span></span> <span data-ttu-id="40e29-151">Dies ist besonders für Daten großer Objekte (Large Objects, LOB) wichtig.</span><span class="sxs-lookup"><span data-stu-id="40e29-151">This becomes particularly important for large object (LOB) data.</span></span> <span data-ttu-id="40e29-152">Darüber hinaus kann über eine von `SqlXml.CreateReader()` zurückgegebene Streamingschnittstelle auf XML-Serverdaten zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="40e29-152">Additionally, server XML data can be accessed through a streaming interface returned by `SqlXml.CreateReader()`.</span></span>  
  
### <a name="clr-vs-extended-stored-procedures"></a><span data-ttu-id="40e29-153">CLR und erweiterte gespeicherte Prozeduren im Vergleich</span><span class="sxs-lookup"><span data-stu-id="40e29-153">CLR vs. Extended Stored Procedures</span></span>  
 <span data-ttu-id="40e29-154">Die Microsoft.SqlServer.Server-APIs (Application Programming Interfaces), die es verwalteten Prozeduren ermöglichen, Resultsets zurück an den Client zu senden, sind leistungsfähiger als die von erweiterten gespeicherten Prozeduren verwendeten Open Data Services(ODS)-APIs.</span><span class="sxs-lookup"><span data-stu-id="40e29-154">The Microsoft.SqlServer.Server application programming interfaces (APIs) that allow managed procedures to send result sets back to the client perform better than the Open Data Services (ODS) APIs used by extended stored procedures.</span></span> <span data-ttu-id="40e29-155">Darüber hinaus unterstützen die System.Data.SqlServer-APIs Datentypen wie `xml`, `varchar(max)`, `nvarchar(max)` und `varbinary(max)`, die in [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)] eingeführt wurden, während ODS-APIs nicht für die Unterstützung der neuen Datentypen erweitert wurden.</span><span class="sxs-lookup"><span data-stu-id="40e29-155">Furthermore, the System.Data.SqlServer APIs support data types such as `xml`, `varchar(max)`, `nvarchar(max)`, and `varbinary(max)`, introduced in [!INCLUDE[ssVersion2005](../../../includes/ssversion2005-md.md)], while the ODS APIs have not been extended to support the new data types.</span></span>  
  
 <span data-ttu-id="40e29-156">Mit verwaltetem Code verwaltet [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] die Verwendung von Ressourcen wie beispielsweise Arbeitsspeicher, Threads und Synchronisierung.</span><span class="sxs-lookup"><span data-stu-id="40e29-156">With managed code, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] manages use of resources such as memory, threads, and synchronization.</span></span> <span data-ttu-id="40e29-157">Das rührt daher, dass die verwalteten APIs, die diese Ressourcen verfügbar machen, auf dem [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)]-Ressourcen-Manager implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="40e29-157">This is because the managed APIs that expose these resources are implemented on top of the [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] resource manager.</span></span> <span data-ttu-id="40e29-158">Hingegen verfügt [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] über keine Sicht für oder Kontrolle über die Ressourcenverwendung der erweiterten gespeicherten Prozedur.</span><span class="sxs-lookup"><span data-stu-id="40e29-158">Conversely, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] has no view or control over the resource usage of the extended stored procedure.</span></span> <span data-ttu-id="40e29-159">Wenn eine erweiterte gespeicherte Prozedur beispielsweise zu viel CPU- oder Speicherressourcen belegt, gibt es keine Möglichkeit, dies mit [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] zu erkennen oder zu kontrollieren.</span><span class="sxs-lookup"><span data-stu-id="40e29-159">For example, if an extended stored procedure consumes too much CPU or memory resources, there is no way to detect or control this with [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="40e29-160">Mit verwaltetem Code kann [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] hingegen erkennen, dass ein bestimmter Thread längere Zeit nicht aktiv war, und dann die Ausführung des Tasks erzwingen, damit andere Arbeit geplant werden kann.</span><span class="sxs-lookup"><span data-stu-id="40e29-160">With managed code, however, [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] can detect that a given thread has not yielded for a long period of time, and then force the task to yield so that other work can be scheduled.</span></span> <span data-ttu-id="40e29-161">Infolgedessen kann mit verwaltetem Code eine bessere Skalierbarkeit und Systemressourcenverwendung erreicht werden.</span><span class="sxs-lookup"><span data-stu-id="40e29-161">Consequently, using managed code provides for better scalability and system resource usage.</span></span>  
  
 <span data-ttu-id="40e29-162">Durch verwalteten Code können möglicherweise zusätzliche Kosten für die Aufrechterhaltung der Ausführungsumgebung sowie die Durchführung von Sicherheitsüberprüfungen entstehen.</span><span class="sxs-lookup"><span data-stu-id="40e29-162">Managed code may incur additional overhead necessary to maintain the execution environment and perform security checks.</span></span> <span data-ttu-id="40e29-163">Das ist beispielsweise dann der Fall, wenn die Ausführung in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] erfolgt und zahlreiche Übergänge von verwaltetem zu systemeigenem Code erforderlich sind (denn [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] muss für threadspezifische Einstellungen beim Übergang in systemeigenen Code und zurück zusätzlichen Wartungsaufwand betreiben).</span><span class="sxs-lookup"><span data-stu-id="40e29-163">This is the case, for example, when running inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] and numerous transitions from managed to native code are required (because [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] needs to do additional maintenance on thread-specific settings when moving out to native code and back).</span></span> <span data-ttu-id="40e29-164">Folglich können erweiterte gespeicherte Prozeduren die Leistung im Vergleich zu verwaltetem Code, der in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] ausgeführt wird, unter Umständen deutlich erhöhen, nämlich in Situationen mit häufigen Übergängen zwischen verwaltetem und systemeigenem Code.</span><span class="sxs-lookup"><span data-stu-id="40e29-164">Consequently, extended stored procedures can significantly outperform managed code running inside [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] for cases in which there are frequent transitions between managed and native code.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="40e29-165">Es wird jedoch empfohlen, keine neuen erweiterten gespeicherten Prozeduren zu entwickeln, da diese Funktion veraltet ist.</span><span class="sxs-lookup"><span data-stu-id="40e29-165">It is recommended that you do not develop new extended stored procedures, because this feature has been deprecated.</span></span>  
  
### <a name="native-serialization-for-user-defined-types"></a><span data-ttu-id="40e29-166">Systemeigene Serialisierung für benutzerdefinierte Typen</span><span class="sxs-lookup"><span data-stu-id="40e29-166">Native Serialization for User-Defined Types</span></span>  
 <span data-ttu-id="40e29-167">Benutzerdefinierte Typen (UDTs) wurden als Erweiterungsmechanismus für das Skalartypsystem entworfen.</span><span class="sxs-lookup"><span data-stu-id="40e29-167">User-defined types (UDTs) are designed as an extensibility mechanism for the scalar type system.</span></span> [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] <span data-ttu-id="40e29-168">implementiert für UDTs ein Serialisierungsformat mit der Bezeichnung `Format.Native`.</span><span class="sxs-lookup"><span data-stu-id="40e29-168">implements a serialization format for UDTs called `Format.Native`.</span></span> <span data-ttu-id="40e29-169">Während der Kompilierung wird die Struktur des Typs zur Generierung von MSIL geprüft, das für die betreffende Typdefinition angepasst wird.</span><span class="sxs-lookup"><span data-stu-id="40e29-169">During compilation, the structure of the type is examined to generate MSIL that is customized for that particular type definition.</span></span>  
  
 <span data-ttu-id="40e29-170">Die systemeigene Serialisierung ist die Standardimplementierung für [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="40e29-170">Native serialization is the default implementation for [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="40e29-171">Die benutzerdefinierte Serialisierung ruft eine Methode auf, die vom Typautor für die Durchführung der Serialisierung definiert wurde.</span><span class="sxs-lookup"><span data-stu-id="40e29-171">User-defined serialization invokes a method defined by the type author to do the serialization.</span></span> <span data-ttu-id="40e29-172">Für eine optimale Leistung sollte, sofern möglich, die `Format.Native`-Serialisierung verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="40e29-172">`Format.Native` serialization should be used when possible for best performance.</span></span>  
  
### <a name="normalization-of-comparable-udts"></a><span data-ttu-id="40e29-173">Normalisierung vergleichbarer UDTs</span><span class="sxs-lookup"><span data-stu-id="40e29-173">Normalization of Comparable UDTs</span></span>  
 <span data-ttu-id="40e29-174">Relationale Vorgänge, z. B. die Sortierung und das Vergleichen von UDTs, verwenden direkt die binäre Darstellung des Werts.</span><span class="sxs-lookup"><span data-stu-id="40e29-174">Relational operations, such as sorting and comparing UDTs, operate directly on the binary representation of the value.</span></span> <span data-ttu-id="40e29-175">Zu diesem Zweck wird eine normalisierte (binär sortierte) Darstellung des UDT-Zustands auf Festplatte gespeichert.</span><span class="sxs-lookup"><span data-stu-id="40e29-175">This is accomplished by storing a normalized (binary ordered) representation of the state of the UDT on disk.</span></span>  
  
 <span data-ttu-id="40e29-176">Normalisierungen bieten zwei Vorteile: Erstens verringern sie den Arbeitsaufwand für den Vergleich erheblich, indem sie die Konstruktion der Typinstanz und die Kosten für den Methodenaufruf vermeiden. Zweitens erstellen sie eine binäre Domäne für den UDT und ermöglichen so die Konstruktion von Histogrammen, Indizes und Histogrammen für Werte des Typs.</span><span class="sxs-lookup"><span data-stu-id="40e29-176">Normalization has two benefits: it makes the comparison operation considerably less expensive by avoiding the construction of the type instance and the method invocation overhead; and it creates a binary domain for the UDT, enabling the construction of histograms, indexes, and histograms for values of the type.</span></span> <span data-ttu-id="40e29-177">Daher haben normalisierte UDTs ein Leistungsprofil, das dem von systemeigenen integrierten Typen sehr ähnlich ist, wenn es sich um Vorgänge handelt, die keinen Methodenaufruf erfordern.</span><span class="sxs-lookup"><span data-stu-id="40e29-177">Consequently, normalized UDTs have a very similar performance profile to the native built-in types for operations that do not involve method invocation.</span></span>  
  
### <a name="scalable-memory-usage"></a><span data-ttu-id="40e29-178">Skalierbare Speicherverwendung</span><span class="sxs-lookup"><span data-stu-id="40e29-178">Scalable Memory Usage</span></span>  
 <span data-ttu-id="40e29-179">Damit die verwaltete Speicherbereinigung in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)] problemlos durchgeführt und skaliert werden kann, vermeiden Sie einzelne große Zuteilungen.</span><span class="sxs-lookup"><span data-stu-id="40e29-179">In order for managed garbage collection to perform and scale well in [!INCLUDE[ssNoVersion](../../../includes/ssnoversion-md.md)], avoid large, single allocation.</span></span> <span data-ttu-id="40e29-180">Zuteilungen, die größer als 88 Kilobytes (KB) sind, werden im Objektheap für große Objekte positioniert. Das führt dazu, dass die automatische Speicherbereinigung schlechter ausgeführt und skaliert wird als bei vielen kleinen Zuteilungen.</span><span class="sxs-lookup"><span data-stu-id="40e29-180">Allocations greater than 88 kilobytes (KB) in size will be placed on the Large Object Heap, which will cause garbage collection to perform and scale much worse than many smaller allocations.</span></span> <span data-ttu-id="40e29-181">Wenn Sie beispielsweise ein großes mehrdimensionales Array zuteilen müssen, empfiehlt es sich, ein verzweigtes Array zuzuteilen.</span><span class="sxs-lookup"><span data-stu-id="40e29-181">For example, if you need to allocate a large multi-dimensional array, it is better to allocate a jagged (scattered) array.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="40e29-182">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="40e29-182">See Also</span></span>  
 [<span data-ttu-id="40e29-183">Benutzerdefinierte CLR-Typen</span><span class="sxs-lookup"><span data-stu-id="40e29-183">CLR User-Defined Types</span></span>](../clr-integration-database-objects-user-defined-types/clr-user-defined-types.md)  
  
  
