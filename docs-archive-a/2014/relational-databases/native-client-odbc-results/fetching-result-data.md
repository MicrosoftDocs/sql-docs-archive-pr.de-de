---
title: Abrufen von Ergebnisdaten | Microsoft-Dokumentation
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- SQLFetchScroll function
- SQL Server Native Client ODBC driver, result sets
- ODBC applications, result sets
- data types [ODBC], fetching
- SQLBindCol function
- result sets [ODBC], fetching
- fetching [ODBC]
- ODBC data types, fetching
- SQLFetch function
- SQL Server Native Client ODBC driver, data types
- SQLGetData function
ms.assetid: b289c7fb-5017-4d7e-a2d3-19401e9fc4cd
author: rothja
ms.author: jroth
ms.openlocfilehash: 7eb038d431dd7f733c36e5913d72cdc6a161acad
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/04/2020
ms.locfileid: "87725653"
---
# <a name="fetching-result-data"></a><span data-ttu-id="63c19-102">Abrufen von Ergebnisdaten</span><span class="sxs-lookup"><span data-stu-id="63c19-102">Fetching Result Data</span></span>
  <span data-ttu-id="63c19-103">Eine ODBC-Anwendung bietet drei Optionen zum Abrufen von Ergebnisdaten.</span><span class="sxs-lookup"><span data-stu-id="63c19-103">An ODBC application has three options for fetching result data.</span></span>  
  
 <span data-ttu-id="63c19-104">Die erste Option basiert auf [SQLBindCol](../native-client-odbc-api/sqlbindcol.md).</span><span class="sxs-lookup"><span data-stu-id="63c19-104">The first option is based on [SQLBindCol](../native-client-odbc-api/sqlbindcol.md).</span></span> <span data-ttu-id="63c19-105">Vor dem Abrufen des Resultsets verwendet die Anwendung **SQLBindCol** , um jede Spalte im Resultset an eine Programm Variable zu binden.</span><span class="sxs-lookup"><span data-stu-id="63c19-105">Before fetching the result set, the application uses **SQLBindCol** to bind each column in the result set to a program variable.</span></span> <span data-ttu-id="63c19-106">Nachdem die Spalten gebunden wurden, überträgt der Treiber die Daten der aktuellen Zeile in die an die Resultsetspalten gebundenen Variablen, wenn **SQLFetch** oder [SQLFetchScroll](../native-client-odbc-api/sqlfetchscroll.md)von der Anwendung aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="63c19-106">After the columns have been bound, the driver transfers the data of the current row into the variables bound to the result set columns each time the application calls **SQLFetch** or [SQLFetchScroll](../native-client-odbc-api/sqlfetchscroll.md).</span></span> <span data-ttu-id="63c19-107">Der Treiber führt Datenkonvertierungen durch, wenn die Resultsetspalte und die Programmvariable verschiedene Datentypen aufweisen.</span><span class="sxs-lookup"><span data-stu-id="63c19-107">The driver handles data conversions if the result set column and program variable have different data types.</span></span> <span data-ttu-id="63c19-108">Wenn die Anwendung SQL_ATTR_ROW_ARRAY_SIZE auf einen Wert größer als 1 festgelegt ist, kann Sie Ergebnis Spalten an Variablen Arrays binden, die alle für jeden **SQLFetchScroll**-Befehl ausgefüllt werden.</span><span class="sxs-lookup"><span data-stu-id="63c19-108">If the application has SQL_ATTR_ROW_ARRAY_SIZE set greater than 1, it can bind result columns to arrays of variables, which will all be filled on each call to **SQLFetchScroll**.</span></span>  
  
 <span data-ttu-id="63c19-109">Die zweite Option basiert auf [SQLGetData](../native-client-odbc-api/sqlgetdata.md).</span><span class="sxs-lookup"><span data-stu-id="63c19-109">The second option is based on [SQLGetData](../native-client-odbc-api/sqlgetdata.md).</span></span> <span data-ttu-id="63c19-110">Die Anwendung verwendet nicht **SQLBindCol** , um Resultsetspalten an Programmvariablen zu binden.</span><span class="sxs-lookup"><span data-stu-id="63c19-110">The application does not use **SQLBindCol** to bind result set columns to program variables.</span></span> <span data-ttu-id="63c19-111">Nach jedem Aufruf von **SQLFetch**Ruft die Anwendung **SQLGetData** einmal für jede Spalte im Resultset auf.</span><span class="sxs-lookup"><span data-stu-id="63c19-111">After each call to **SQLFetch**, the application calls **SQLGetData** once for each column in the result set.</span></span> <span data-ttu-id="63c19-112">**SQLGetData** weist den Treiber an, Daten aus einer bestimmten Resultsetspalte in eine bestimmte Programm Variable zu übertragen, und gibt die Datentypen der Spalte und der Variablen an.</span><span class="sxs-lookup"><span data-stu-id="63c19-112">**SQLGetData** instructs the driver to transfer data from a specific result set column to a specific program variable and specifies the data types of the column and variable.</span></span> <span data-ttu-id="63c19-113">Dies ermöglicht es dem Treiber, Daten zu konvertieren, wenn die Datentypen der Ergebnisspalte und der Programmvariablen nicht übereinstimmen.</span><span class="sxs-lookup"><span data-stu-id="63c19-113">This allows the driver to convert data if the result column and program variable have different data types.</span></span> <span data-ttu-id="63c19-114">**Text**-, **ntext**-und **Image** -Spalten sind in der Regel zu groß, um Sie in eine Programm Variable zu integrieren, können aber trotzdem mithilfe von **SQLGetData**abgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="63c19-114">**Text**, **ntext**, and **image** columns are typically too large to fit into a program variable but can still be retrieved using **SQLGetData**.</span></span> <span data-ttu-id="63c19-115">Wenn die **Text**-, **ntext**-oder **Image** -Daten in der Ergebnisspalte größer als die Programm Variable sind, gibt **SQLGetData** SQL_SUCCESS_WITH_INFO und SQLSTATE 01004 (String Data, Right truncated) zurück.</span><span class="sxs-lookup"><span data-stu-id="63c19-115">If the **text**, **ntext**, or **image** data in the result column is larger than the program variable, **SQLGetData** returns SQL_SUCCESS_WITH_INFO and SQLSTATE 01004 (string data, right truncated).</span></span> <span data-ttu-id="63c19-116">Aufeinanderfolgende Aufrufe von **SQLGetData** geben aufeinander folgende Blöcke der **Text** -oder **Bilddaten** zurück.</span><span class="sxs-lookup"><span data-stu-id="63c19-116">Successive calls to **SQLGetData** return successive chunks of the **text** or **image** data.</span></span> <span data-ttu-id="63c19-117">Wenn das Ende der Daten erreicht ist, gibt **SQLGetData** SQL_SUCCESS zurück.</span><span class="sxs-lookup"><span data-stu-id="63c19-117">When the end of the data is reached, **SQLGetData** returns SQL_SUCCESS.</span></span> <span data-ttu-id="63c19-118">Jeder Abruf gibt einen Satz von Zeilen oder ein Rowset zurück, wenn SQL_ATTR_ROW_ARRAY_SIZE größer als 1 ist.</span><span class="sxs-lookup"><span data-stu-id="63c19-118">Each fetch returns a set of rows, or rowset, if SQL_ATTR_ROW_ARRAY_SIZE is greater than 1.</span></span> <span data-ttu-id="63c19-119">Vor der Verwendung von **SQLGetData**müssen Sie zuerst **SQLSetPos** verwenden, um eine bestimmte Zeile im Rowset als aktuelle Zeile anzugeben.</span><span class="sxs-lookup"><span data-stu-id="63c19-119">Before using **SQLGetData**, you must first use **SQLSetPos** to specify a specific row within the rowset as the current row.</span></span>  
  
 <span data-ttu-id="63c19-120">Die dritte Möglichkeit besteht darin, eine Mischung aus **SQLBindCol** und **SQLGetData**zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="63c19-120">The third option is to use a mix of **SQLBindCol** and **SQLGetData**.</span></span> <span data-ttu-id="63c19-121">Eine Anwendung könnte z. b. die ersten zehn Spalten eines Resultsets binden und dann bei jedem Abruf dreimal **SQLGetData** aufrufen, um die Daten aus drei ungebundenen Spalten abzurufen.</span><span class="sxs-lookup"><span data-stu-id="63c19-121">An application could, for example, bind the first ten columns of a result set and then, on each fetch, call **SQLGetData** three times to retrieve the data from three unbound columns.</span></span> <span data-ttu-id="63c19-122">Dies wird normalerweise verwendet, wenn ein Resultset mindestens eine **Text** -oder **Image** -Spalte enthält.</span><span class="sxs-lookup"><span data-stu-id="63c19-122">This would typically be used when a result set contains one or more **text** or **image** columns.</span></span>  
  
 <span data-ttu-id="63c19-123">Abhängig von den Cursor Optionen, die für das Resultset festgelegt sind, kann eine Anwendung auch die Scrolloptionen von **SQLFetchScroll** verwenden, um einen Bildlauf um das Resultset durchzuführen.</span><span class="sxs-lookup"><span data-stu-id="63c19-123">Depending on the cursor options set for the result set, an application can also use the scrolling options of **SQLFetchScroll** to scroll around the result set.</span></span>  
  
 <span data-ttu-id="63c19-124">Die übermäßige Verwendung von **SQLBindCol** , um eine Resultsetspalte an eine Programm Variable zu binden, ist aufwendig, da **SQLBindCol** bewirkt, dass ein ODBC-Treiber Arbeitsspeicher belegt.</span><span class="sxs-lookup"><span data-stu-id="63c19-124">Excess use of **SQLBindCol** to bind a result set column to a program variable is expensive because **SQLBindCol** causes an ODBC driver to allocate memory.</span></span> <span data-ttu-id="63c19-125">Wenn Sie eine Ergebnisspalte an eine Variable binden, bleibt diese Bindung wirksam, bis Sie entweder [SQLFreeHandle](../native-client-odbc-api/sqlfreehandle.md) aufzurufen, um das Anweisungs Handle freizugeben, oder [SQLFreeStmt](../native-client-odbc-api/sqlfreestmt.md) aufzurufen, wobei *fOption* auf SQL_UNBIND festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="63c19-125">When you bind a result column to a variable, that binding remains in effect until you either call [SQLFreeHandle](../native-client-odbc-api/sqlfreehandle.md) to free the statement handle or call [SQLFreeStmt](../native-client-odbc-api/sqlfreestmt.md) with *fOption* set to SQL_UNBIND.</span></span> <span data-ttu-id="63c19-126">Die Bindungen werden nicht automatisch rückgängig gemacht, wenn die Anweisung abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="63c19-126">The bindings are not automatically undone when the statement completes.</span></span>  
  
 <span data-ttu-id="63c19-127">Diese Logik ermöglicht Ihnen das effektive Ausführen derselben SELECT-Anweisung mehrere Male mit verschiedenen Parametern.</span><span class="sxs-lookup"><span data-stu-id="63c19-127">This logic allows you to effectively deal with executing the same SELECT statement several times with different parameters.</span></span> <span data-ttu-id="63c19-128">Da das Resultset dieselbe Struktur beibehält, können Sie das Resultset einmal binden, alle SELECT-Anweisungen verarbeiten und dann **SQLFreeStmt** mit der *Option fOption* auf SQL_UNBIND nach der letzten Ausführung festlegen.</span><span class="sxs-lookup"><span data-stu-id="63c19-128">Because the result set keeps the same structure, you can bind the result set once, process all the SELECT statements, then call **SQLFreeStmt** with *fOption* set to SQL_UNBIND after the last execution.</span></span> <span data-ttu-id="63c19-129">Sie sollten **SQLBindCol** nicht aufrufen, um die Spalten in einem Resultset zu binden, ohne zuerst **SQLFreeStmt** aufzurufen, wobei *fOption* auf SQL_UNBIND festgelegt ist, um vorherige Bindungen freizugeben.</span><span class="sxs-lookup"><span data-stu-id="63c19-129">You should not call **SQLBindCol** to bind the columns in a result set without first calling **SQLFreeStmt** with *fOption* set to SQL_UNBIND to free any previous bindings.</span></span>  
  
 <span data-ttu-id="63c19-130">Wenn Sie **SQLBindCol**verwenden, können Sie entweder zeilenweise oder spaltenweise Bindung durchführen.</span><span class="sxs-lookup"><span data-stu-id="63c19-130">When using **SQLBindCol**, you can either do row-wise or column-wise binding.</span></span> <span data-ttu-id="63c19-131">Zeilenbezogene Bindungen sind etwas schneller als spaltenbezogene Bindungen.</span><span class="sxs-lookup"><span data-stu-id="63c19-131">Row-wise binding is somewhat faster than column-wise binding.</span></span>  
  
 <span data-ttu-id="63c19-132">Sie können **SQLGetData** verwenden, um Daten auf Spalten Basis abzurufen, anstatt Resultsetspalten mithilfe von **SQLBindCol**zu binden.</span><span class="sxs-lookup"><span data-stu-id="63c19-132">You can use **SQLGetData** to retrieve data on a column-by-column basis instead of binding result set columns using **SQLBindCol**.</span></span> <span data-ttu-id="63c19-133">Wenn ein Resultset nur wenige Zeilen enthält, ist die Verwendung von **SQLGetData** anstelle von **SQLBindCol** schneller. Andernfalls bietet **SQLBindCol** die beste Leistung.</span><span class="sxs-lookup"><span data-stu-id="63c19-133">If a result set contains only a few rows, using **SQLGetData** instead of **SQLBindCol** is faster; otherwise, **SQLBindCol** gives the best performance.</span></span> <span data-ttu-id="63c19-134">Wenn Sie die Daten nicht immer im selben Satz von Variablen ablegen, sollten Sie **SQLGetData** anstelle der ständig erneuten Bindung verwenden.</span><span class="sxs-lookup"><span data-stu-id="63c19-134">If you do not always put the data in the same set of variables, you should use **SQLGetData** instead of constantly rebinding.</span></span> <span data-ttu-id="63c19-135">Sie können **SQLGetData** nur für Spalten verwenden, die in der SELECT-Liste enthalten sind, nachdem alle Spalten mit **SQLBindCol**gebunden wurden.</span><span class="sxs-lookup"><span data-stu-id="63c19-135">You can only use **SQLGetData** on columns that are in the select list after all columns are bound with **SQLBindCol**.</span></span> <span data-ttu-id="63c19-136">Die Spalte muss auch nach allen Spalten angezeigt werden, für die Sie **SQLGetData**bereits verwendet haben.</span><span class="sxs-lookup"><span data-stu-id="63c19-136">The column must also appear after any columns on which you have already used **SQLGetData**.</span></span>  
  
 <span data-ttu-id="63c19-137">Die ODBC-Funktionen, die sich mit dem Verschieben von Daten in oder aus Programmvariablen wie **SQLGetData**, **SQLBindCol**und [SQLBindParameter](../native-client-odbc-api/sqlbindparameter.md)befassen, unterstützen die implizite Datentyp Konvertierung.</span><span class="sxs-lookup"><span data-stu-id="63c19-137">The ODBC functions that deal with moving data into or out of program variables, such as **SQLGetData**, **SQLBindCol**, and [SQLBindParameter](../native-client-odbc-api/sqlbindparameter.md), support implicit data type conversion.</span></span> <span data-ttu-id="63c19-138">Wenn beispielsweise eine Anwendung eine Spalte mit ganzen Zahlen an eine Zeichenfolgen-Programmvariable bindet, konvertiert der Treiber automatisch die Daten aus einer ganzen Zahl in ein Zeichen, bevor sie in der Programmvariablen abgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="63c19-138">For example, if an application binds an integer column to a character string program variable, the driver automatically converts the data from integer to character before placing it into the program variable.</span></span>  
  
 <span data-ttu-id="63c19-139">Datenkonvertierungen in Anwendungen sollten reduziert werden.</span><span class="sxs-lookup"><span data-stu-id="63c19-139">Data conversion in applications should be minimized.</span></span> <span data-ttu-id="63c19-140">Nur wenn eine Datenkonvertierung für die von der Anwendung durchgeführte Verarbeitung erforderlich ist, sollten Anwendungen Spalten und Parameter an Programmvariablen desselben Datentyps binden.</span><span class="sxs-lookup"><span data-stu-id="63c19-140">Unless data conversion is required for the processing done by the application, applications should bind columns and parameters to program variables of the same data type.</span></span> <span data-ttu-id="63c19-141">Wenn die Daten von einem Typ in einen anderen konvertiert werden müssen, ist es effektiver, wenn der Treiber die Konvertierung durchführt, anstatt dies in der Anwendung durchzuführen.</span><span class="sxs-lookup"><span data-stu-id="63c19-141">If the data must be converted from one type to another, however, it is more efficient to have the driver do the conversion than doing it in the application.</span></span> <span data-ttu-id="63c19-142">Der ODBC-Treiber für [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client überträgt normalerweise einfach Daten direkt aus den Netzwerkpuffern an die Variablen der Anwendung.</span><span class="sxs-lookup"><span data-stu-id="63c19-142">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver normally just transfers data directly from the network buffers to the variables of the application.</span></span> <span data-ttu-id="63c19-143">Wenn Sie die Datenkonvertierung durch den Treiber anfordern, zwingt dies den Treiber, die Daten zu puffern und CPU-Zyklen für das Konvertieren der Daten zu verwenden.</span><span class="sxs-lookup"><span data-stu-id="63c19-143">Requesting the driver to do data conversion forces the driver to buffer the data and use CPU cycles to convert the data.</span></span>  
  
 <span data-ttu-id="63c19-144">Programmvariablen sollten groß genug sein, um Daten zu speichern, die aus einer Spalte übertragen wurden, mit Ausnahme von **Text**-, **ntext**-und **Image** -Daten.</span><span class="sxs-lookup"><span data-stu-id="63c19-144">Program variables should be large enough to hold data transferred in from a column, except for **text**, **ntext**, and **image** data.</span></span> <span data-ttu-id="63c19-145">Wenn eine Anwendung versucht, Resultsetdaten abzurufen und in einer Variablen abzulegen, die für die Aufnahme dieser Daten zu klein ist, generiert der Treiber eine Warnung.</span><span class="sxs-lookup"><span data-stu-id="63c19-145">If an application attempts to retrieve result set data and place it into a variable that is too small to hold it, the driver generates a warning.</span></span> <span data-ttu-id="63c19-146">Dies zwingt den Treiber, Speicher für die Meldung zu belegen, und sowohl der Treiber als auch die Anwendung müssen CPU-Zyklen für die Verarbeitung der Meldung und die Durchführung der Fehlerbehandlung aufwenden.</span><span class="sxs-lookup"><span data-stu-id="63c19-146">This forces the driver to allocate memory for the message, and the driver and application both have to spend CPU cycles processing the message and doing error handling.</span></span> <span data-ttu-id="63c19-147">Die Anwendung sollte entweder eine Variable zuordnen, die groß genug ist, die abgerufenen Daten aufzunehmen, oder die SUBSTRING-Funktion in der Auswahlliste verwenden, um die Größe der Spalte im Resultset zu reduzieren.</span><span class="sxs-lookup"><span data-stu-id="63c19-147">The application should either allocate a variable large enough to hold the data being retrieved or use the SUBSTRING function in the select list to reduce the size of the column in the result set.</span></span>  
  
 <span data-ttu-id="63c19-148">Beim Verwenden von SQL_C_DEFAULT zur Angabe des Typs der C-Variablen müssen Sie mit Bedacht vorgehen.</span><span class="sxs-lookup"><span data-stu-id="63c19-148">Care must be taken when using SQL_C_DEFAULT to specify the type of the C variable.</span></span> <span data-ttu-id="63c19-149">SQL_C_DEFAULT gibt an, dass der Typ der C-Variablen mit dem SQL-Datentyp der Spalte oder des Parameters übereinstimmt.</span><span class="sxs-lookup"><span data-stu-id="63c19-149">SQL_C_DEFAULT specifies that the type of the C variable matches the SQL data type of the column or parameter.</span></span> <span data-ttu-id="63c19-150">Wenn SQL_C_DEFAULT für eine **ntext**-, **NCHAR**-oder **nvarchar** -Spalte angegeben ist, werden Unicode-Daten an die Anwendung zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="63c19-150">If SQL_C_DEFAULT is specified for an **ntext**, **nchar**, or **nvarchar** column, Unicode data is returned to the application.</span></span> <span data-ttu-id="63c19-151">Dies kann verschiedene Probleme verursachen, wenn die Anwendung nicht codiert wurde, um Unicode-Daten zu behandeln.</span><span class="sxs-lookup"><span data-stu-id="63c19-151">This can cause various problems if the application has not been coded to handle Unicode data.</span></span> <span data-ttu-id="63c19-152">Die gleichen Probleme können mit dem Datentyp **uniqueidentifier** (SQL_GUID) auftreten.</span><span class="sxs-lookup"><span data-stu-id="63c19-152">The same types of problems can occur with the **uniqueidentifier** (SQL_GUID) data type.</span></span>  
  
 <span data-ttu-id="63c19-153">**Text**-, **ntext**-und **Image** -Daten sind in der Regel zu groß, um in eine einzelne Programm Variable zu passen, und werden in der Regel mit **SQLGetData** anstelle von **SQLBindCol**verarbeitet.</span><span class="sxs-lookup"><span data-stu-id="63c19-153">**text**, **ntext**, and **image** data is typically too large to fit into a single program variable, and is usually processed with **SQLGetData** instead of **SQLBindCol**.</span></span> <span data-ttu-id="63c19-154">Bei der Verwendung von Server Cursorn [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] wird der Native Client-ODBC-Treiber so optimiert, dass die Daten für ungebundene **Text**-, **ntext**-oder **Image** -Spalten zum Zeitpunkt der Zeilen Abruf nicht übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="63c19-154">When using server cursors, the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Native Client ODBC driver is optimized to not transmit the data for unbound **text**, **ntext**, or **image** columns at the time the row is fetched.</span></span> <span data-ttu-id="63c19-155">Die **Text**-, **ntext**-oder **Image** -Daten werden erst dann vom Server abgerufen, wenn die Anwendung **SQLGetData** für die Spalte ausgibt.</span><span class="sxs-lookup"><span data-stu-id="63c19-155">The **text**, **ntext**, or **image** data is not actually retrieved from the server until the application issues **SQLGetData** for the column.</span></span>  
  
 <span data-ttu-id="63c19-156">Diese Optimierung kann auf Anwendungen angewendet werden, sodass keine Text-, **ntext**-oder **Image** -Daten angezeigt werden, während ein Benutzer einen **Bildlauf**nach oben oder unten durchführt.</span><span class="sxs-lookup"><span data-stu-id="63c19-156">This optimization can be applied to applications so that no **text**, **ntext**, or **image** data is displayed while a user is scrolling up and down a cursor.</span></span> <span data-ttu-id="63c19-157">Nachdem der Benutzer eine Zeile ausgewählt hat, kann die Anwendung **SQLGetData** aufrufen, um die **Text**-, **ntext**-oder **Image** -Daten abzurufen.</span><span class="sxs-lookup"><span data-stu-id="63c19-157">After the user selects a row, the application can call **SQLGetData** to retrieve the **text**, **ntext**, or **image** data.</span></span> <span data-ttu-id="63c19-158">Dadurch wird die Übertragung von **Text**-, **ntext**-oder **Image** -Daten für alle Zeilen, die der Benutzer nicht ausgewählt hat, und die Übertragung sehr großer Datenmengen gespart.</span><span class="sxs-lookup"><span data-stu-id="63c19-158">This saves transmitting the **text**, **ntext**, or **image** data for any of the rows the user does not select and can save the transmission of very large amounts of data.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="63c19-159">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="63c19-159">See Also</span></span>  
 [<span data-ttu-id="63c19-160">Verarbeitungsergebnisse &#40;ODBC-&#41;</span><span class="sxs-lookup"><span data-stu-id="63c19-160">Processing Results &#40;ODBC&#41;</span></span>](processing-results-odbc.md)  
  
  
