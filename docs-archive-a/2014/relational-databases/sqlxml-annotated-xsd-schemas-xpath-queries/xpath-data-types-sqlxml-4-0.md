---
title: XPath-Datentypen (SQLXML 4,0) | Microsoft-Dokumentation
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: xml
ms.topic: reference
helpviewer_keywords:
- mapping XDR types to XPath types [SQLXML]
- data types [XPath]
- arithmetic operators
- mapping data types [SQLXML]
- relational operators [SQLXML]
- node-set [SQLXML]
- data types [SQLXML], XPath
- XPath operators [SQLXML]
- XDR data type [SQLXML]
- equality operators [SQLXML]
- XPath conversions [SQLXML]
- converting data types [SQLXML]
- Boolean operators
- XPath queries [SQLXML], data types
- XPath data types [SQLXML]
- operators [SQLXML]
ms.assetid: a90374bf-406f-4384-ba81-59478017db68
author: rothja
ms.author: jroth
ms.openlocfilehash: 846fc5a17ac97d30b6f0ab65fee176ac459c20cc
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/04/2020
ms.locfileid: "87619733"
---
# <a name="xpath-data-types-sqlxml-40"></a><span data-ttu-id="70e03-102">XPath-Datentypen (SQLXML 4.0)</span><span class="sxs-lookup"><span data-stu-id="70e03-102">XPath Data Types (SQLXML 4.0)</span></span>
  [!INCLUDE[msCoName](../../includes/msconame-md.md)]<span data-ttu-id="70e03-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], XPath und XML-Schema (XSD) weisen sehr unterschiedliche Datentypen auf.</span><span class="sxs-lookup"><span data-stu-id="70e03-103">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], XPath, and XML Schema (XSD) have very different data types.</span></span> <span data-ttu-id="70e03-104">Zum Beispiel verfügt XPath nicht über Ganzzahl- oder Datumsdatentypen, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] und XSD hingegen über mehrere.</span><span class="sxs-lookup"><span data-stu-id="70e03-104">For example, XPath does not have integer or date data types, but [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] and XSD have many.</span></span> <span data-ttu-id="70e03-105">XSD gibt Zeitwerte auf die Nanosekunde genau an, während die Genauigkeit von [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] höchstens 1/300 Sekunde beträgt.</span><span class="sxs-lookup"><span data-stu-id="70e03-105">XSD uses nanosecond precision for time values, and [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] uses at most 1/300-second precision.</span></span> <span data-ttu-id="70e03-106">Einen Datentyp einem anderen zuzuordnen ist deshalb nicht immer möglich.</span><span class="sxs-lookup"><span data-stu-id="70e03-106">Consequently, mapping one data type to another is not always possible.</span></span> <span data-ttu-id="70e03-107">Weitere Informationen zum Mapping von [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] Datentypen zu XSD-Datentypen finden Sie unter [Datentyp Umwandlungen und die SQL: datatype-Anmerkung &#40;SQLXML 4,0&#41;](../sqlxml-annotated-xsd-schemas-using/data-type-coercions-and-the-sql-datatype-annotation-sqlxml-4-0.md).</span><span class="sxs-lookup"><span data-stu-id="70e03-107">For more information about mapping [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] data types to XSD data types, see [Data Type Coercions and the sql:datatype Annotation &#40;SQLXML 4.0&#41;](../sqlxml-annotated-xsd-schemas-using/data-type-coercions-and-the-sql-datatype-annotation-sqlxml-4-0.md).</span></span>  
  
 <span data-ttu-id="70e03-108">XPath verfügt über drei Datentypen: `string`, `number` und `boolean`.</span><span class="sxs-lookup"><span data-stu-id="70e03-108">XPath has three data types: `string`, `number`, and `boolean`.</span></span> <span data-ttu-id="70e03-109">Beim `number`-Datentyp handelt es sich stets um einen IEEE 754-Gleitkommawert mit doppelter Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="70e03-109">The `number` data type is always an IEEE 754 double-precision floating-point.</span></span> <span data-ttu-id="70e03-110">Der- [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `float(53)` Datentyp ist der XPath am nächsten `number` .</span><span class="sxs-lookup"><span data-stu-id="70e03-110">The [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]`float(53)` data type is the closest to XPath `number`.</span></span> <span data-ttu-id="70e03-111">Allerdings entspricht `float(53)` IEEE 754 nicht genau.</span><span class="sxs-lookup"><span data-stu-id="70e03-111">However, `float(53)` is not exactly IEEE 754.</span></span> <span data-ttu-id="70e03-112">Zum Beispiel wird weder NaN (Not-a-Number) noch Unendlichkeit verwendet.</span><span class="sxs-lookup"><span data-stu-id="70e03-112">For example, neither NaN (Not-a-Number) nor infinity is used.</span></span> <span data-ttu-id="70e03-113">Wenn man versucht, eine nicht numerische Zeichenfolge in `number` zu konvertieren und eine Division durch Null durchzuführen, tritt ein Fehler auf.</span><span class="sxs-lookup"><span data-stu-id="70e03-113">Attempting to convert a nonnumeric string to `number` and trying to divide by zero results in an error.</span></span>  
  
## <a name="xpath-conversions"></a><span data-ttu-id="70e03-114">XPath-Konvertierungen</span><span class="sxs-lookup"><span data-stu-id="70e03-114">XPath Conversions</span></span>  
 <span data-ttu-id="70e03-115">Wenn Sie eine XPath-Abfrage wie `OrderDetail[@UnitPrice > "10.0"]` verwenden, können implizite und explizite Datentypkonvertierungen den Sinn der Abfrage leicht verändern.</span><span class="sxs-lookup"><span data-stu-id="70e03-115">When you use an XPath query such as `OrderDetail[@UnitPrice > "10.0"]`, implicit and explicit data type conversions can change the meaning of the query in subtle ways.</span></span> <span data-ttu-id="70e03-116">Deshalb sollte nachvollzogen werden können, wie XPath-Datentypen implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="70e03-116">Therefore, it is important to understand how XPath data types are implemented.</span></span> <span data-ttu-id="70e03-117">Die XPath-Sprachspezifikation, XML Path Language (XPath), Version 1,0 W3C, vorgeschlagene Empfehlung 8. Oktober 1999, finden Sie auf der W3C-Website unter http://www.w3.org/TR/1999/PR-xpath-19991008.html .</span><span class="sxs-lookup"><span data-stu-id="70e03-117">The XPath language specification, XML Path Language (XPath) version 1.0 W3C Proposed Recommendation 8 October 1999, can be found at the W3C Web site at http://www.w3.org/TR/1999/PR-xpath-19991008.html.</span></span>  
  
 <span data-ttu-id="70e03-118">XPath-Operatoren werden in vier Kategorien unterteilt:</span><span class="sxs-lookup"><span data-stu-id="70e03-118">XPath operators are divided into four categories:</span></span>  
  
-   <span data-ttu-id="70e03-119">Boolesche Operatoren (AND, OR)</span><span class="sxs-lookup"><span data-stu-id="70e03-119">Boolean operators (and, or)</span></span>  
  
-   <span data-ttu-id="70e03-120">Relationale Operatoren ( \<, > , \<=, > =)</span><span class="sxs-lookup"><span data-stu-id="70e03-120">Relational operators (\<, >, \<=, >=)</span></span>  
  
-   <span data-ttu-id="70e03-121">Gleichheitsoperatoren (=, !=)</span><span class="sxs-lookup"><span data-stu-id="70e03-121">Equality operators (=, !=)</span></span>  
  
-   <span data-ttu-id="70e03-122">Arithmetische Operatoren (+, -, \*, DIV, MOD)</span><span class="sxs-lookup"><span data-stu-id="70e03-122">Arithmetic operators (+, -, \*, div, mod)</span></span>  
  
 <span data-ttu-id="70e03-123">Bei jeder Operatorkategorie werden die Operanden auf andere Art und Weise konvertiert.</span><span class="sxs-lookup"><span data-stu-id="70e03-123">Each category of operator converts its operands differently.</span></span> <span data-ttu-id="70e03-124">XPath-Operatoren konvertieren ihre Operanden gegebenenfalls implizit.</span><span class="sxs-lookup"><span data-stu-id="70e03-124">XPath operators implicitly convert their operands if necessary.</span></span> <span data-ttu-id="70e03-125">Arithmetische Operatoren konvertieren ihre Operanden in den Typ `number` und geben einen Zahlenwert aus.</span><span class="sxs-lookup"><span data-stu-id="70e03-125">Arithmetic operators convert their operands to `number`, and result in a number value.</span></span> <span data-ttu-id="70e03-126">Boolesche Operatoren konvertieren ihre Operanden in den Typ `boolean` und geben einen booleschen Wert aus.</span><span class="sxs-lookup"><span data-stu-id="70e03-126">Boolean operators convert their operands to `boolean`, and result in a Boolean value.</span></span> <span data-ttu-id="70e03-127">Relationale Operatoren und Gleichheitsoperatoren geben einen booleschen Wert aus.</span><span class="sxs-lookup"><span data-stu-id="70e03-127">Relational operators and equality operators result in a Boolean value.</span></span> <span data-ttu-id="70e03-128">Allerdings verfügen sie, je nach dem ursprünglichen Datentyp ihrer Operanden, über unterschiedliche Konvertierungsregeln (siehe Tabelle).</span><span class="sxs-lookup"><span data-stu-id="70e03-128">However, they have different conversion rules depending on the original data types of their operands, as shown in this table.</span></span>  
  
|<span data-ttu-id="70e03-129">Operand</span><span class="sxs-lookup"><span data-stu-id="70e03-129">Operand</span></span>|<span data-ttu-id="70e03-130">Relationaler Operator</span><span class="sxs-lookup"><span data-stu-id="70e03-130">Relational operator</span></span>|<span data-ttu-id="70e03-131">Gleichheitsoperator</span><span class="sxs-lookup"><span data-stu-id="70e03-131">Equality operator</span></span>|  
|-------------|-------------------------|-----------------------|  
|<span data-ttu-id="70e03-132">Beide Operanden sind Knotensätze.</span><span class="sxs-lookup"><span data-stu-id="70e03-132">Both operands are node-sets.</span></span>|<span data-ttu-id="70e03-133">TRUE ist nur dann gegeben, wenn sich der eine Knoten in einem Satz und der andere Knoten im zweiten Satz befindet, sodass der Vergleich ihrer `string`-Werte TRUE ergibt.</span><span class="sxs-lookup"><span data-stu-id="70e03-133">TRUE if and only if there is a node in one set and a node in the second set such that the comparison of their `string` values is TRUE.</span></span>|<span data-ttu-id="70e03-134">Identisch.</span><span class="sxs-lookup"><span data-stu-id="70e03-134">Same.</span></span>|  
|<span data-ttu-id="70e03-135">Bei dem einen handelt sich um einen Knotensatz, bei dem anderen um den Typ `string`.</span><span class="sxs-lookup"><span data-stu-id="70e03-135">One is a node-set, the other a `string`.</span></span>|<span data-ttu-id="70e03-136">TRUE ist nur dann gegeben, wenn sich ein Knoten im Knotensatz befindet und bei der Konvertierung in `number` der Vergleich mit dem in `string` konvertierten Datentyp `number` TRUE ergibt.</span><span class="sxs-lookup"><span data-stu-id="70e03-136">TRUE if and only if there is a node in the node-set such that when converted to `number`, the comparison of it with the `string` converted to `number` is TRUE.</span></span>|<span data-ttu-id="70e03-137">TRUE ist nur dann gegeben, wenn sich ein Knoten im Knotensatz befindet und bei der Konvertierung in `string` der Vergleich mit dem Typ `string` TRUE ergibt.</span><span class="sxs-lookup"><span data-stu-id="70e03-137">TRUE if and only if there is a node in the node-set such that when converted to `string`, the comparison of it with the `string` is TRUE.</span></span>|  
|<span data-ttu-id="70e03-138">Bei dem einen handelt sich um einen Knotensatz, bei dem anderen um den Typ `number`.</span><span class="sxs-lookup"><span data-stu-id="70e03-138">One is a node-set, the other a `number`.</span></span>|<span data-ttu-id="70e03-139">TRUE ist nur dann gegeben, wenn sich ein Knoten im Knotensatz befindet und bei der Konvertierung in `number` der Vergleich mit dem Typ `number` TRUE ergibt.</span><span class="sxs-lookup"><span data-stu-id="70e03-139">TRUE if and only if there is a node in the node-set such that when converted to `number`, the comparison of it with the `number` is TRUE.</span></span>|<span data-ttu-id="70e03-140">Identisch.</span><span class="sxs-lookup"><span data-stu-id="70e03-140">Same.</span></span>|  
|<span data-ttu-id="70e03-141">Bei dem einen handelt sich um einen Knotensatz, bei dem anderen um den Typ `boolean`.</span><span class="sxs-lookup"><span data-stu-id="70e03-141">One is a node-set, the other a `boolean`.</span></span>|<span data-ttu-id="70e03-142">TRUE ist nur dann gegeben, wenn sich ein Knoten im Knotensatz befindet und bei der Konvertierung in `boolean` und anschließend in `number` der Vergleich mit dem in `boolean` konvertierten Typ `number` TRUE ergibt.</span><span class="sxs-lookup"><span data-stu-id="70e03-142">TRUE if and only if there is a node in the node-set such that when converted to `boolean` and then to `number`, the comparison of it with the `boolean` converted to `number` is TRUE.</span></span>|<span data-ttu-id="70e03-143">TRUE ist nur dann gegeben, wenn sich ein Knoten im Knotensatz befindet und bei der Konvertierung in `boolean` der Vergleich mit dem Typ `boolean` TRUE ergibt.</span><span class="sxs-lookup"><span data-stu-id="70e03-143">TRUE if and only if there is a node in the node-set such that when converted to `boolean`, the comparison of it with the `boolean` is TRUE.</span></span>|  
|<span data-ttu-id="70e03-144">In beiden Fällen handelt es sich nicht um einen Knotensatz.</span><span class="sxs-lookup"><span data-stu-id="70e03-144">Neither is a node-set.</span></span>|<span data-ttu-id="70e03-145">Konvertieren Sie beide Operanden in den Typ `number`, und führen Sie dann einen Vergleich durch.</span><span class="sxs-lookup"><span data-stu-id="70e03-145">Convert both operands to `number` and then compare.</span></span>|<span data-ttu-id="70e03-146">Konvertieren Sie beide Operanden in einen gängigen Typ , und führen Sie dann einen Vergleich durch.</span><span class="sxs-lookup"><span data-stu-id="70e03-146">Convert both operands to a common type and then compare.</span></span> <span data-ttu-id="70e03-147">Führen Sie eine Konvertierung in den Typ `boolean` durch, wenn es sich um den Typ `boolean` handelt, oder in den Typ `number`, wenn es sich um den Typ `number` handelt. Andernfalls führen Sie eine Konvertierung in den Typ `string` durch.</span><span class="sxs-lookup"><span data-stu-id="70e03-147">Convert to `boolean` if either is `boolean`, `number` if either is `number`; otherwise, convert to `string`.</span></span>|  
  
> [!NOTE]  
>  <span data-ttu-id="70e03-148">Da relationale XPath-Operatoren ihre Operanden stets in den Typ `number` konvertieren, sind `string`-Vergleiche nicht möglich.</span><span class="sxs-lookup"><span data-stu-id="70e03-148">Because XPath relational operators always convert their operands to `number`, `string` comparisons are not possible.</span></span> <span data-ttu-id="70e03-149">Um Datenvergleiche zu ermöglichen, bietet SQL Server 2000 bei der XPath-Spezifikation folgende Möglichkeit: Wenn ein relationaler Operator einen Typ `string` mit einem Typ `string`, einen Knotensatz mit einem Typ `string` oder einen als Zeichenkette angegebenen Knotensatz mit einem als Zeichenkette angegebenen Knotensatz vergleicht, erfolgt ein `string`-Vergleich (kein `number`-Vergleich).</span><span class="sxs-lookup"><span data-stu-id="70e03-149">To include date comparisons, SQL Server 2000 offers this variation to the XPath specification: When a relational operator compares a `string` to a `string`, a node-set to a `string`, or a string-valued node-set to a string-valued node-set, a `string` comparison (not a `number` comparison) is performed.</span></span>  
  
## <a name="node-set-conversions"></a><span data-ttu-id="70e03-150">Konvertierungen von Knotensätzen</span><span class="sxs-lookup"><span data-stu-id="70e03-150">Node-Set Conversions</span></span>  
 <span data-ttu-id="70e03-151">Konvertierungen von Knotensätzen sind nicht immer intuitiv.</span><span class="sxs-lookup"><span data-stu-id="70e03-151">Node-set conversions are not always intuitive.</span></span> <span data-ttu-id="70e03-152">Die Konvertierung eines Knotensatzes in den Typ `string` erfolgt anhand des Zeichenkettenwerts des ersten Knotens des Satzes.</span><span class="sxs-lookup"><span data-stu-id="70e03-152">A node-set is converted to a `string` by taking the string value of only the first node in the set.</span></span> <span data-ttu-id="70e03-153">Bei der Konvertierung eines Knotensatzes in den Typ `number` wird dieser zunächst in den Typ `string` und anschließend der Typ `string` in den Typ `number` konvertiert.</span><span class="sxs-lookup"><span data-stu-id="70e03-153">A node-set is converted to `number` by converting it to `string`, and then converting `string` to `number`.</span></span> <span data-ttu-id="70e03-154">Ein Knotensatz wird in den Typ `boolean` konvertiert, indem sein Vorhandensein überprüft wird.</span><span class="sxs-lookup"><span data-stu-id="70e03-154">A node-set is converted to `boolean` by testing for its existence.</span></span>  
  
> [!NOTE]  
>  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="70e03-155">führt bei Knotensätzen keine Positionalauswahl durch: Die XPath-Abfrage `Customer[3]` beispielsweise bezieht sich auf den dritten Kunden; eine solche Positionalauswahl wird in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="70e03-155">does not perform positional selection on node-sets: for example, the XPath query `Customer[3]` means the third customer; this type of positional selection is not supported in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="70e03-156">Aus diesem Grund wurden die Konvertierungen, bei denen gemäß XPath-Spezifikation ein Knotensatz in den Typ `string` oder in den Typ `number` konvertiert wird, nicht implementiert.</span><span class="sxs-lookup"><span data-stu-id="70e03-156">Therefore, the node-set-to-`string` or node-set-to-`number` conversions as described by the XPath specification are not implemented.</span></span> <span data-ttu-id="70e03-157">Die Semantik von [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] bezieht sich auf "ein" Vorkommnis, während die XPath-Spezifikation "das erste" Vorkommnis bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="70e03-157">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] uses "any" semantics wherever the XPath specification specifies "first" semantics.</span></span> <span data-ttu-id="70e03-158">Beispielsweise wählt die XPath-Abfrage basierend auf der W3C-XPath-Spezifikation `Order[OrderDetail/@UnitPrice > 10.0]` diese Bestellungen mit dem ersten **OrderDetail** aus, das einen **UnitPrice** größer als 10,0 hat.</span><span class="sxs-lookup"><span data-stu-id="70e03-158">For example, based on the W3C XPath specification, the XPath query `Order[OrderDetail/@UnitPrice > 10.0]` selects those orders with the first **OrderDetail** that has a **UnitPrice** greater than 10.0.</span></span> <span data-ttu-id="70e03-159">In [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] wählt diese XPath-Abfrage diese Bestellungen mit allen **OrderDetails** aus, deren **UnitPrice** größer als 10,0 ist.</span><span class="sxs-lookup"><span data-stu-id="70e03-159">In [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], this XPath query selects those orders with any **OrderDetail** that has a **UnitPrice** greater than 10.0.</span></span>  
  
 <span data-ttu-id="70e03-160">Bei Konvertierungen in den Typ `boolean` wird das Vorhandensein überprüft; aus diesem Grund entspricht die XPath-Abfrage `Products[@Discontinued=true()]` dem SQL-Ausdruck "Products.Discontinued is not null", nicht dem SQL-Ausdruck "Products.Discontinued = 1".</span><span class="sxs-lookup"><span data-stu-id="70e03-160">Conversion to `boolean` generates an existence test; therefore, the XPath query `Products[@Discontinued=true()]` is equivalent to the SQL expression "Products.Discontinued is not null", not the SQL expression "Products.Discontinued = 1".</span></span> <span data-ttu-id="70e03-161">Damit die Abfrage dem letztgenannten SQL-Ausdruck entspricht, konvertierten Sie den Knotensatz zunächst in einen anderen Typ als `boolean`, etwa `number`.</span><span class="sxs-lookup"><span data-stu-id="70e03-161">To make the query equivalent to the latter SQL expression, first convert the node-set to a non-`boolean` type, such as `number`.</span></span> <span data-ttu-id="70e03-162">Beispielsweise `Products[number(@Discontinued) = true()]`.</span><span class="sxs-lookup"><span data-stu-id="70e03-162">For example, `Products[number(@Discontinued) = true()]`.</span></span>  
  
 <span data-ttu-id="70e03-163">Da die meisten Operatoren gemäß Definition als TRUE gelten, wenn sie für einen beliebigen oder einen einzigen der Knoten im Knotensatz TRUE sind, ergeben diese Operationen stets FALSE, wenn der Knotensatz leer ist.</span><span class="sxs-lookup"><span data-stu-id="70e03-163">Because most operators are defined to be TRUE if they are TRUE for any or one of the nodes in the node-set, these operations always evaluate to FALSE if the node-set is empty.</span></span> <span data-ttu-id="70e03-164">Wenn also A leer ist, gilt sowohl für `A = B` als auch `A != B` FALSE, für `not(A=B)` und `not(A!=B)` hingegen gilt TRUE.</span><span class="sxs-lookup"><span data-stu-id="70e03-164">Thus, if A is empty, both `A = B` and `A != B` are FALSE, and `not(A=B)` and `not(A!=B)` are TRUE.</span></span>  
  
 <span data-ttu-id="70e03-165">In der Regel ist ein Attribut oder ein Element, das auf eine Spalte verweist, vorhanden, sobald der Wert jener Spalte in der Datenbank ungleich `null` ist.</span><span class="sxs-lookup"><span data-stu-id="70e03-165">Usually, an attribute or element that maps to a column exists if the value of that column in the database is not `null`.</span></span> <span data-ttu-id="70e03-166">Elemente, die auf Zeilen verweisen, sind vorhanden, sobald untergeordnete Elemente vorhanden sind.</span><span class="sxs-lookup"><span data-stu-id="70e03-166">Elements that map to rows exist if any of their children exist.</span></span>  
  
> [!NOTE]  
>  <span data-ttu-id="70e03-167">Mit der `is-constant`-Anmerkung versehene Elemente sind immer vorhanden.</span><span class="sxs-lookup"><span data-stu-id="70e03-167">Elements annotated with `is-constant` always exist.</span></span> <span data-ttu-id="70e03-168">Infolgedessen können XPath-Prädikate nicht für `is-constant`-Elemente verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="70e03-168">Consequently, XPath predicates cannot be used on `is-constant` elements.</span></span>  
  
 <span data-ttu-id="70e03-169">Wenn ein Knotensatz in den Typ `string` oder `number` konvertiert wird, wird sein XDR-Typ (sofern vorhanden) im mit Anmerkungen versehenen Schema überprüft. Dieser Typ wird dann verwendet, um die erforderliche Konvertierung zu ermitteln.</span><span class="sxs-lookup"><span data-stu-id="70e03-169">When a node-set is converted to `string` or `number`, its XDR type (if any) is inspected in the annotated schema and that type is used to determine the conversion that is required.</span></span>  
  
## <a name="mapping-xdr-data-types-to-xpath-data-types"></a><span data-ttu-id="70e03-170">Zuordnung von XDR-Datentypen und XPath-Datentypen</span><span class="sxs-lookup"><span data-stu-id="70e03-170">Mapping XDR Data Types to XPath Data Types</span></span>  
 <span data-ttu-id="70e03-171">Der XPath-Datentyp eines Knotens wird vom XDR-Datentyp im Schema abgeleitet, wie in der folgenden Tabelle dargestellt ( **die Knoten Mitarbeiter** -ID wird zur Veranschaulichung verwendet).</span><span class="sxs-lookup"><span data-stu-id="70e03-171">The XPath data type of a node is derived from the XDR data type in the schema, as shown in the following table (the node **EmployeeID** is used for illustrative purpose).</span></span>  
  
|<span data-ttu-id="70e03-172">XDR-Datentyp</span><span class="sxs-lookup"><span data-stu-id="70e03-172">XDR data type</span></span>|<span data-ttu-id="70e03-173">Entsprechung</span><span class="sxs-lookup"><span data-stu-id="70e03-173">Equivalent</span></span><br /><br /> <span data-ttu-id="70e03-174">XPath-Datentyp</span><span class="sxs-lookup"><span data-stu-id="70e03-174">XPath data type</span></span>|<span data-ttu-id="70e03-175">Verwendete SQL Server-Konvertierung</span><span class="sxs-lookup"><span data-stu-id="70e03-175">SQL Server conversion used</span></span>|  
|-------------------|------------------------------------|--------------------------------|  
|<span data-ttu-id="70e03-176">Nonebin.base64bin.hex</span><span class="sxs-lookup"><span data-stu-id="70e03-176">Nonebin.base64bin.hex</span></span>|<span data-ttu-id="70e03-177">–</span><span class="sxs-lookup"><span data-stu-id="70e03-177">N/A</span></span>|<span data-ttu-id="70e03-178">KeineEmployeeID</span><span class="sxs-lookup"><span data-stu-id="70e03-178">NoneEmployeeID</span></span>|  
|<span data-ttu-id="70e03-179">boolean</span><span class="sxs-lookup"><span data-stu-id="70e03-179">boolean</span></span>|<span data-ttu-id="70e03-180">boolean</span><span class="sxs-lookup"><span data-stu-id="70e03-180">boolean</span></span>|<span data-ttu-id="70e03-181">CONVERT(bit, EmployeeID)</span><span class="sxs-lookup"><span data-stu-id="70e03-181">CONVERT(bit, EmployeeID)</span></span>|  
|<span data-ttu-id="70e03-182">number, int, float,i1, i2, i4, i8,r4, r8ui1, ui2, ui4, ui8</span><span class="sxs-lookup"><span data-stu-id="70e03-182">number, int, float,i1, i2, i4, i8,r4, r8ui1, ui2, ui4, ui8</span></span>|<span data-ttu-id="70e03-183">number</span><span class="sxs-lookup"><span data-stu-id="70e03-183">number</span></span>|<span data-ttu-id="70e03-184">CONVERT(float(53), EmployeeID)</span><span class="sxs-lookup"><span data-stu-id="70e03-184">CONVERT(float(53), EmployeeID)</span></span>|  
|<span data-ttu-id="70e03-185">id, idref, idrefsentity, entities, enumerationnotation, nmtoken, nmtokens, chardate, Timedate, Time.tz, string, uri, uuid</span><span class="sxs-lookup"><span data-stu-id="70e03-185">id, idref, idrefsentity, entities, enumerationnotation, nmtoken, nmtokens, chardate, Timedate, Time.tz, string, uri, uuid</span></span>|<span data-ttu-id="70e03-186">Zeichenfolge</span><span class="sxs-lookup"><span data-stu-id="70e03-186">string</span></span>|<span data-ttu-id="70e03-187">CONVERT(nvarchar(4000), EmployeeID, 126)</span><span class="sxs-lookup"><span data-stu-id="70e03-187">CONVERT(nvarchar(4000), EmployeeID, 126)</span></span>|  
|<span data-ttu-id="70e03-188">fixed14.4</span><span class="sxs-lookup"><span data-stu-id="70e03-188">fixed14.4</span></span>|<span data-ttu-id="70e03-189">– (es gibt keinen Datentyp in XPath, der dem fixed14.4 XDR-Datentyp entspricht)</span><span class="sxs-lookup"><span data-stu-id="70e03-189">N/A(There is no data type in XPath that is equivalent to the fixed14.4 XDR data type)</span></span>|<span data-ttu-id="70e03-190">CONVERT(money, EmployeeID)</span><span class="sxs-lookup"><span data-stu-id="70e03-190">CONVERT(money, EmployeeID)</span></span>|  
|<span data-ttu-id="70e03-191">date</span><span class="sxs-lookup"><span data-stu-id="70e03-191">date</span></span>|<span data-ttu-id="70e03-192">Zeichenfolge</span><span class="sxs-lookup"><span data-stu-id="70e03-192">string</span></span>|<span data-ttu-id="70e03-193">LEFT(CONVERT(nvarchar(4000), EmployeeID, 126), 10)</span><span class="sxs-lookup"><span data-stu-id="70e03-193">LEFT(CONVERT(nvarchar(4000), EmployeeID, 126), 10)</span></span>|  
|<span data-ttu-id="70e03-194">time</span><span class="sxs-lookup"><span data-stu-id="70e03-194">time</span></span><br /><br /> <span data-ttu-id="70e03-195">time.tz</span><span class="sxs-lookup"><span data-stu-id="70e03-195">time.tz</span></span>|<span data-ttu-id="70e03-196">Zeichenfolge</span><span class="sxs-lookup"><span data-stu-id="70e03-196">string</span></span>|<span data-ttu-id="70e03-197">SUBSTRING(CONVERT(nvarchar(4000), EmployeeID, 126), 1 + CHARINDEX(N'T', CONVERT(nvarchar(4000), EmployeeID, 126)), 24)</span><span class="sxs-lookup"><span data-stu-id="70e03-197">SUBSTRING(CONVERT(nvarchar(4000), EmployeeID, 126), 1 + CHARINDEX(N'T', CONVERT(nvarchar(4000), EmployeeID, 126)), 24)</span></span>|  
  
 <span data-ttu-id="70e03-198">Die Datums-und Uhrzeit Konvertierungen sind so konzipiert, dass Sie funktionieren, ob der Wert in der Datenbank mithilfe des- [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `datetime` Datentyps oder einer gespeichert wird `string` .</span><span class="sxs-lookup"><span data-stu-id="70e03-198">The date and time conversions are designed to work whether the value is stored in the database using the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]`datetime` data type or a `string`.</span></span> <span data-ttu-id="70e03-199">Beachten Sie, dass der [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] `datetime` -Datentyp nicht verwendet `timezone` und eine geringere Genauigkeit aufweist als der XML- `time` Datentyp.</span><span class="sxs-lookup"><span data-stu-id="70e03-199">Note that the [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]`datetime` data type does not use `timezone` and has a smaller precision than the XML `time` data type.</span></span> <span data-ttu-id="70e03-200">Um den `timezone`-Datentyp aufzunehmen oder eine höhere Genauigkeit zu gewährleisten, speichern Sie die Daten mithilfe eines `string`-Typs in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span><span class="sxs-lookup"><span data-stu-id="70e03-200">To include the `timezone` data type or additional precision, store the data in [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] using a `string` type.</span></span>  
  
 <span data-ttu-id="70e03-201">Wenn ein Knoten vom XDR-Datentyp in den XPath-Datentyp konvertiert wird, müssen mitunter weitere Konvertierungen vorgenommen werden (von einem XPath-Datentyp in einen anderen XPath-Datentyp).</span><span class="sxs-lookup"><span data-stu-id="70e03-201">When a node is converted from its XDR data type to the XPath data type, additional conversion is sometimes necessary (from one XPath data type to another XPath data type).</span></span> <span data-ttu-id="70e03-202">Ein Beispiel ist die folgende XPath-Abfrage:</span><span class="sxs-lookup"><span data-stu-id="70e03-202">For example, consider this XPath query:</span></span>  
  
```  
(@m + 3) = 4  
```  
  
 <span data-ttu-id="70e03-203">Wenn vom @m `fixed14.4` XDR-Datentyp ist, wird die Konvertierung vom XDR-Datentyp in den XPath-Datentyp mit folgenden Aktionen durchgeführt:</span><span class="sxs-lookup"><span data-stu-id="70e03-203">If @m is of the `fixed14.4` XDR data type, the conversion from XDR data type to XPath data type is accomplished using:</span></span>  
  
```  
CONVERT(money, m)  
```  
  
 <span data-ttu-id="70e03-204">Bei dieser Konvertierung wird der Knoten `m` von `fixed14.4` in `money` konvertiert.</span><span class="sxs-lookup"><span data-stu-id="70e03-204">In this conversion, the node `m` is converted from `fixed14.4` to `money`.</span></span> <span data-ttu-id="70e03-205">Um den Wert 3 hinzuzufügen, ist jedoch eine zusätzliche Konvertierung erforderlich:</span><span class="sxs-lookup"><span data-stu-id="70e03-205">However, adding the value of 3, requires additional conversion:</span></span>  
  
```  
CONVERT(float(CONVERT(money, m))  
```  
  
 <span data-ttu-id="70e03-206">Der XPath-Ausdruck wird wie folgt ausgewertet:</span><span class="sxs-lookup"><span data-stu-id="70e03-206">The XPath expression is evaluated as:</span></span>  
  
```  
CONVERT(float(CONVERT(money, m)) + CONVERT(float(53), 3) = CONVERT(float(53), 3)  
```  
  
 <span data-ttu-id="70e03-207">Wie in der folgenden Tabelle dargestellt, handelt es sich hierbei um die gleiche Konvertierung wie bei anderen XPath-Ausdrücken (etwa Literalausdrücken oder zusammengesetzten Ausdrücken).</span><span class="sxs-lookup"><span data-stu-id="70e03-207">As shown in the following table, this is the same conversion that is applied for other XPath expressions (such as literals or compound expressions).</span></span>  
  
||||||  
|-|-|-|-|-|  
||<span data-ttu-id="70e03-208">X ist unbekannt</span><span class="sxs-lookup"><span data-stu-id="70e03-208">X is unknown</span></span>|<span data-ttu-id="70e03-209">X ist vom Datentyp `string`</span><span class="sxs-lookup"><span data-stu-id="70e03-209">X is `string`</span></span>|<span data-ttu-id="70e03-210">X ist vom Datentyp `number`</span><span class="sxs-lookup"><span data-stu-id="70e03-210">X is `number`</span></span>|<span data-ttu-id="70e03-211">X ist vom Datentyp `boolean`</span><span class="sxs-lookup"><span data-stu-id="70e03-211">X is `boolean`</span></span>|  
|<span data-ttu-id="70e03-212">string(X)</span><span class="sxs-lookup"><span data-stu-id="70e03-212">string(X)</span></span>|<span data-ttu-id="70e03-213">CONVERT (nvarchar(4000), X, 126)</span><span class="sxs-lookup"><span data-stu-id="70e03-213">CONVERT (nvarchar(4000), X, 126)</span></span>|-|<span data-ttu-id="70e03-214">CONVERT (nvarchar(4000), X, 126)</span><span class="sxs-lookup"><span data-stu-id="70e03-214">CONVERT (nvarchar(4000), X, 126)</span></span>|<span data-ttu-id="70e03-215">CASE WHEN X THEN N'true' ELSE N'false' END</span><span class="sxs-lookup"><span data-stu-id="70e03-215">CASE WHEN X THEN N'true' ELSE N'false' END</span></span>|  
|<span data-ttu-id="70e03-216">number(X)</span><span class="sxs-lookup"><span data-stu-id="70e03-216">number(X)</span></span>|<span data-ttu-id="70e03-217">CONVERT (float(53), X)</span><span class="sxs-lookup"><span data-stu-id="70e03-217">CONVERT (float(53), X)</span></span>|<span data-ttu-id="70e03-218">CONVERT (float(53), X)</span><span class="sxs-lookup"><span data-stu-id="70e03-218">CONVERT (float(53), X)</span></span>|-|<span data-ttu-id="70e03-219">CASE WHEN X THEN 1 ELSE 0 END</span><span class="sxs-lookup"><span data-stu-id="70e03-219">CASE WHEN X THEN 1 ELSE 0 END</span></span>|  
|<span data-ttu-id="70e03-220">boolean(X)</span><span class="sxs-lookup"><span data-stu-id="70e03-220">boolean(X)</span></span>|-|<span data-ttu-id="70e03-221">LEN (X) > 0</span><span class="sxs-lookup"><span data-stu-id="70e03-221">LEN(X) > 0</span></span>|<span data-ttu-id="70e03-222">X != 0</span><span class="sxs-lookup"><span data-stu-id="70e03-222">X != 0</span></span>|-|  
  
## <a name="examples"></a><span data-ttu-id="70e03-223">Beispiele</span><span class="sxs-lookup"><span data-stu-id="70e03-223">Examples</span></span>  
  
### <a name="a-convert-a-data-type-in-an-xpath-query"></a><span data-ttu-id="70e03-224">A.</span><span class="sxs-lookup"><span data-stu-id="70e03-224">A.</span></span> <span data-ttu-id="70e03-225">Konvertieren Sie einen Datentyp in einer XPath-Abfrage</span><span class="sxs-lookup"><span data-stu-id="70e03-225">Convert a data type in an XPath query</span></span>  
 <span data-ttu-id="70e03-226">In der folgenden XPath-Abfrage, die für ein XSD-Schema mit Anmerkungen angegeben ist, wählt die Abfrage alle Employee-Knoten mit dem **Employee** **Eid** -Attribut Wert "e-1" aus, wobei "e-" das Präfix ist, das mithilfe der-Anmerkung angegeben wurde `sql:id-prefix` .</span><span class="sxs-lookup"><span data-stu-id="70e03-226">In the following XPath query specified against an annotated XSD schema, the query selects all **Employee** nodes with the **EmployeeID** attribute value of E-1, where "E-" is the prefix specified using the `sql:id-prefix` annotation.</span></span>  
  
 `Employee[@EmployeeID="E-1"]`  
  
 <span data-ttu-id="70e03-227">Das Prädikat in der Abfrage entspricht dem folgenden SQL-Ausdruck:</span><span class="sxs-lookup"><span data-stu-id="70e03-227">The predicate in the query is equivalent to the SQL expression:</span></span>  
  
 `N'E-' + CONVERT(nvarchar(4000), Employees.EmployeeID, 126) = N'E-1'`  
  
 <span data-ttu-id="70e03-228">Da Mitarbeiter **Eid** einer der `id` `idref` `idrefs` Datentyp Werte (,, `nmtoken` , usw. `nmtokens` ) im XSD-Schema ist, wird Mitarbeiter **Eid** `string` mithilfe der zuvor beschriebenen Konvertierungsregeln in den XPath-Datentyp konvertiert.</span><span class="sxs-lookup"><span data-stu-id="70e03-228">Because **EmployeeID** is one of the `id` (`idref`, `idrefs`, `nmtoken`, `nmtokens`, and so on) data type values in the XSD schema, **EmployeeID** is converted to the `string` XPath data type using the conversion rules described previously.</span></span>  
  
 `CONVERT(nvarchar(4000), Employees.EmployeeID, 126)`  
  
 <span data-ttu-id="70e03-229">Der Zeichenfolge wird das Präfix "E-" hinzugefügt, und das Ergebnis wird dann mit `N'E-1'` verglichen.</span><span class="sxs-lookup"><span data-stu-id="70e03-229">The "E-" prefix is added to the string, and the result is then compared with `N'E-1'`.</span></span>  
  
### <a name="b-perform-several-data-type-conversions-in-an-xpath-query"></a><span data-ttu-id="70e03-230">B.</span><span class="sxs-lookup"><span data-stu-id="70e03-230">B.</span></span> <span data-ttu-id="70e03-231">Führen Sie mehrere Datentypkonvertierungen in einer XPath-Abfrage aus</span><span class="sxs-lookup"><span data-stu-id="70e03-231">Perform several data type conversions in an XPath query</span></span>  
 <span data-ttu-id="70e03-232">Betrachten Sie die folgende, für ein mit Anmerkungen versehenes XSD-Schema angegebene XPath-Abfrage: `OrderDetail[@UnitPrice * @OrderQty > 98]`</span><span class="sxs-lookup"><span data-stu-id="70e03-232">Consider this XPath query specified against an annotated XSD schema: `OrderDetail[@UnitPrice * @OrderQty > 98]`</span></span>  
  
 <span data-ttu-id="70e03-233">Diese XPath-Abfrage gibt alle **\<OrderDetail>** Elemente zurück, die das Prädikat erfüllen `@UnitPrice * @OrderQty > 98` .</span><span class="sxs-lookup"><span data-stu-id="70e03-233">This XPath query returns all the **\<OrderDetail>** elements satisfying the predicate `@UnitPrice * @OrderQty > 98`.</span></span> <span data-ttu-id="70e03-234">Wenn der **UnitPrice** mit einem `fixed14.4` Datentyp im Schema mit Anmerkungen versehen wird, entspricht dieses Prädikat dem SQL-Ausdruck:</span><span class="sxs-lookup"><span data-stu-id="70e03-234">If the **UnitPrice** is annotated with a `fixed14.4` data type in the annotated schema, this predicate is equivalent to the SQL expression:</span></span>  
  
 `CONVERT(float(53), CONVERT(money, OrderDetail.UnitPrice)) * CONVERT(float(53), OrderDetail.OrderQty) > CONVERT(float(53), 98)`  
  
 <span data-ttu-id="70e03-235">Beim Konvertieren der Werte in der XPath-Abfrage wird zunächst der XDR-Datentyp in den XPath-Datentyp konvertiert.</span><span class="sxs-lookup"><span data-stu-id="70e03-235">In converting the values in the XPath query, the first conversion converts the XDR data type to the XPath data type.</span></span> <span data-ttu-id="70e03-236">Da der XSD-Datentyp von **UnitPrice** ist `fixed14.4` , wie in der obigen Tabelle beschrieben, ist dies die erste Konvertierung, die verwendet wird:</span><span class="sxs-lookup"><span data-stu-id="70e03-236">Because the XSD data type of **UnitPrice** is `fixed14.4`, as described in the previous table, this is the first conversion that is used:</span></span>  
  
```  
CONVERT(money, OrderDetail.UnitPrice))   
```  
  
 <span data-ttu-id="70e03-237">Da die arithmetischen Operatoren ihre Operanden in den `number`-XPath-Datentyp konvertieren, erfolgt eine zweite Konvertierung (von einem XPath-Datentyp in einen anderen XPath-Datentyp), bei der der Wert in `float(53)` konvertiert wird (`float(53)` ist nahe am `number`-XPath-Datentyp):</span><span class="sxs-lookup"><span data-stu-id="70e03-237">Because the arithmetic operators convert their operands to the `number` XPath data type, the second conversion (from one XPath data type to another XPath data type) is applied in which the value is converted to `float(53)` (`float(53)` is close to the XPath `number` data type):</span></span>  
  
```  
CONVERT(float(53), CONVERT(money, OrderDetail.UnitPrice))   
```  
  
 <span data-ttu-id="70e03-238">Wenn das **OrderQty** -Attribut keinen XSD-Datentyp aufweist, wird **OrderQty** `number` in einer einzelnen Konvertierung in einen XPath-Datentyp konvertiert:</span><span class="sxs-lookup"><span data-stu-id="70e03-238">Assuming the **OrderQty** attribute has no XSD data type, **OrderQty** is converted to a `number` XPath data type in a single conversion:</span></span>  
  
```  
CONVERT(float(53), OrderDetail.OrderQty)  
```  
  
 <span data-ttu-id="70e03-239">Parallel dazu wird der Wert 98 in den `number`-XPath-Datentyp konvertiert:</span><span class="sxs-lookup"><span data-stu-id="70e03-239">Similarly, the value 98 is converted to the `number` XPath data type:</span></span>  
  
```  
CONVERT(float(53), 98)  
```  
  
> [!NOTE]  
>  <span data-ttu-id="70e03-240">Wenn der im Schema verwendete XSD-Datentyp mit dem in der Datenbank zugrunde gelegten [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]-Datentyp inkompatibel ist oder eine nicht mögliche XPath-Datentypkonvertierung durchgeführt werden soll, sollte [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] einen Fehler melden.</span><span class="sxs-lookup"><span data-stu-id="70e03-240">If the XSD data type used in the schema is incompatible with the underlying [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] data type in the database, or if an impossible XPath data type conversion is performed, [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] may return an error.</span></span> <span data-ttu-id="70e03-241">Wenn das Mitarbeiter-ID-Attribut z. b. **mit der-** Anmerkung versehen ist `id-prefix` , generiert XPath `Employee[@EmployeeID=1]` einen Fehler, **EmployeeID** da Mitarbeiter-ID über die-Anmerkung verfügt `id-prefix` und nicht in konvertiert werden kann `number` .</span><span class="sxs-lookup"><span data-stu-id="70e03-241">For example, if the **EmployeeID** attribute is annotated with `id-prefix` annotation, the XPath `Employee[@EmployeeID=1]` generates an error, because **EmployeeID** has the `id-prefix` annotation and cannot be converted to `number`.</span></span>  
  
  
