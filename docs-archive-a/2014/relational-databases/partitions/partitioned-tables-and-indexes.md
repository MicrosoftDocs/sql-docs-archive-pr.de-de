---
title: Partitionierte Tabellen und Indizes | Microsoft-Dokumentation
ms.custom: ''
ms.date: 06/13/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: ''
ms.topic: conceptual
helpviewer_keywords:
- partitioned tables [SQL Server], about partitioned tables
- partitioned indexes [SQL Server], architecture
- partitioned tables [SQL Server], architecture
- partitioned indexes [SQL Server], about partitioned indexes
ms.assetid: cc5bf181-18a0-44d5-8bd7-8060d227c927
author: MikeRayMSFT
ms.author: mikeray
ms.openlocfilehash: e8d041abcfe491f311e38bc8dab4be4ea253e37c
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/04/2020
ms.locfileid: "87723738"
---
# <a name="partitioned-tables-and-indexes"></a><span data-ttu-id="2e4dc-102">Partitioned Tables and Indexes</span><span class="sxs-lookup"><span data-stu-id="2e4dc-102">Partitioned Tables and Indexes</span></span>
  [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="2e4dc-103">unterstützt die Tabellen- und Indexpartitionierung.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-103">supports table and index partitioning.</span></span> <span data-ttu-id="2e4dc-104">Die Daten partitionierter Tabellen und Indizes werden in Einheiten aufgeteilt, die über mehrere Dateigruppen in einer Datenbank verteilt sein können.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-104">The data of partitioned tables and indexes is divided into units that can be spread across more than one filegroup in a database.</span></span> <span data-ttu-id="2e4dc-105">Die Daten werden horizontal partitioniert, sodass Gruppen von Zeilen einzelnen Partitionen zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-105">The data is partitioned horizontally, so that groups of rows are mapped into individual partitions.</span></span> <span data-ttu-id="2e4dc-106">Alle Partitionen eines einzelnen Indexes oder einer Tabelle müssen sich in der gleichen Datenbank befinden.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-106">All partitions of a single index or table must reside in the same database.</span></span> <span data-ttu-id="2e4dc-107">Die Tabelle oder der Index wird als einzelne logische Entität behandelt, wenn Abfragen oder Aktualisierungen für die Daten ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-107">The table or index is treated as a single logical entity when queries or updates are performed on the data.</span></span> <span data-ttu-id="2e4dc-108">Partitionierte Tabellen und Indizes sind nicht in jeder Edition von [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] verfügbar.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-108">Partitioned tables and indexes are not available in every edition of [!INCLUDE[msCoName](../../includes/msconame-md.md)][!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)].</span></span> <span data-ttu-id="2e4dc-109">Eine Liste der Funktionen, die von den Editionen von [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]unterstützt werden, finden Sie unter [Features Supported by the Editions of SQL Server 2014](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md).</span><span class="sxs-lookup"><span data-stu-id="2e4dc-109">For a list of features that are supported by the editions of [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)], see [Features Supported by the Editions of SQL Server 2014](../../getting-started/features-supported-by-the-editions-of-sql-server-2014.md).</span></span>  
  
> [!IMPORTANT]  
>  [!INCLUDE[ssCurrent](../../includes/sscurrent-md.md)] <span data-ttu-id="2e4dc-110">unterstützt standardmäßig bis zu 15.000 Partitionen.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-110">supports up to 15,000 partitions by default.</span></span> <span data-ttu-id="2e4dc-111">In Versionen vor [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)]war die Anzahl der Partitionen standardmäßig auf 1.000 beschränkt. Auf x86-basierten Systemen ist das Erstellen einer Tabelle oder eines Index mit mehr als 1000 möglich, wird jedoch nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-111">In versions earlier than [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], the number of partitions was limited to 1,000 by default.On x86-based systems, creating a table or index with more than 1000 partitions is possible, but is not supported.</span></span>  
  
## <a name="benefits-of-partitioning"></a><span data-ttu-id="2e4dc-112">Vorteile der Partitionierung</span><span class="sxs-lookup"><span data-stu-id="2e4dc-112">Benefits of Partitioning</span></span>  
 <span data-ttu-id="2e4dc-113">Das Partitionieren großer Tabellen oder Indizes kann die folgenden Vorteile bei der Verwaltung und Leistung haben.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-113">Partitioning large tables or indexes can have the following manageability and performance benefits.</span></span>  
  
-   <span data-ttu-id="2e4dc-114">Sie können Teilmengen von Daten schnell und effizient übertragen und darauf zugreifen, während die Integrität der Datensammlung erhalten bleibt.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-114">You can transfer or access subsets of data quickly and efficiently, while maintaining the integrity of a data collection.</span></span> <span data-ttu-id="2e4dc-115">So dauert beispielsweise ein Vorgang wie das Laden von Daten von einem OLTP-System in ein OLAP-System nur Sekunden, statt Minuten und Stunden, wenn die Daten nicht partitioniert sind.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-115">For example, an operation such as loading data from an OLTP to an OLAP system takes only seconds, instead of the minutes and hours the operation takes when the data is not partitioned.</span></span>  
  
-   <span data-ttu-id="2e4dc-116">Sie können Wartungsvorgänge für eine oder mehrere Partitionen schneller ausführen.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-116">You can perform maintenance operations on one or more partitions more quickly.</span></span> <span data-ttu-id="2e4dc-117">Die Vorgänge sind effizienter, da sie auf nur diese Datenteilmengen abzielen, statt auf die ganze Tabelle.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-117">The operations are more efficient because they target only these data subsets, instead of the whole table.</span></span> <span data-ttu-id="2e4dc-118">Sie können z. B. wählen, Daten in einer oder mehreren Partitionen zu komprimieren oder eine oder mehrere Partitionen eines Indexes neu zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-118">For example, you can choose to compress data in one or more partitions or rebuild one or more partitions of an index.</span></span>  
  
-   <span data-ttu-id="2e4dc-119">Die Abfrageleistung lässt sich, abhängig von den am häufigsten ausgeführten Abfragetypen sowie der Hardwarekonfiguration, möglicherweise verbessern.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-119">You may improve query performance, based on the types of queries you frequently run and on your hardware configuration.</span></span> <span data-ttu-id="2e4dc-120">So kann der Abfrageoptimierer zum Beispiel Gleichheitsjoin-Abfragen zwischen zwei oder mehr partitionierten Tabellen schneller verarbeiten, wenn die Partitionierungsspalten in den Tabellen identisch sind, da die Partitionen selbst verbunden sein können.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-120">For example, the query optimizer can process equi-join queries between two or more partitioned tables faster when the partitioning columns in the tables are the same, because the partitions themselves can be joined.</span></span>  
  
     <span data-ttu-id="2e4dc-121">Beim Sortieren von Daten nach E-A-Operationen geht [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] zunächst nach Partitionen vor.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-121">When [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] performs data sorting for I/O operations, it sorts the data first by partition.</span></span> [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] <span data-ttu-id="2e4dc-122">greift jeweils auf ein Laufwerk zu, wodurch sich die Leistung möglicherweise verringert.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-122">accesses one drive at a time, and this might reduce performance.</span></span> <span data-ttu-id="2e4dc-123">Um die Leistung beim Sortieren von Daten zu verbessern, verteilen Sie die Datendateien der Partitionen über mehrere Datenträger, d. h. durch das Einrichten eines RAID (Redundant Array of Independent Disks).</span><span class="sxs-lookup"><span data-stu-id="2e4dc-123">To improve data sorting performance, stripe the data files of your partitions across more than one disk by setting up a RAID.</span></span> <span data-ttu-id="2e4dc-124">Auf diese Weise kann [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] , obwohl die Daten dabei weiterhin nach Partitionen sortiert werden, auf alle Laufwerke der einzelnen Partitionen gleichzeitig zugreifen.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-124">In this way, although [!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)] still sorts data by partition, it can access all the drives of each partition at the same time.</span></span>  
  
     <span data-ttu-id="2e4dc-125">Darüber hinaus kann die Leistung verbessert werden, indem eine Sperrenausweitung auf Partitionsebene statt auf die gesamte Tabelle angewendet wird.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-125">In addition, you can improve performance by enabling lock escalation at the partition level instead of a whole table.</span></span> <span data-ttu-id="2e4dc-126">Dies kann Sperrenkonflikte für die Tabelle reduzieren.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-126">This can reduce lock contention on the table.</span></span>  
  
## <a name="components-and-concepts"></a><span data-ttu-id="2e4dc-127">Komponenten und Konzepte</span><span class="sxs-lookup"><span data-stu-id="2e4dc-127">Components and Concepts</span></span>  
 <span data-ttu-id="2e4dc-128">Die folgenden Begriffe beziehen sich auf die Tabellen- und Indexpartitionierung.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-128">The following terms are applicable to table and index partitioning.</span></span>  
  
 <span data-ttu-id="2e4dc-129">Partitionsfunktion</span><span class="sxs-lookup"><span data-stu-id="2e4dc-129">Partition function</span></span>  
 <span data-ttu-id="2e4dc-130">Ein Datenbankobjekt, das definiert, wie die Zeilen einer Tabelle oder eines Index basierend auf den Werten bestimmter Spalten, den sogenannten Partitionierungsspalten, einem Satz von Partitionen zugeordnet werden.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-130">A database object that defines how the rows of a table or index are mapped to a set of partitions based on the values of certain column, called a partitioning column.</span></span> <span data-ttu-id="2e4dc-131">Das heißt, die Partitionsfunktion definiert die Anzahl von Partitionen, über die die Tabelle verfügt, und wie die Begrenzungen der Partitionen definiert werden.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-131">That is, the partition function defines the number of partitions that the table will have and how the boundaries of the partitions are defined.</span></span> <span data-ttu-id="2e4dc-132">Angenommen, Sie verfügen über eine Tabelle, die Verkaufsauftragsdaten enthält, und möchten die Tabelle möglicherweise in zwölf (monatliche) Partitionen auf Grundlage einer `datetime`-Spalte (z. B. Verkaufsdatum) partitionieren.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-132">For example, given a table that contains sales order data, you may want to partition the table into twelve (monthly) partitions based on a `datetime` column such as a sales date.</span></span>  
  
 <span data-ttu-id="2e4dc-133">Partitionsschema</span><span class="sxs-lookup"><span data-stu-id="2e4dc-133">Partition scheme</span></span>  
 <span data-ttu-id="2e4dc-134">Ein Datenbankobjekt, das die Partitionen einer Partitionsfunktion Dateigruppen zuordnet.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-134">A database object that maps the partitions of a partition function to a set of filegroups.</span></span> <span data-ttu-id="2e4dc-135">Der wichtigste Grund dafür, dass Partitionen in separaten Dateigruppen platziert werden, besteht darin, sicherzustellen, dass Sie Sicherungsvorgänge unabhängig für Partitionen ausführen können.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-135">The primary reason for placing your partitions on separate filegroups is to make sure that you can independently perform backup operations on partitions.</span></span> <span data-ttu-id="2e4dc-136">Dies liegt daran, dass Sie Sicherungen für einzelne Dateigruppen ausführen können.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-136">This is because you can perform backups on individual filegroups.</span></span>  
  
 <span data-ttu-id="2e4dc-137">Partitionierungsspalte</span><span class="sxs-lookup"><span data-stu-id="2e4dc-137">Partitioning column</span></span>  
 <span data-ttu-id="2e4dc-138">Die Spalte einer Tabelle oder eines Indexes, die von einer Partitionsfunktion zum Partitionieren der Tabelle oder des Indexes verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-138">The column of a table or index that a partition function uses to partition the table or index.</span></span> <span data-ttu-id="2e4dc-139">Berechnete Spalten, die in eine Partitionsfunktion einbezogen werden, müssen explizit als PERSISTED gekennzeichnet sein.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-139">Computed columns that participate in a partition function must be explicitly marked PERSISTED.</span></span> <span data-ttu-id="2e4dc-140">Alle Datentypen, die zum Verwenden als Indexspalten zulässig sind, können als Partitionsspalte verwenden werden, mit Ausnahme des Datentyps `timestamp`.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-140">All data types that are valid for use as index columns can be used as a partitioning column, except `timestamp`.</span></span> <span data-ttu-id="2e4dc-141">Die Datentypen `ntext`, `text`, `image`, `xml`, `varchar(max)`, `nvarchar(max)` oder `varbinary(max)` können nicht angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-141">The `ntext`, `text`, `image`, `xml`, `varchar(max)`, `nvarchar(max)`, or `varbinary(max)` data types cannot be specified.</span></span> <span data-ttu-id="2e4dc-142">Zudem können der benutzerdefinierte CLR-Typ (Common Language Runtime) von Microsoft .NET Framework und die Spalten mit dem Aliasdatentyp nicht angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-142">Also, Microsoft .NET Framework common language runtime (CLR) user-defined type and alias data type columns cannot be specified.</span></span>  
  
 <span data-ttu-id="2e4dc-143">Ausgerichteter Index</span><span class="sxs-lookup"><span data-stu-id="2e4dc-143">Aligned index</span></span>  
 <span data-ttu-id="2e4dc-144">Ein Index, der auf dem gleichen Partitionsschema wie die zugehörige Tabelle aufbaut.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-144">An index that is built on the same partition scheme as its corresponding table.</span></span> <span data-ttu-id="2e4dc-145">Wenn eine Tabelle und ihre Indizes aneinander ausgerichtet sind, kann SQL Server schnell zwischen Partitionen wechseln und gleichzeitig die Partitionsstruktur sowohl der Tabelle als auch ihrer Indizes beibehalten.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-145">When a table and its indexes are in alignment, SQL Server can switch partitions quickly and efficiently while maintaining the partition structure of both the table and its indexes.</span></span> <span data-ttu-id="2e4dc-146">Ein Index muss nicht an derselben benannten Partitionsfunktion beteiligt sein, um an ihrer Basistabelle ausgerichtet zu sein.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-146">An index does not have to participate in the same named partition function to be aligned with its base table.</span></span> <span data-ttu-id="2e4dc-147">Allerdings muss die Partitionsfunktion des Indexes und der Basistabelle im Wesentlichen übereinstimmen, und zwar dahingehend, dass 1) die Argumente der Partitionsfunktionen denselben Datentyp haben, dass sie 2) dieselbe Anzahl von Partitionen definieren und dass sie 3) dieselben Begrenzungswerte für Partitionen definieren.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-147">However, the partition function of the index and the base table must be essentially the same, in that 1) the arguments of the partition functions have the same data type, 2) they define the same number of partitions, and 3) they define the same boundary values for partitions.</span></span>  
  
 <span data-ttu-id="2e4dc-148">Nicht ausgerichteter Index</span><span class="sxs-lookup"><span data-stu-id="2e4dc-148">Nonaligned index</span></span>  
 <span data-ttu-id="2e4dc-149">Ein Index, der unabhängig von der zugehörigen Tabelle partitioniert ist.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-149">An index partitioned independently from its corresponding table.</span></span> <span data-ttu-id="2e4dc-150">Das heißt, der Index hat ein anderes Partitionsschema oder wird in einer anderen Dateigruppe als die Basistabelle platziert.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-150">That is, the index has a different partition scheme or is placed on a separate filegroup from the base table.</span></span> <span data-ttu-id="2e4dc-151">Das Entwerfen eines nicht ausgerichteten partitionierten Index kann in den folgenden Fällen nützlich sein:</span><span class="sxs-lookup"><span data-stu-id="2e4dc-151">Designing an nonaligned partitioned index can be useful in the following cases:</span></span>  
  
-   <span data-ttu-id="2e4dc-152">Die Basistabelle ist nicht partitioniert.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-152">The base table has not been partitioned.</span></span>  
  
-   <span data-ttu-id="2e4dc-153">Der Indexschlüssel ist eindeutig und enthält nicht die Partitionierungsspalte der Tabelle.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-153">The index key is unique and it does not contain the partitioning column of the table.</span></span>  
  
-   <span data-ttu-id="2e4dc-154">Sie möchten die Basistabelle an angeordneten Joins mit weiteren Tabellen beteiligen, die unterschiedliche Joinspalten verwenden.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-154">You want the base table to participate in collocated joins with more tables using different join columns.</span></span>  
  
 <span data-ttu-id="2e4dc-155">Partitionsentfernung</span><span class="sxs-lookup"><span data-stu-id="2e4dc-155">Partition elimination</span></span>  
 <span data-ttu-id="2e4dc-156">Der Prozess, durch den der Abfrageoptimierer nur auf relevante Partitionen zugreift, um die Filterkriterien der Abfrage zu erfüllen.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-156">The process by which the query optimizer accesses only the relevant partitions to satisfy the filter criteria of the query.</span></span>  
  
## <a name="performance-guidelines"></a><span data-ttu-id="2e4dc-157">Leistungsrichtlinien</span><span class="sxs-lookup"><span data-stu-id="2e4dc-157">Performance Guidelines</span></span>  
 <span data-ttu-id="2e4dc-158">Die neue, höhere Grenze von 15.000 Partitionen wirkt sich auf den Arbeitsspeicher, Vorgänge mit partitionierten Indizes, DBCC-Befehle und Abfragen aus.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-158">The new, higher limit of 15,000 partitions affects memory, partitioned index operations, DBCC commands, and queries.</span></span> <span data-ttu-id="2e4dc-159">In diesem Abschnitt werden die Auswirkungen auf die Leistung beschrieben, wenn die Anzahl der Partitionen mehr als 1.000 beträgt, und es werden mögliche Problemumgehungen bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-159">This section describes the performance implications of increasing the number of partitions above 1,000 and provides workarounds as needed.</span></span> <span data-ttu-id="2e4dc-160">Dadurch, dass die maximale Anzahl von Partitionen auf 15.000 erhöht wurde, können Sie Daten über einen längeren Zeitraum speichern.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-160">With the limit on the maximum number of partitions being increased to 15,000, you can store data for a longer time.</span></span> <span data-ttu-id="2e4dc-161">Sie sollten Daten jedoch nur so lange beibehalten, wie sie benötigt werden, und darauf achten, dass die Leistung und die Anzahl der Partitionen ausgewogen ist.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-161">However, you should retain data only for as long as it is needed and maintain a balance between performance and number of partitions.</span></span>  
  
### <a name="memory-usage-and-guidelines"></a><span data-ttu-id="2e4dc-162">Speicherauslastung und Richtlinien</span><span class="sxs-lookup"><span data-stu-id="2e4dc-162">Memory Usage and Guidelines</span></span>  
 <span data-ttu-id="2e4dc-163">Es empfiehlt sich, mindestens 16 GB Arbeitsspeicher zu verwenden, wenn eine große Anzahl von Partitionen verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-163">We recommend that you use at least 16 GB of RAM if a large number of partitions are in use.</span></span> <span data-ttu-id="2e4dc-164">Wenn das System nicht über ausreichend Arbeitsspeicher verfügt, kann es bei DML-Anweisungen (Datenbearbeitungssprache), DDL-Anweisungen (Datendefinitionssprache) und anderen Vorgängen aufgrund ungenügenden Arbeitsspeichers zu Fehlern kommen.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-164">If the system does not have enough memory, Data Manipulation Language (DML) statements, Data Definition Language (DDL) statements and other operations can fail due to insufficient memory.</span></span> <span data-ttu-id="2e4dc-165">Bei Systemen mit 16 GB Arbeitsspeicher, die zahlreiche speicherintensive Prozesse ausführen, kann es bei Vorgängen, die für eine große Anzahl von Partitionen ausgeführt werden, zu Fehlern aufgrund von Speicherauslastung kommen.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-165">Systems with 16 GB of RAM that run many memory-intensive processes may run out of memory on operations that run on a large number of partitions.</span></span> <span data-ttu-id="2e4dc-166">Je mehr Arbeitsspeicher Sie über die empfohlenen 16 GB hinaus verwenden, desto geringer ist die Wahrscheinlichkeit, dass Probleme mit der Leistung und Speicherauslastung auftreten.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-166">Therefore, the more memory you have over 16 GB, the less likely you are to encounter performance and memory issues.</span></span>  
  
 <span data-ttu-id="2e4dc-167">Einschränkungen beim Arbeitsspeicher können sich negativ auf die Leistung oder auf die Möglichkeit von SQL Server zum Erstellen eines partitionierten Index auswirken.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-167">Memory limitations can affect the performance or ability of SQL Server to build a partitioned index.</span></span> <span data-ttu-id="2e4dc-168">Das gilt insbesondere für den Fall, wenn der Index nicht an seiner Basistabelle oder an deren gruppierten Index ausgerichtet ist, sofern für die Tabelle bereits ein gruppierter Index erstellt wurde.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-168">This is especially the case when the index is not aligned with its base table or is not aligned with its clustered index, if the table already has a clustered index applied to it.</span></span>  
  
### <a name="partitioned-index-operations"></a><span data-ttu-id="2e4dc-169">Vorgänge für partitionierte Indizes</span><span class="sxs-lookup"><span data-stu-id="2e4dc-169">Partitioned Index Operations</span></span>  
 <span data-ttu-id="2e4dc-170">Einschränkungen beim Arbeitsspeicher können sich negativ auf die Leistung oder auf die Möglichkeit von SQL Server zum Erstellen eines partitionierten Index auswirken.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-170">Memory limitations can affect the performance or ability of SQL Server to build a partitioned index.</span></span> <span data-ttu-id="2e4dc-171">Dies ist insbesondere bei nicht ausgerichteten Indizes der Fall.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-171">This is especially the case with nonaligned indexes.</span></span> <span data-ttu-id="2e4dc-172">Das Erstellen bzw. Neuerstellen von nicht ausgerichteten Indizes für eine Tabelle mit mehr als 1.000 Partitionen ist möglich, wird aber nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-172">Creating and rebuilding nonaligned indexes on a table with more than 1,000 partitions is possible, but is not supported.</span></span> <span data-ttu-id="2e4dc-173">Dies hätte Leistungseinbußen oder eine zu hohe Speicherauslastung während der Vorgänge zur Folge.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-173">Doing so may cause degraded performance or excessive memory consumption during these operations.</span></span>  
  
 <span data-ttu-id="2e4dc-174">Das Erstellen und Neuerstellen von ausgrichteten Indizes kann um so länger dauern, je mehr Partitionen hinzugefügt werden.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-174">Creating and rebuilding aligned indexes could take longer to execute as the number of partitions increases.</span></span> <span data-ttu-id="2e4dc-175">Es empfiehlt sich, nicht mehrere Befehle zum Erstellen und Neuerstellen von Befehlen gleichzeitig auszuführen, da es zu Leistungs- und Arbeitsspeicherproblemen kommen kann.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-175">We recommend that you do not run multiple create and rebuild index commands at the same time as you may run into performance and memory issues.</span></span>  
  
 <span data-ttu-id="2e4dc-176">Wenn SQL Server Sortiervorgänge zum Erstellen partitionierter Indizes durchführt, wird zuerst eine Sortiertabelle für jede Partition erstellt.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-176">When SQL Server performs sorting to build partitioned indexes, it first builds one sort table for each partition.</span></span> <span data-ttu-id="2e4dc-177">Anschließend werden die Sortiertabellen entweder in der jeweiligen Dateigruppe jeder Partition oder in `tempdb` erstellt, wenn die SORT_IN_TEMPDB-Indexoption angegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-177">It then builds the sort tables either in the respective filegroup of each partition or in `tempdb`, if the SORT_IN_TEMPDB index option is specified.</span></span> <span data-ttu-id="2e4dc-178">Jede Sortiertabelle setzt für ihre Erstellung eine Mindestmenge an Arbeitsspeicher voraus.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-178">Each sort table requires a minimum amount of memory to build.</span></span> <span data-ttu-id="2e4dc-179">Wenn Sie einen partitionierten Index erstellen, der an seiner Basistabelle ausgerichtet ist, werden alle Sortiertabellen nacheinander erstellt, was weniger Arbeitsspeicher in Anspruch nimmt.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-179">When you are building a partitioned index that is aligned with its base table, sort tables are built one at a time, using less memory.</span></span> <span data-ttu-id="2e4dc-180">Wenn Sie allerdings einen nicht gruppierten partitionierten Index erstellen, werden alle Sortiertabellen gleichzeitig erstellt.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-180">However, when you are building a nonaligned partitioned index, the sort tables are built at the same time.</span></span> <span data-ttu-id="2e4dc-181">Das heißt, es muss ausreichend Arbeitsspeicher verfügbar sein, um diese gleichzeitigen Sortiervorgänge zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-181">As a result, there must be sufficient memory to handle these concurrent sorts.</span></span> <span data-ttu-id="2e4dc-182">Je größer die Anzahl der Partitionen, desto mehr Arbeitsspeicher wird benötigt.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-182">The larger the number of partitions, the more memory required.</span></span> <span data-ttu-id="2e4dc-183">Die Mindestgröße für jede Sortiertabelle beträgt 40 Seiten für jede Partition mit 8 Kilobyte pro Seite.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-183">The minimum size for each sort table, for each partition, is 40 pages, with 8 kilobytes per page.</span></span> <span data-ttu-id="2e4dc-184">So beansprucht z.&nbsp;B. ein nicht ausgerichteter partitionierter Index mit 100 Partitionen ausreichend Arbeitsspeicher, um 4.000 (40 \* 100) Seiten gleichzeitig seriell sortieren zu können.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-184">For example, a nonaligned partitioned index with 100 partitions requires sufficient memory to serially sort 4,000 (40 \* 100) pages at the same time.</span></span> <span data-ttu-id="2e4dc-185">Wenn dieser Arbeitsspeicher verfügbar ist, ist die Erstellung zwar erfolgreich, jedoch kann die Leistung darunter leiden.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-185">If this memory is available, the build operation will succeed, but performance may suffer.</span></span> <span data-ttu-id="2e4dc-186">Wenn dieser Arbeitsspeicher nicht verfügbar ist, schlägt die Erstellung fehl.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-186">If this memory is not available, the build operation will fail.</span></span> <span data-ttu-id="2e4dc-187">Alternativ erfordert ein ausgerichteter partitionierter Index mit 100 Partitionen nur ausreichend Arbeitsspeicher, um 40 Seiten zu sortieren, da die Sortiervorgänge nicht gleichzeitig durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-187">Alternatively, an aligned partitioned index with 100 partitions requires only sufficient memory to sort 40 pages, because the sorts are not performed at the same time.</span></span>  
  
 <span data-ttu-id="2e4dc-188">Sowohl bei ausgerichteten als auch bei nicht ausgerichteten Indizes kann der Arbeitsspeicherbedarf noch höher sein, wenn SQL Server bei einem Computer mit mehreren Prozessoren Grade der Parallelität beim Erstellungsvorgang verwendet.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-188">For both aligned and nonaligned indexes, the memory requirement can be greater if SQL Server is applying degrees of parallelism to the build operation on a multiprocessor computer.</span></span> <span data-ttu-id="2e4dc-189">Denn je höher die Grade der Parallelität sind, desto größer ist auch der Arbeitsspeicherbedarf.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-189">This is because the greater the degrees of parallelism, the greater the memory requirement.</span></span> <span data-ttu-id="2e4dc-190">Wenn SQL Server z. B. die Grade der Parallelität auf 4 festlegt, benötigt ein nicht ausgerichteter partitionierter Index mit 100 Partitionen ausreichend Arbeitsspeicher, damit vier Prozessoren gleichzeitig jeweils 4.000 Seiten sortieren können – also 16.000 Seiten gleichzeitig.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-190">For example, if SQL Server sets degrees of parallelism to 4, a nonaligned partitioned index with 100 partitions requires sufficient memory for four processors to sort 4,000 pages at the same time, or 16,000 pages.</span></span> <span data-ttu-id="2e4dc-191">Wenn der partitionierte Index ausgerichtet ist, verringert sich der Arbeitsspeicherbedarf auf vier Prozessoren, die jeweils 40 Seiten sortieren – also 160 (4 \* 40) Seiten.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-191">If the partitioned index is aligned, the memory requirement is reduced to four processors sorting 40 pages, or 160 (4 \* 40) pages.</span></span> <span data-ttu-id="2e4dc-192">Sie können die MAXDOP-Indexoption verwenden, um die Grade der Parallelität manuell zu reduzieren.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-192">You can use the MAXDOP index option to manually reduce the degrees of parallelism.</span></span>  
  
### <a name="dbcc-commands"></a><span data-ttu-id="2e4dc-193">DBCC-Befehle</span><span class="sxs-lookup"><span data-stu-id="2e4dc-193">DBCC Commands</span></span>  
 <span data-ttu-id="2e4dc-194">Bei einer größeren Anzahl von Partitionen können DBCC-Befehle mehr Zeit für die Ausführung in Anspruch nehmen, während sich die Anzahl von Partitionen erhöht.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-194">With a larger number of partitions, DBCC commands could take longer to execute as the number of partitions increases.</span></span>  
  
### <a name="queries"></a><span data-ttu-id="2e4dc-195">Abfragen</span><span class="sxs-lookup"><span data-stu-id="2e4dc-195">Queries</span></span>  
 <span data-ttu-id="2e4dc-196">Abfragen, die Partitionsentfernung verwenden, weisen eine vergleichbare oder verbesserte Leistung bei einer größeren Anzahl von Partitionen auf.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-196">Queries that use partition elimination could have comparable or improved performance with larger number of partitions.</span></span> <span data-ttu-id="2e4dc-197">Abfragen, die keine Partitionsentfernung verwenden, nehmen mehr Zeit für die Ausführung in Anspruch, wenn sich die Anzahl der Partitionen erhöht.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-197">Queries that do not use partition elimination could take longer to execute as the number of partitions increases.</span></span>  
  
 <span data-ttu-id="2e4dc-198">Nehmen Sie beispielsweise an, eine Tabelle hat 100 Millionen Zeilen und Spalten `A`, `B`und `C`.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-198">For example, assume a table has 100 million rows and columns `A`, `B`, and `C`.</span></span> <span data-ttu-id="2e4dc-199">In Szenario 1 ist die Tabelle in 1000 Partitionen der Spalte `A`unterteilt.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-199">In scenario 1, the table is divided into 1000 partitions on column `A`.</span></span> <span data-ttu-id="2e4dc-200">In Szenario 2 ist die Tabelle in 10.000 Partitionen der Spalte `A`unterteilt.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-200">In scenario 2, the table is divided into 10,000 partitions on column `A`.</span></span> <span data-ttu-id="2e4dc-201">Eine Abfrage der Tabelle, die über eine WHERE-Klausel verfügt, die nach Spalte `A` filtert, führt die Partitionsentfernung aus und scannt eine Partition.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-201">A query on the table that has a WHERE clause filtering on column `A` will perform partition elimination and scan one partition.</span></span> <span data-ttu-id="2e4dc-202">Die gleiche Abfrage wird in Szenario 2 möglicherweise schneller ausgeführt, da es weniger zu scannende Zeilen in einer Partition gibt.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-202">That same query may run faster in scenario 2 as there are fewer rows to scan in a partition.</span></span> <span data-ttu-id="2e4dc-203">Eine Abfrage, die über eine WHERE-Klausel verfügt, die nach Spalte B filtert, scannt alle Partitionen.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-203">A query that has a WHERE clause filtering on column B will scan all partitions.</span></span> <span data-ttu-id="2e4dc-204">Die Abfrage wird möglicherweise in Szenario 1 schneller als in Szenario 2 ausgeführt, da weniger Partitionen gescannt werden müssen.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-204">The query may run faster in scenario 1 than in scenario 2 as there are fewer partitions to scan.</span></span>  
  
 <span data-ttu-id="2e4dc-205">Abfragen, die Operatoren wie TOP oder MAX/MIN für andere Spalten als die Partitionierungsspalte verwenden, erzielen aufgrund der Partitionierung möglicherweise eine geringere Leistung, da alle Partitionen ausgewertet werden müssen.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-205">Queries that use operators such as TOP or MAX/MIN on columns other than the partitioning column may experience reduced performance with partitioning because all partitions must be evaluated.</span></span>  
  
## <a name="behavior-changes-in-statistics-computation-during-partitioned-index-operations"></a><span data-ttu-id="2e4dc-206">Das Verhalten ändert sich beim Berechnen von Statistiken, während Vorgänge für partitionierte Indizes durchgeführt werden</span><span class="sxs-lookup"><span data-stu-id="2e4dc-206">Behavior Changes in Statistics Computation During Partitioned Index Operations</span></span>  
 <span data-ttu-id="2e4dc-207">Ab [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)]werden Statistiken nicht durch das Scannen aller Zeilen in der Tabelle erstellt, wenn ein partitionierter Index erstellt oder neu erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-207">Beginning with [!INCLUDE[ssSQL11](../../includes/sssql11-md.md)], statistics are not created by scanning all the rows in the table when a partitioned index is created or rebuilt.</span></span> <span data-ttu-id="2e4dc-208">Der Abfrageoptimierer generiert stattdessen Statistiken mithilfe des Standardalgorithmus zur Stichprobenentnahme.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-208">Instead, the query optimizer uses the default sampling algorithm to generate statistics.</span></span> <span data-ttu-id="2e4dc-209">Nachdem eine Datenbank mit partitionierten Indizes aktualisiert wurde, bemerken Sie möglicherweise einen Unterschied in den Histogrammdaten für diese Indizes.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-209">After upgrading a database with partitioned indexes, you may notice a difference in the histogram data for these indexes.</span></span> <span data-ttu-id="2e4dc-210">Diese Änderung des Verhaltens beeinträchtigt die Abfrageleistung möglicherweise nicht.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-210">This change in behavior may not affect query performance.</span></span> <span data-ttu-id="2e4dc-211">Um Statistiken zu partitionierten Indizes durch das Scannen aller Zeilen in der Tabelle abzurufen, verwenden Sie CREATE STATISTICS oder UPDATE STATISTICS mit der FULLSCAN-Klausel.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-211">To obtain statistics on partitioned indexes by scanning all the rows in the table, use CREATE STATISTICS or UPDATE STATISTICS with the FULLSCAN clause.</span></span>  
  
## <a name="related-tasks"></a><span data-ttu-id="2e4dc-212">Related Tasks</span><span class="sxs-lookup"><span data-stu-id="2e4dc-212">Related Tasks</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="2e4dc-213">**Aufgaben**</span><span class="sxs-lookup"><span data-stu-id="2e4dc-213">**Tasks**</span></span>|<span data-ttu-id="2e4dc-214">**Thema**</span><span class="sxs-lookup"><span data-stu-id="2e4dc-214">**Topic**</span></span>|  
|<span data-ttu-id="2e4dc-215">Beschreibt das Erstellen von Partitionsfunktionen und Partitionsschemas sowie deren Anwendung auf eine Tabelle und einen Index.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-215">Describes how to create partition functions and partition schemes and then apply these to a table and index.</span></span>|[<span data-ttu-id="2e4dc-216">Erstellen partitionierter Tabellen und Indizes</span><span class="sxs-lookup"><span data-stu-id="2e4dc-216">Create Partitioned Tables and Indexes</span></span>](create-partitioned-tables-and-indexes.md)|  
|||  
  
## <a name="related-content"></a><span data-ttu-id="2e4dc-217">Verwandte Inhalte</span><span class="sxs-lookup"><span data-stu-id="2e4dc-217">Related Content</span></span>  
 <span data-ttu-id="2e4dc-218">Die folgenden Whitepaper zu partitionierten Tabellen und Indexstrategien sowie Implementierungen sind möglicherweise für Sie interessant.</span><span class="sxs-lookup"><span data-stu-id="2e4dc-218">You may find the following white papers on partitioned table and index strategies and implementations useful.</span></span>  
  
-   <span data-ttu-id="2e4dc-219">[Partitionierte Tabellen- und Indexstrategien für SQL Server 2008](https://msdn.microsoft.com/library/dd578580\(SQL.100\).aspx)</span><span class="sxs-lookup"><span data-stu-id="2e4dc-219">[Partitioned Table and Index Strategies Using SQL Server 2008](https://msdn.microsoft.com/library/dd578580\(SQL.100\).aspx)</span></span>  
  
-   <span data-ttu-id="2e4dc-220">[So implementieren Sie ein automatisch gleitendes Fenster](https://msdn.microsoft.com/library/aa964122\(SQL.90\).aspx)</span><span class="sxs-lookup"><span data-stu-id="2e4dc-220">[How to Implement an Automatic Sliding Window](https://msdn.microsoft.com/library/aa964122\(SQL.90\).aspx)</span></span>  
  
-   [<span data-ttu-id="2e4dc-221">Massenladen in eine partitionierte Tabelle</span><span class="sxs-lookup"><span data-stu-id="2e4dc-221">Bulk Loading into a Partitioned Table</span></span>](https://msdn.microsoft.com/library/cc966380.aspx)  
  
-   [<span data-ttu-id="2e4dc-222">Verbesserte Abfrageverarbeitung bei partitionierten Tabellen und Indizes</span><span class="sxs-lookup"><span data-stu-id="2e4dc-222">Query Processing Enhancements on Partitioned Tables and Indexes</span></span>](https://msdn.microsoft.com/library/ms345599.aspx)  
  
-   [<span data-ttu-id="2e4dc-223">Top 10 Best Practices zum Erstellen von einem umfassenden relationalen Data Warehouse</span><span class="sxs-lookup"><span data-stu-id="2e4dc-223">Top 10 Best Practices for Building a Large Scale Relational Data Warehouse</span></span>](http://sqlcat.com/top10lists/archive/2008/02/06/top-10-best-practices-for-building-a-large-scale-relational-data-warehouse.aspx)  
  
  
