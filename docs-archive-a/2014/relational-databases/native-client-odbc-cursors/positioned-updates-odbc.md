---
title: Positionierte Updates (ODBC) | Microsoft-Dokumentation
ms.custom: ''
ms.date: 03/06/2017
ms.prod: sql-server-2014
ms.reviewer: ''
ms.technology: native-client
ms.topic: reference
helpviewer_keywords:
- SQL Server Native Client ODBC driver, cursors
- SQLSetPos function
- SQLSetCursorName function
- ODBC applications, cursors
- cursors [ODBC], positioned updates
- positioned updates [ODBC]
- ODBC cursors, positioned updates
ms.assetid: ff404e02-630f-474d-b5d4-06442b756991
author: rothja
ms.author: jroth
ms.openlocfilehash: 20272014e32632117e6282e5929d1d21789852df
ms.sourcegitcommit: ad4d92dce894592a259721a1571b1d8736abacdb
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 08/04/2020
ms.locfileid: "87616062"
---
# <a name="positioned-updates-odbc"></a><span data-ttu-id="a53b3-102">Positionierte Updates (ODBC)</span><span class="sxs-lookup"><span data-stu-id="a53b3-102">Positioned Updates (ODBC)</span></span>
  <span data-ttu-id="a53b3-103">ODBC unterstützt zwei Methoden für das Ausführen von positionierten Updates in einem Cursor:</span><span class="sxs-lookup"><span data-stu-id="a53b3-103">ODBC supports two methods for performing positioned updates in a cursor:</span></span>  
  
-   <span data-ttu-id="a53b3-104">**SQLSetPos**</span><span class="sxs-lookup"><span data-stu-id="a53b3-104">**SQLSetPos**</span></span>  
  
-   <span data-ttu-id="a53b3-105">WHERE CURRENT OF-Klausel</span><span class="sxs-lookup"><span data-stu-id="a53b3-105">WHERE CURRENT OF clause</span></span>  
  
 <span data-ttu-id="a53b3-106">Der gängigste Ansatz ist die Verwendung von **SQLSetPos**.</span><span class="sxs-lookup"><span data-stu-id="a53b3-106">The more common approach is to use **SQLSetPos**.</span></span> <span data-ttu-id="a53b3-107">Es bietet die folgenden Optionen.</span><span class="sxs-lookup"><span data-stu-id="a53b3-107">It has the following options.</span></span>  
  
 <span data-ttu-id="a53b3-108">SQL_POSITION</span><span class="sxs-lookup"><span data-stu-id="a53b3-108">SQL_POSITION</span></span>  
 <span data-ttu-id="a53b3-109">Positioniert den Cursor in einer bestimmten Zeile im aktuellen Rowset.</span><span class="sxs-lookup"><span data-stu-id="a53b3-109">Positions the cursor on a specific row in the current rowset.</span></span>  
  
 <span data-ttu-id="a53b3-110">SQL_REFRESH</span><span class="sxs-lookup"><span data-stu-id="a53b3-110">SQL_REFRESH</span></span>  
 <span data-ttu-id="a53b3-111">Aktualisiert die an die Resultsetspalten gebundenen Programmvariablen mit den Werten aus der Zeile, in der der Cursor zurzeit positioniert ist.</span><span class="sxs-lookup"><span data-stu-id="a53b3-111">Refreshes program variables bound to the result set columns with the values from the row the cursor is currently positioned on.</span></span>  
  
 <span data-ttu-id="a53b3-112">SQL_UPDATE</span><span class="sxs-lookup"><span data-stu-id="a53b3-112">SQL_UPDATE</span></span>  
 <span data-ttu-id="a53b3-113">Aktualisiert die aktuelle Zeile im Cursor mit den Werten aus den an die Resultsetspalten gebundenen Programmvariablen.</span><span class="sxs-lookup"><span data-stu-id="a53b3-113">Updates the current row in the cursor with the values stored in the program variables bound to the result set columns.</span></span>  
  
 <span data-ttu-id="a53b3-114">SQL_DELETE</span><span class="sxs-lookup"><span data-stu-id="a53b3-114">SQL_DELETE</span></span>  
 <span data-ttu-id="a53b3-115">Löscht die aktuelle Zeile im Cursor.</span><span class="sxs-lookup"><span data-stu-id="a53b3-115">Deletes the current row in the cursor.</span></span>  
  
 <span data-ttu-id="a53b3-116">**SQLSetPos** können mit jedem Anweisungs Ergebnissatz verwendet werden, wenn die Cursor Attribute des Anweisungs Handles für die Verwendung von Server Cursorn festgelegt sind.</span><span class="sxs-lookup"><span data-stu-id="a53b3-116">**SQLSetPos** can be used with any statement result set when the statement handle cursor attributes are set to use server cursors.</span></span> <span data-ttu-id="a53b3-117">Die Resultsetspalten müssen an Programmvariablen gebunden sein.</span><span class="sxs-lookup"><span data-stu-id="a53b3-117">The result set columns must be bound to program variables.</span></span> <span data-ttu-id="a53b3-118">Sobald die Anwendung eine Zeile abgerufen hat, ruft Sie **SQLSetPos**(SQL_POSTION) auf, um den Cursor in der Zeile zu positionieren.</span><span class="sxs-lookup"><span data-stu-id="a53b3-118">As soon as the application has fetched a row it calls **SQLSetPos**(SQL_POSTION) to position the cursor on the row.</span></span> <span data-ttu-id="a53b3-119">Die Anwendung könnte dann SQLSetPos(SQL_DELETE) aufrufen, um die aktuelle Zeile zu löschen, oder neue Datenwerte in die gebundenen Programmvariablen verschieben und SQLSetPos(SQL_UPDATE) aufrufen, um die aktuelle Zeile zu aktualisieren.</span><span class="sxs-lookup"><span data-stu-id="a53b3-119">The application could then call SQLSetPos(SQL_DELETE) to delete the current row, or it can move new data values into the bound program variables and call SQLSetPos(SQL_UPDATE) to update the current row.</span></span>  
  
 <span data-ttu-id="a53b3-120">Anwendungen können jede Zeile im Rowset mit **SQLSetPos**aktualisieren oder löschen.</span><span class="sxs-lookup"><span data-stu-id="a53b3-120">Applications can update or delete any row in the rowset with **SQLSetPos**.</span></span> <span data-ttu-id="a53b3-121">Das Aufrufen von **SQLSetPos** ist eine bequeme Alternative zum Erstellen und Ausführen einer SQL-Anweisung.</span><span class="sxs-lookup"><span data-stu-id="a53b3-121">Calling **SQLSetPos** is a convenient alternative to constructing and executing an SQL statement.</span></span> <span data-ttu-id="a53b3-122">**SQLSetPos** funktioniert auf dem aktuellen Rowset und kann nur nach einem [SQLFetchScroll](../native-client-odbc-api/sqlfetchscroll.md)-Aufrufvorgang verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="a53b3-122">**SQLSetPos** operates on the current rowset and can be used only after a call to [SQLFetchScroll](../native-client-odbc-api/sqlfetchscroll.md).</span></span>  
  
 <span data-ttu-id="a53b3-123">Die Rowsetgröße wird durch einen Aufrufen von [SQLSetStmtAttr](../native-client-odbc-api/sqlsetstmtattr.md) mit dem Attribut Argument SQL_ATTR_ROW_ARRAY_SIZE festgelegt.</span><span class="sxs-lookup"><span data-stu-id="a53b3-123">Rowset size is set by a call to [SQLSetStmtAttr](../native-client-odbc-api/sqlsetstmtattr.md) with an attribute argument of SQL_ATTR_ROW_ARRAY_SIZE.</span></span> <span data-ttu-id="a53b3-124">**SQLSetPos** verwendet eine neue Rowsetgröße, jedoch erst nach einem-Befehl von **SQLFetch** oder **SQLFetchScroll**.</span><span class="sxs-lookup"><span data-stu-id="a53b3-124">**SQLSetPos** uses a new rowset size, but only after a call to **SQLFetch** or **SQLFetchScroll**.</span></span> <span data-ttu-id="a53b3-125">Wenn z. b. die Rowsetgröße geändert wird, wird **SQLSetPos** aufgerufen und dann **SQLFetch** oder **SQLFetchScroll** aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="a53b3-125">For example, if the rowset size is changed, **SQLSetPos** is called and then **SQLFetch** or **SQLFetchScroll** is called.</span></span> <span data-ttu-id="a53b3-126">Beim Aufrufen von **SQLSetPos** wird die alte Rowsetgröße verwendet, aber **SQLFetch** oder **SQLFetchScroll** verwendet die neue Rowsetgröße.</span><span class="sxs-lookup"><span data-stu-id="a53b3-126">The call to **SQLSetPos** uses the old rowset size, but **SQLFetch** or **SQLFetchScroll** uses the new rowset size.</span></span>  
  
 <span data-ttu-id="a53b3-127">Die erste Zeile im Rowset ist die Zeile 1.</span><span class="sxs-lookup"><span data-stu-id="a53b3-127">The first row in the rowset is row number 1.</span></span> <span data-ttu-id="a53b3-128">Das RowNumber-Argument in **SQLSetPos** muss eine Zeile im Rowset identifizieren. Das heißt, der Wert muss im Bereich zwischen 1 und der Anzahl von Zeilen liegen, die zuletzt abgerufen wurden.</span><span class="sxs-lookup"><span data-stu-id="a53b3-128">The RowNumber argument in **SQLSetPos** must identify a row in the rowset; that is, its value must be in the range between 1 and the number of rows that were most recently fetched.</span></span> <span data-ttu-id="a53b3-129">Diese ist eventuell kleiner als die Rowsetgröße.</span><span class="sxs-lookup"><span data-stu-id="a53b3-129">This may be less than the rowset size.</span></span> <span data-ttu-id="a53b3-130">Wenn RowNumber 0 ist, gilt der Vorgang für jede Zeile im Rowset.</span><span class="sxs-lookup"><span data-stu-id="a53b3-130">If RowNumber is 0, the operation applies to every row in the rowset.</span></span>  
  
 <span data-ttu-id="a53b3-131">Der DELETE-Vorgang von **SQLSetPos** bewirkt, dass die Datenquelle eine oder mehrere ausgewählte Zeilen einer Tabelle löscht.</span><span class="sxs-lookup"><span data-stu-id="a53b3-131">The delete operation of **SQLSetPos** makes the data source delete one or more selected rows of a table.</span></span> <span data-ttu-id="a53b3-132">Zum Löschen von Zeilen mit **SQLSetPos**Ruft die Anwendung **SQLSetPos** auf, wobei Operation auf SQL_DELETE und RowNumber auf die Nummer der zu löschenden Zeile festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="a53b3-132">To delete rows with **SQLSetPos**, the application calls **SQLSetPos** with Operation set to SQL_DELETE and RowNumber set to the number of the row to delete.</span></span> <span data-ttu-id="a53b3-133">Wenn RowNumber 0 ist, werden alle Zeilen im Rowset gelöscht.</span><span class="sxs-lookup"><span data-stu-id="a53b3-133">If RowNumber is 0, all rows in the rowset are deleted.</span></span>  
  
 <span data-ttu-id="a53b3-134">Nach dem zurückkehren von **SQLSetPos** ist die gelöschte Zeile die aktuelle Zeile, und Ihr Status ist SQL_ROW_DELETED.</span><span class="sxs-lookup"><span data-stu-id="a53b3-134">After **SQLSetPos** returns, the deleted row is the current row and its status is SQL_ROW_DELETED.</span></span> <span data-ttu-id="a53b3-135">Die Zeile kann nicht in weiteren positionierten Vorgängen verwendet werden, z. b. bei Aufrufen von [SQLGetData](../native-client-odbc-api/sqlgetdata.md) oder **SQLSetPos**.</span><span class="sxs-lookup"><span data-stu-id="a53b3-135">The row cannot be used in any additional positioned operations, such as calls to [SQLGetData](../native-client-odbc-api/sqlgetdata.md) or **SQLSetPos**.</span></span>  
  
 <span data-ttu-id="a53b3-136">Wenn Sie alle Zeilen des Rowsets löschen (RowNumber ist gleich 0), kann die Anwendung verhindern, dass der Treiber bestimmte Zeilen löscht, indem er das Zeilen Vorgangs Array genau wie für den Aktualisierungs Vorgang von **SQLSetPos**verwendet.</span><span class="sxs-lookup"><span data-stu-id="a53b3-136">When you delete all rows of the rowset (RowNumber is equal to 0), the application can prevent the driver from deleting certain rows by using the row operation array just like for the update operation of **SQLSetPos**.</span></span>  
  
 <span data-ttu-id="a53b3-137">Jede Zeile, die gelöscht wird, sollte eine Zeile sein, die im Resultset vorhanden ist.</span><span class="sxs-lookup"><span data-stu-id="a53b3-137">Every row that is deleted should be a row that exists in the result set.</span></span> <span data-ttu-id="a53b3-138">Wenn die Anwendungspuffer beim Abrufen gefüllt werden und ein Zeilenstatusarray beibehalten wurde, sollten die Werte an jeder Zeilenposition nicht SQL_ROW_DELETED, SQL_ROW_ERROR oder SQL_ROW_NOROW sein.</span><span class="sxs-lookup"><span data-stu-id="a53b3-138">If the application buffers were filled by fetching, and if a row status array has been maintained, its values at each of these row positions should not be SQL_ROW_DELETED, SQL_ROW_ERROR, or SQL_ROW_NOROW.</span></span>  
  
 <span data-ttu-id="a53b3-139">Positionierte Updates können auch mit der WHERE CURRENT OF-Klausel für UPDATE-, DELETE- und INSERT-Anweisungen durchgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="a53b3-139">Positioned updates can also be performed using the WHERE CURRENT OF clause on UPDATE, DELETE, and INSERT statements.</span></span> <span data-ttu-id="a53b3-140">WHERE CURRENT of erfordert einen Cursor Namen, den ODBC generiert, wenn die [SQLGetCursorName](../native-client-odbc-api/sqlgetcursorname.md) -Funktion aufgerufen wird, oder die Sie durch Aufrufen von **SQLSetCursorName**angeben können.</span><span class="sxs-lookup"><span data-stu-id="a53b3-140">WHERE CURRENT OF requires a cursor name that ODBC will generate when the [SQLGetCursorName](../native-client-odbc-api/sqlgetcursorname.md) function is called, or which you can specify by calling **SQLSetCursorName**.</span></span> <span data-ttu-id="a53b3-141">Im Folgenden finden Sie allgemeine Schritte zum Durchführen eines WHERE CURRENT OF-Updates in einer ODBC-Anwendung:</span><span class="sxs-lookup"><span data-stu-id="a53b3-141">The following are general steps used to perform a WHERE CURRENT OF update in an ODBC application:</span></span>  
  
-   <span data-ttu-id="a53b3-142">Aufrufen von **SQLSetCursorName** , um einen Cursor Namen für das Anweisungs Handle festzulegen.</span><span class="sxs-lookup"><span data-stu-id="a53b3-142">Call **SQLSetCursorName** to establish a cursor name for the statement handle.</span></span>  
  
-   <span data-ttu-id="a53b3-143">Erstellen Sie eine SELECT-Anweisung mit einer FOR UPDATE OF-Klausel, und führen Sie sie aus.</span><span class="sxs-lookup"><span data-stu-id="a53b3-143">Build a SELECT statement with a FOR UPDATE OF clause and execute it.</span></span>  
  
-   <span data-ttu-id="a53b3-144">Rufen Sie **SQLFetchScroll** auf, um ein Rowset oder **SQLFetch** zum Abrufen einer Zeile abzurufen.</span><span class="sxs-lookup"><span data-stu-id="a53b3-144">Call **SQLFetchScroll** to retrieve a rowset or **SQLFetch** to retrieve a row.</span></span>  
  
-   <span data-ttu-id="a53b3-145">Aufrufen von **SQLSetPos** (SQL_POSITION), um den Cursor in der Zeile zu positionieren.</span><span class="sxs-lookup"><span data-stu-id="a53b3-145">Call **SQLSetPos** (SQL_POSITION) to position the cursor on the row.</span></span>  
  
-   <span data-ttu-id="a53b3-146">Erstellen Sie eine Update-Anweisung mit einer WHERE CURRENT OF-Klausel, und führen Sie Sie mit dem mit **SQLSetCursorName**festgelegten Cursor Namen aus.</span><span class="sxs-lookup"><span data-stu-id="a53b3-146">Build and execute an UPDATE statement with a WHERE CURRENT OF clause using the cursor name set with **SQLSetCursorName**.</span></span>  
  
 <span data-ttu-id="a53b3-147">Alternativ könnten Sie **sqlgetcursor Name** auch aufrufen, nachdem Sie die SELECT-Anweisung ausgeführt haben, anstatt **sqlsetcursor Name** vor dem Ausführen der SELECT-Anweisung aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="a53b3-147">Alternatively, you could call **SQLGetCursorName** after you execute the SELECT statement instead of calling **SQLSetCursorName** before executing the SELECT statement.</span></span> <span data-ttu-id="a53b3-148">**SQLGetCursorName** gibt einen von ODBC zugewiesenen standardmäßigen Cursor Namen zurück, wenn Sie keinen Cursor Namen mithilfe von **SQLSetCursorName**festlegen.</span><span class="sxs-lookup"><span data-stu-id="a53b3-148">**SQLGetCursorName** returns a default cursor name assigned by ODBC if you do not set a cursor name using **SQLSetCursorName**.</span></span>  
  
 <span data-ttu-id="a53b3-149">**SQLSetPos** wird von WHERE CURRENT of bevorzugt, wenn Sie Server Cursor verwenden.</span><span class="sxs-lookup"><span data-stu-id="a53b3-149">**SQLSetPos** is preferred over WHERE CURRENT OF when you are using server cursors.</span></span> <span data-ttu-id="a53b3-150">Wenn Sie einen statischen, aktualisierbaren Cursor mit der ODBC-Cursorbibliothek verwenden, implementiert die Cursorbibliothek die WHERE CURRENT OF-Updates, indem eine WHERE-Klausel mit den Schlüsselwerten für die zugrunde liegende Tabelle hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="a53b3-150">If you are using a static, updatable cursor with the ODBC cursor library, the cursor library implements WHERE CURRENT OF updates by adding a WHERE clause with the key values for the underlying table.</span></span> <span data-ttu-id="a53b3-151">Dies kann zu nicht beabsichtigten Updates führen, wenn die Schlüssel in der Tabelle nicht eindeutig sind.</span><span class="sxs-lookup"><span data-stu-id="a53b3-151">This can cause unintended updates if the keys in the table are not unique.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a53b3-152">Weitere Informationen</span><span class="sxs-lookup"><span data-stu-id="a53b3-152">See Also</span></span>  
 [<span data-ttu-id="a53b3-153">Verwenden von Cursorn &#40;ODBC-&#41;</span><span class="sxs-lookup"><span data-stu-id="a53b3-153">Using Cursors &#40;ODBC&#41;</span></span>](using-cursors-odbc.md)  
  
  
